<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机图形学（九）Radiosity &amp; Ray Tracing</title>
      <link href="/computer-graphics-09/"/>
      <url>/computer-graphics-09/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（九）Radiosity-amp-Ray-Tracing"><a href="#计算机图形学（九）Radiosity-amp-Ray-Tracing" class="headerlink" title="计算机图形学（九）Radiosity &amp; Ray Tracing"></a>计算机图形学（九）Radiosity &amp; Ray Tracing</h1><h2 id="Radiosity"><a href="#Radiosity" class="headerlink" title="Radiosity"></a>Radiosity</h2><h3 id="1-Radiosity-History"><a href="#1-Radiosity-History" class="headerlink" title="1. Radiosity History"></a>1. Radiosity History</h3><ul><li>In about 1950, Radiosity methods in the engineering field of heat transfer.</li><li>In 1984, Radiosity rendering in computer graphics by Goral et al. of Cornell University. (Cornell Box)</li><li>Lightscape – Notable commercial radiosity engine</li><li><strong>Radiosity</strong> vs. <strong>Ray Tracing</strong><ul><li>Ray tracing is computed in <strong>image-space</strong><ul><li>if the camera is moved, we have to start over</li><li>Can transmit the reflection, refraction and shadow</li></ul></li><li>Radiosity is computed in <strong>object-space</strong><ul><li>View-independent to allow interactive walkthroughs in the scene</li><li>Can transmit the diffuse interreflection</li></ul></li></ul></li></ul><h3 id="2-What-is-Radiosity"><a href="#2-What-is-Radiosity" class="headerlink" title="2. What is Radiosity?"></a>2. What is Radiosity?</h3><ul><li><strong>Concept</strong><ul><li>describes an <strong>equilibrium energy balance</strong>（平衡能量） within an enclosure based on the theory of thermal radiation</li><li>relies on computing the amount of <strong>light energy</strong> transferred among surfaces</li><li>The surfaces are each divided up into one or more smaller surfaces (<strong>patches</strong>)</li><li>All scattering on the patches is <strong>diffuse interreflections</strong> and soft shadows for rendering</li><li>For computing how well the patches can see each other, we have coefficients called <strong>form factors</strong></li></ul></li><li><strong>Radiosity Computing</strong><ul><li>The radiosity energy is in the form of <strong>visible light</strong></li><li>By computing from the geometric orientation (form factor) of two patches, we solve the <strong>radiosity</strong> of each patch by radiosity equations</li><li>Solve <strong>radiosity equations</strong> as a matrix problem and it is a linear system</li><li>Progressive radiosity solves the system iteratively by the several passes</li></ul></li><li><strong>Features of Radiosity</strong><ul><li>For rendering a static scene (no add or modify the objects)</li><li>Can simulate the lighting of the scene with <strong>time-lapse</strong></li><li>Can ramble in the scene by moving view with whole direction other than BSP with the <em>z</em> direction</li></ul></li><li><strong>Processing of Radiosity</strong></li></ul><p><img src="./09-01.png" alt="09-01 Process of Radiosity"></p><h3 id="3-Radiosity-Algorithm"><a href="#3-Radiosity-Algorithm" class="headerlink" title="3. Radiosity Algorithm"></a>3. Radiosity Algorithm</h3><ul><li><strong>Radiosity Equation</strong><ul><li>Calculating the flux L for each patch as the following rendering equation, which consists of two parts</li><li>$L(x’,w’)=E(x’,w’)+\int_{\rho_x’}(w,w’)L(x,w)G(x,x’)V(x,x’)dA$</li><li>emitted radiance from a point x’: E is non-zero only if x’ is emissive (a light <em>source)</em></li><li>Sum of the incident energy which is the contribution from all of the other patches in the scene<ul><li>diffuse coefficient at the point <em>x</em> ‘ from the direction ω to the direction ω ‘</li><li><em>gathering</em> the radiance at point <em>x</em> in the direction ω</li><li>visibility between $x$ and $x’$: $G(x,x’)=\frac{\cos\theta\cos\theta’}{\pi\cdot||x-x’||^2}dA$</li></ul></li></ul></li></ul><h3 id="4-Calculate-Form-Factors"><a href="#4-Calculate-Form-Factors" class="headerlink" title="4. Calculate Form Factors"></a>4. Calculate Form Factors</h3><ul><li><p>Stages in a Radiosity Solution</p><p><img src="./09-02.png" alt="09-02 Stage"></p></li><li><p>Form factor</p><ul><li>$F_{ji}(x,x’)=\frac{\cos\theta\cos\theta’}{\pi\cdot r^2}V(x,x’)dA$</li></ul></li><li><p>Hemicube Algorithm</p></li></ul><h3 id="5-Computing-Radiosity-Equation"><a href="#5-Computing-Radiosity-Equation" class="headerlink" title="5. Computing Radiosity Equation"></a>5. Computing Radiosity Equation</h3><ul><li>Method<ul><li>Gauss-Siedel method, to iterate radiosity for the patch <em>gethering</em> from other patches</li><li>Southwell method, to iterate radiosity for the patch <em>shooting</em> “unshot” radiosity to other patches</li><li>Cohen[1988] restructured the Southwell algorithm by progressive refinement</li></ul></li><li>Ambient<ul><li>When iterating in the beginning steps, some patches are dark. Ambient radiosity term is used only during rendering, not to obtain radiosity solution.</li><li>As the radiosity solution progresses, the ambient contribution must approach zero</li></ul></li></ul><h3 id="6-Advanced-Radiosity"><a href="#6-Advanced-Radiosity" class="headerlink" title="6. Advanced Radiosity"></a>6. Advanced Radiosity</h3><ul><li>Adaptive Subdivision<ul><li>Reducing the number of patches</li><li>Patches are subdivided only is large gradients occur</li><li>The receiving patch are subdivided adaptively as elements but not shooting patch</li></ul></li><li>Discontinuity Meshing<ul><li>Limits of umbra and penumbra<ul><li>Captures nice shadow boundaries</li><li>Complex geometric computation</li><li>The mesh is getting complex</li></ul></li></ul></li><li>Hierarchical Radiosity<ul><li>Group elements when the light exchange is not important<ul><li>Breaks the quadratic complexity </li><li>Control non trivial, memory cost</li></ul></li></ul></li></ul><h2 id="Ray-Tracing"><a href="#Ray-Tracing" class="headerlink" title="Ray Tracing"></a>Ray Tracing</h2><h3 id="1-What-is-Ray-Tracing"><a href="#1-What-is-Ray-Tracing" class="headerlink" title="1. What is Ray Tracing?"></a>1. What is Ray Tracing?</h3><ul><li><strong>Ray Tracing History</strong><ul><li>Ray Casting: Appel, 1968</li><li>CSG and quadrics: Goldstein &amp; Nagel 1971</li><li>Recursive Ray Tracing: Whitted, 1980</li></ul></li><li><strong>Local Illumination Model</strong><ul><li>All lights come from light sources defined within the scene</li></ul></li><li><strong>Global illumination</strong><ul><li>not only <strong>light ray</strong> which comes directly from a light source (<em>direct illumination</em>)</li><li>but also <strong>light rays</strong> from the same source which are reflected by other surfaces in the scene (<em>indirect illumination</em>)</li></ul></li><li><strong>Global Illumination: Ray Tracing</strong><ul><li>Characteristics<ul><li>Generates shadows</li><li>generates mirror image – reflection ray</li><li>generates transparency – refraction ray</li></ul></li></ul></li></ul><h3 id="2-Ray-Casting-and-Shadows"><a href="#2-Ray-Casting-and-Shadows" class="headerlink" title="2. Ray Casting and Shadows"></a>2. Ray Casting and Shadows</h3><ul><li><strong>Ray Casting</strong><ul><li>In real life, a light ray shoots out from a source, hits a surface, then is reflected, and finally entered our eyes</li><li>In ray casting, a ray is generated from the eye point through each pixel on a “virtual screen” of view volume</li><li>Very easy to remove hidden surfaces </li><li>Easy to generate shadows</li></ul></li><li><strong>Ray Casting Algorithm</strong><ul><li>For each ray, to find the closest object blocking the path of that ray</li><li>Compute the pixel color of the object</li><li>Can determine the shadow of the object, whether or not the light will reach that surface</li></ul></li><li><strong>What is Shadows</strong><ul><li>Shadow areas:<ul><li>to be seen from the view position</li><li>not to be seen from light source position</li></ul></li><li>Two types<ul><li><em>Light sources that extend over an area (area light sources) should cast soft-edged shadows</em><ul><li>Some points see all the light - fully illuminated</li><li>Some points see none of the light source - <strong>the umbra</strong></li><li>Some points see part of the light source - <strong>the penumbra</strong></li></ul></li><li>Point light source generates only the umbra shadow</li><li>To trace area light sources, cast multiple shadow rays <ul><li>Each one to a different point on the light source</li><li>Weigh illumination by the number that get through</li></ul></li></ul></li></ul></li><li><strong>Ray Casting / Scan-Conversion Similarities</strong><ul><li>Ray-Casting (E,P):<ul><li>For each ray(E,P) in all pixel P do<ul><li><em>For each triangle T</em> <em>projecting over P</em> <em>do</em><ul><li>Decide if the triangle is visible(is the closest object)) </li><li>Decide if the triangle faces to a light(shadow?) </li><li>Compute reflected color and store in the pixel</li></ul></li></ul></li></ul></li><li>Scan-conversion:<ul><li><em>For each pixel P</em> <em>covered by the projection of T</em> <em>do</em> <ul><li><em>Decide if the triangle is visible</em></li><li><em>Compute reflected color and store in the pixel</em></li></ul></li></ul></li></ul></li></ul><h3 id="3-Ray-Tracing"><a href="#3-Ray-Tracing" class="headerlink" title="3. Ray Tracing"></a>3. Ray Tracing</h3><ul><li>Whitted’s Ray Tracing Algorithm<ul><li>3 parts<ul><li>Local illumination or shadow at S</li><li>Reflected illumination $I_s$ in the direction $R$</li><li>Refractive illumination $I_t$ in the direction $T$ if $S$ is transparent</li></ul></li><li>$I=(L_0+\sum_{lights}L_A)<em>C_A+\sum_{lights}L_D*C_D</em>(L\cdot N)+\sum_{lights}L_S*C_S(E\cdot(L-2(N(N\cdot L))))^K+C_SI_S+C_tI_t$</li></ul></li><li>Ray Tree<ul><li>左边反射，右边折射</li></ul></li><li>Stopping Criteria of Algorithm<ul><li>Recursion depth<ul><li>Stop after a number of bounces</li></ul></li><li>Ray Contribution<ul><li>Stop if transparency/transmitted attenuation becomes too small</li></ul></li><li>Usually ao both</li></ul></li></ul><h3 id="4-Advance-in-Ray-Tracing"><a href="#4-Advance-in-Ray-Tracing" class="headerlink" title="4. Advance in Ray Tracing"></a>4. Advance in Ray Tracing</h3><ul><li>Speeding up Ray Tracing<ul><li>Hierarchy of scene and Bounding boxes</li><li>Spatial Partitioning</li></ul></li><li>Advantage:<ul><li>More Realistic by tracing the rays from light sources and opaque</li><li>More Realistic: shadow and refraction</li></ul></li><li>Disadvantage:<ul><li>Complex on intersection computing</li><li>Super-realistic on reflection of specular transmitted by bright surfaces</li><li>Not trace the diffuse rays in the scene</li></ul></li></ul><p><img src="./09-03.png" alt="09-03 Exercise"></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（八）Modeling and Hierarchy</title>
      <link href="/computer-graphics-08/"/>
      <url>/computer-graphics-08/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（八）Modeling-and-Hierarchy"><a href="#计算机图形学（八）Modeling-and-Hierarchy" class="headerlink" title="计算机图形学（八）Modeling and Hierarchy"></a>计算机图形学（八）Modeling and Hierarchy</h1><h2 id="1-Example-I-Car-Model"><a href="#1-Example-I-Car-Model" class="headerlink" title="1. Example I: Car Model"></a>1. Example I: Car Model</h2><ul><li>DAG Model<ul><li>Directed acyclic graph 有向无环图</li></ul></li><li>Modeling with Tree<ul><li>Nodes: what to draw, pointers to children</li><li>Edges: may have information on incremental changes to transformation matrices (can also store in nodes)</li></ul></li><li>层级（hierarchical）</li></ul><h2 id="2-Example-II-Robot-Arm"><a href="#2-Example-II-Robot-Arm" class="headerlink" title="2. Example II: Robot Arm"></a>2. Example II: Robot Arm</h2><ul><li><p>Articulated Model 铰链模型</p></li><li><p>Possible Node Structure</p><p><img src="./08-01.png" alt="08-01 Possible Node Structure"></p></li><li><p>OpenGL code for robot</p><pre class=" language-c++"><code class="language-c++">mat4 ctm;robot_arm(){ctm = RotateY(theta);base();ctm *= Translate(0.0, h1, 0.0) * RotateZ(phi);  lower_arm();ctm *= Translate(0.0, h2, 0.0) * RotateZ(psi);  upper_arm();}</code></pre></li></ul><h2 id="3-Example-III-Humanoid-Figure"><a href="#3-Example-III-Humanoid-Figure" class="headerlink" title="3. Example III: Humanoid Figure"></a>3. Example III: Humanoid Figure</h2><ul><li><p>Tree with Matrices</p><p><img src="./08-02.png" alt="08-02 Tree with Matrices"></p></li><li><p>Display and Traversal</p><ul><li>Stack-based Traversal code</li></ul><pre class=" language-c++"><code class="language-c++">figure() {mvstack.push( model_view );//save present model-view matrix torso();//update model-view matrix for headmodel_view = model_view*Translate(...)*Rotate(...); head();model_view = mvstack.pop();//recover original model-view matrix mvstack.push( model_view );//save it again//update model-view matrix for left upper armmodel_view= model_view*Translate(...)*Rotate(...); left_upper_arm();model_view = mvstack.pop();//recover original model-view matrix again ......}</code></pre><ul><li><p>General Tree Data Structure</p><ul><li><p>left-child right sibling structure</p><ul><li>Used linked lists</li><li>Each node in data structure is two pointers</li><li>Left: next node</li><li>Right: linked list of children</li></ul><p><img src="./08-03.png" alt="08-03 tree structure"></p></li><li><p>Tree node structure</p><ul><li>Pointer to sibling / child</li><li>Pointer to a function that draws the object represented by the node</li><li>Homogeneous coordinate matrix to multiply on the right of the current model-view matrix</li></ul></li></ul></li></ul></li></ul><h2 id="4-OpenGL-and-Objects"><a href="#4-OpenGL-and-Objects" class="headerlink" title="4. OpenGL and Objects"></a>4. OpenGL and Objects</h2><ul><li>OpenGL lacks an object orientation</li></ul><h2 id="5-Scene-Graph"><a href="#5-Scene-Graph" class="headerlink" title="5. Scene Graph"></a>5. Scene Graph</h2><ul><li>Scene graph</li></ul><p><img src="./08-04.png" alt="08-04 scene graph"></p><p><img src="./08-05.png" alt="08-05 Scene Graph Example"></p><ul><li>Group Nodes<ul><li>Necessary to isolate state chages<ul><li>Equivalent to Push/Pop</li></ul></li><li>Note that as with the figure model<ul><li>We can write a universal traversal algorithm</li><li>The order of traversal can matter</li></ul></li></ul></li><li>Events and the Scene Graph<ul><li>It is not difficult to let any part of the scene graph vary</li><li>Events could be used to identify the part of the scene graph and how it is to change<ul><li>Change geometry </li><li>Change transformations </li><li>Change appearance</li></ul></li></ul></li></ul><h2 id="6-Events-in-OpenGL"><a href="#6-Events-in-OpenGL" class="headerlink" title="6. Events in OpenGL"></a>6. Events in OpenGL</h2><ul><li>Event Processing in OpenGL</li></ul><p><img src="./08-06.png" alt="08-06 Event Processing"></p><ul><li><p>code example</p><pre class=" language-c++"><code class="language-c++">int main( int argc, char **argv){    glutInit( &argc, argv);     glutInitWindowSize( 400, 400);     glutInitWindowPosition( 200, 100);    glutCreateWindow( “Sample”);    //specify callback functions    glutDisplayFunc( display);    glutIdleFunc( animation);     glutKeyboardFunc( kboard);    glutSpecialFunc(special_key);     glutMouseFunc( mousef);    glutMotionFunc( mousePos);     glutCreateMenu( menuf );     glutTimerFunc(300, timer, -1); glutReshapeFunc(reshape);    init();     glutMainLoop();    return 0;}timer() {  ... ;   glutPostRedisplay();   // call display() right now}void mousef(int button, int state, int x, int y){  if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {    drag = true;   }  if (button == GLUT_LEFT_BUTTON && state == GLUT_UP) {     xx = x/100.-2.; yy = 2.-y/100.;    drag = false;    glutPostRedisplay();  }}void mousePos( int x, int y) {   if ( drag ) {    xx = x/100.-2.; yy = 2.-y/100.;    glutPostRedisplay();   }}glutCreateMenu( menuf ); //callback menuf( int i) is called if triggeredglutAddMenuEntry("Level 1: Beginner", 1);glutAddMenuEntry("Level 2: amateur", 2);glutAddMenuEntry("Level 3: Professional", 3);glutAttachMenu(GLUT_RIGHT_BUTTON);void  menuf( int i) {   if (i == 1) {    ispeed = 0.002; rw = .125;    }    else if (i == 2) {        ...   }    else if (i == 3) {     ...    }    ...}//Create the main menuglutCreateMenu( mainf ); glutAddMenuEntry("Restart", 1);//Link the sub-menu to the main menu glutAddSubMenu("Set Level", levelMenu); glutAddMenuEntry("Quit", 3); glutAttachMenu( GLUT_RIGHT_BUTTON);//Create a sub-menuint levelMenu = glutCreateMenu( levelf); glutAddMenuEntry("Learner", 1); glutAddMenuEntry("Average", 2); glutAddMenuEntry("Racing God", 3);//define Callback function for the main menuvoid mainf( int i) {  if (i == 1) { restart(); . . . }  else if (i == 3) { . . . }  //If i == 2, levelf() will be called automatically}//define Callback for //the sub-menu void levelf( int i) {  if ( i == 1) . . .  ... }</code></pre></li><li><p><strong>MUI</strong></p><ul><li>MUI is a particular user interaction toolkit</li><li>It’s very simple, but very easy to use</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（七）Discrete Techniques</title>
      <link href="/computer-graphics-07/"/>
      <url>/computer-graphics-07/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（七）Discrete-Techniques"><a href="#计算机图形学（七）Discrete-Techniques" class="headerlink" title="计算机图形学（七）Discrete Techniques"></a>计算机图形学（七）Discrete Techniques</h1><ul><li>Uses of Texturing<ul><li>Simulating materials</li><li>Reducing Geometric Complexity</li></ul></li></ul><h2 id="1-Buffer-in-OpenGL"><a href="#1-Buffer-in-OpenGL" class="headerlink" title="1. Buffer in OpenGL"></a>1. Buffer in OpenGL</h2><ul><li><strong>Define a buffer</strong>: spatial resolution $(n\times m)$ and its depth (or precision) $k$, the number of bits/pixel</li><li>OpenGL Frame Bufferes: Back buffer, Front buffer</li><li>OpenGL Buffers<ul><li>Color buffers: Front, Back, Auxiliary 辅助, Stereo 立体</li><li>Depth</li><li>Stencil: Holds masks</li><li>Most RGBA buffers 8 bits per component</li><li>Latest are floating point (IEEE)</li></ul></li></ul><h2 id="2-Writing-in-Buffers"><a href="#2-Writing-in-Buffers" class="headerlink" title="2. Writing in Buffers"></a>2. Writing in Buffers</h2><ul><li><p>The frame buffer is part of this memory</p></li><li><p>Writing Model</p><ul><li>read desrination pixel before writing source</li></ul><p><img src="./07-01.png" alt="07-01 Writing Model"></p><ul><li><p>Bit Writing Modes</p><ul><li>Source and destination bits are combined bitwise</li><li>$s$, $d$, 从小到大, 16 possible function(<code>glLoicOp(mode); --default:mode=GL_COPY</code>)</li></ul><p><img src="./07-02.png" alt="07-02 Bit Writing Modes"></p></li><li><p>XOR Mode</p><ul><li>XOR is especially useful for swapping blocks of memory such as menus that are stored off screen</li><li>$S$ represents screen and $M$ represents a menu the sequence<ul><li>$S\leftarrow S\oplus M$; $M\leftarrow S\oplus M$; $S\leftarrow M\oplus M$</li><li>Swaps the $S$ and $M$</li></ul></li></ul></li></ul></li><li><p><strong>The Pixel Pipeline</strong></p><ul><li>OpenGL has a separate pipeline for pixels</li></ul><p><img src="./07-03.png" alt="07-03 Pixel Pipeline"></p></li><li><p><strong>Buffer Selection</strong></p><ul><li>OpenGL can read from any of the buffers (front, back, depth)</li><li>Default to the back buffer, change with <code>glReadBuffer</code></li><li>format of the pixels in the frame buffer is different from that of processor memory and these two types of memory reside in different places<ul><li>Need packing and unpacking</li><li>Reading can be slow</li></ul></li><li>Drawing through texture function</li></ul></li><li><p><strong>OpenGL Pixel Functions</strong></p><ul><li><code>glReadPixels(x,t,width,height,format,type, myimage)</code></li><li>eg. <code>glReadPixells(0,0,512,512,GL_RGB,GL_UNSIGNED_BYTE,myimage)</code></li></ul></li><li><p>Deprecated Functionality</p><ul><li>Replace by use of texture functionality, glBltFrameBuffer, frame buffer objects</li><li>GPUs now include a large amount of texture memory that we can write into</li><li>Advantage: fast (not under control of window system)</li></ul></li></ul><h2 id="3-Mapping-Methods"><a href="#3-Mapping-Methods" class="headerlink" title="3. Mapping Methods"></a>3. Mapping Methods</h2><ul><li>3 Types<ul><li><strong>Texture Mapping</strong><ul><li>Uses images to fill inside of polygons</li></ul></li><li><strong>Environment (reflection mapping)</strong><ul><li>Uses a picture of the environment for texture maps</li><li>Allows simulation of highly specular surfaces</li></ul></li><li><strong>Bump mapping</strong><ul><li>Emulates altering normal vectors during the rendering process</li><li>to process each fragment independently with a fragment shader</li></ul></li></ul></li><li><strong>Where does mapping take place</strong><ul><li>Mapping techniques are implemented at the end of the rendering pipeline</li><li>Very efficient because few polygons make it past the clipper</li></ul></li><li><strong>Coordinate Systems</strong><ul><li>Parametric coordinates<ul><li>May be used to model curves and surfaces</li></ul></li><li>Texture coordinates<ul><li>Used to identify points in the image to be mapped</li></ul></li><li>Object or World Coordinates<ul><li>Conceptually, where the mapping takes place</li></ul></li><li>Window Corrdinates<ul><li>Where the final image is really produces</li></ul></li></ul></li><li><strong>Mapping</strong><ul><li>Backward Mapping<ul><li>$s=s(x,y,z)$; $t=t(x,y,z)$</li></ul></li><li>Two-part Mapping<ul><li>first map the texture to a simple intermediate surface</li><li>Cylindrical Mapping</li><li>Sherical Map </li><li>Box Map</li></ul></li></ul></li></ul><h2 id="4-Texture-Mapping-in-OpenGL"><a href="#4-Texture-Mapping-in-OpenGL" class="headerlink" title="4. Texture Mapping in OpenGL"></a>4. Texture Mapping in OpenGL</h2><ul><li>3 steps to applying a texture<ul><li>specify the texture</li><li>Assign texture coordinates to vertices</li><li>specify texture parameters</li></ul></li><li>Specify the Texture<ul><li><code>Glubyte my_texels[512][512]</code></li><li><code>glEnable(GL_TEXTURE_2D)</code></li><li>Define Image as a Texture <ul><li><code>glTexImage2D(target,level,components,w,h,border,format,type,texels)</code><ul><li>format: 是否使用平滑</li></ul></li><li>eg. <code>glTexImage2D(GL_TEXTURE_2D,0,3,512,512,0,GL_RGB,GL_UNSIGNED_BYTE,my_texels)</code></li></ul></li></ul></li><li>Maping a Texture<ul><li><code>glTexCoord*()</code> specified at each vertex</li></ul></li><li>Parameter of Texture Mapping<ul><li>Interpolation:<ul><li><code>glHint(GL_PERSPECTIVE_CORRECTION_HIT,hint)</code></li><li><code>GL_DONT_CARE</code>(default), <code>GL_NICEST</code>, <code>GL_FASTNEST</code>(don’t perform the perspective correction to maximize speed)</li></ul></li><li>OpenGL has a variety of parameters that determine how texture is applied<ul><li><strong>Wrapping Mode:</strong> determine what happpens if $s$ and $t$ are outside the $(0,1)$ range <ul><li><code>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE)</code></li><li><code>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP_REPEAT)</code></li></ul></li><li><strong>Filter Mode:</strong> allow us to use area averageing instead of point samples<ul><li>More than one texel can cover a pixel (<strong>minification</strong>) or more than one pixel can cover a texel (<strong>magnification</strong>)</li><li><code>glTexParameteri(GL_TEXTURE,GL_TEXTURE_MAG_FILTER,GL_NEAREST)</code></li><li><code>glTexParameteri(GL_TEXTURE,GL_TEXTURE_MIN_FILTER,GL_LINEAR)</code></li></ul></li><li><strong>Mipmapping:</strong> allow us to use textures at multiple resolutions，处理纹理缩小的问题<ul><li><em>Mipmapping</em> allows for prefiltered texture maps of decreasing resolutions</li><li>Lessens interpolation errors for smaller textured objects</li><li><code>glGenerateMipMap(GL_TEXTURE_2D)</code></li><li><code>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST_MIPMAP_NEAREST)</code></li><li>point sampling, linear filtering, mipmapped point sampling, mipped linear filtering</li></ul></li><li><strong>Environment parameters:</strong> determine how texture mapping interacts with shading</li></ul></li></ul></li></ul><h2 id="5-Texture-Objects-in-OpenGL"><a href="#5-Texture-Objects-in-OpenGL" class="headerlink" title="5. Texture Objects in OpenGL"></a>5. Texture Objects in OpenGL</h2><ul><li><p>Texture Object</p><pre class=" language-c++"><code class="language-c++">GLuint textures[1];glEnable(GL_TEXTURE_2D); //open texture computingglGenTextures(1, texName); // generates a texture nameglBindTexture(GL_TEXTURE_2D,texName[0]); // Create texture objects with texture data and stateglTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT); //texture parametersglTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);//Define a texture image from an array of texels in CPU memoryglTexImage2D(GL_TEXTURE_2D,0,GL_RGB,TEX_WIDTH,TEX_HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, texImage);glActiveTexture( GL_TEXTURE0 );</code></pre></li><li><p>Linking with Shader</p></li><li><p>Applying Textures</p><ul><li><strong>sampler</strong></li></ul><pre class=" language-c++"><code class="language-c++">in vec4 color; //color from rasterizerin vec2 texCoord; //texure coordinate from rasterizer uniform sampler2D texture; //texture object from applicationvoid main() {gl_FragColor = color * texture2D( texture, texCoord );}</code></pre></li><li><p>Mirror image</p><pre class=" language-c++"><code class="language-c++">glTexParameteri(GL_TEXTURE_ 2D,GL_TEXTURE_WRAP_S,GL_MIR RORED_REPEAT);glTexParameteri(GL_TEXTURE_ 2D,GL_TEXTURE_WRAP_S,GL_MIR RORED_REPEAT); glTexParameteri(GL_TEXTURE_ 2D,GL_TEXTURE_WRAP_T,GL_MIR RORED_REPEAT);</code></pre></li></ul><h2 id="6-The-Example-of-Texture"><a href="#6-The-Example-of-Texture" class="headerlink" title="6. The Example of Texture"></a>6. The Example of Texture</h2><ul><li>OpenGL new version can read texture depth with GL_DEPTH_STENCIL</li></ul><h2 id="7-Blend-Model-合成技术"><a href="#7-Blend-Model-合成技术" class="headerlink" title="7. Blend Model 合成技术"></a>7. Blend Model 合成技术</h2><ul><li>Use A component of RGBA color to store opacity</li></ul><p><img src="./07-04.png" alt="07-04 Blend Model"></p><ul><li><p>Draw partially transparent faces</p><pre class=" language-c++"><code class="language-c++">glEnable(GL_DEPTH_TEST)//Draw all opacityglEnable(GL_BLEND)glDepthMask(GL_FALSE) //depth only readglBlendFunc(GL_SRC_ALPHA, GL_ONE)//Draw all transparence from back to front //compare depth but not write to depth, blending with opacityglDepthMask(GL_TRUE) glDisable(GL_BLEND)</code></pre></li><li><p>Billboard</p><ul><li>A billboard is a <em>plane object</em> (usually simple, like a rectangle) on which an image is texture mapped</li><li>The image often includes <em>zero-alpha</em> areas so they can be “seen through”</li><li>The object is rotated to <em>face the viewer</em> so that the viewer sees the image in 3D space, simulating a full 3D object</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（六）From Vertices to Fragments</title>
      <link href="/computer-graphics-06/"/>
      <url>/computer-graphics-06/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（六）From-Vertices-to-Fragments"><a href="#计算机图形学（六）From-Vertices-to-Fragments" class="headerlink" title="计算机图形学（六）From Vertices to Fragments"></a>计算机图形学（六）From Vertices to Fragments</h1><h2 id="0-引入"><a href="#0-引入" class="headerlink" title="0. 引入"></a>0. 引入</h2><ul><li><p><strong>Moeling Pipeline</strong></p><p><img src="./06-01.png" alt="06-01 Modeling Pipeline"></p></li><li><p><strong>Rendering Pipeline</strong></p><p><img src="./06-02.png" alt="06-02 Rendering Pipeline"></p></li><li><p>OpengGL</p><ul><li>OpenGL 4.5<ul><li>Direct State Access, DSA<ul><li>object accessors enable state to be queried and modified without binding objects to contexts, for increased application and middleware efficiency and flexibility;</li></ul></li><li>Flush Control<ul><li>applications can control flushing of pending commands before context switching – enabling high-performance multithreaded applications;</li></ul></li><li>Robustness</li><li>OpenGL ES 3.1 API and shader compatibility</li><li>DX11 emulation feature</li></ul></li><li>OpenGL 4.6 Core Profile</li></ul><p><img src="./06-03.png" alt="06-03 OpenGL 4.6 Core Profile"></p><ul><li>OpenGL Fundamentals</li><li>OpenGL Objects Model</li></ul></li></ul><h2 id="1-Clipping-line-polygon"><a href="#1-Clipping-line-polygon" class="headerlink" title="1. Clipping: line, polygon"></a>1. Clipping: line, polygon</h2><ul><li><p><strong>Cohen-Sutherland线段剪裁算法</strong></p><ul><li><p>Two steps:</p><ul><li>判断线段是否需要裁剪</li><li>裁剪线段</li></ul></li><li><p>Cases:</p><ul><li>Case1: both endpoints of line segment inside all four lines<ul><li>Draw</li></ul></li><li>Case 2: both endpoiints outside all lines and on same side of a line <ul><li>Discard</li></ul></li><li>Case 3: one endpoint inside, one outside<ul><li>Must do at least one intersection</li></ul></li><li>Case4: both outside<ul><li>May have part inside</li><li>must do at least one intersection</li></ul></li></ul></li><li><p>Outcodes</p><ul><li><p>Outcodes:</p><ul><li><p>XXXX – TBRL</p><table><thead><tr><th>1001</th><th>1000</th><th>1010</th></tr></thead><tbody><tr><td>0001</td><td>0000</td><td>0010</td></tr><tr><td>0101</td><td>0100</td><td>0110</td></tr></tbody></table></li></ul></li><li><p>例子：</p><ul><li>l1: code1=0000; code2=0000</li><li>l2: code1=0100; code2=0110</li></ul></li></ul></li><li><p>算法：</p><blockquote><ol><li><p>线段完全保留：</p><p>if (code1==0&amp;&amp;code2==0) or (code1|code2)==0</p></li><li><p>线段完全放弃：</p><p>if ((code1&amp;code2)&lt;&gt;0)</p></li><li><p>剪裁线段：</p><p>else computing intersection</p><p>Reexecute algorithm</p></li></ol></blockquote></li><li><p>Efficiency</p><ul><li>In many applications, the clipping window is small relative to the size of the entire data base</li><li>Inefficiency when code has to be reexecuted for line segments that must be shortened in more than one step</li></ul></li><li><p>Cohen Sutherland in 3D</p><ul><li>6-bit outcode 前后上下右左</li></ul></li></ul></li><li><p><strong>梁友栋-Barsky线段剪裁算法</strong></p><ul><li><p>算法描述：</p><ul><li><p>线段$(s_1,s_2)$的参数方程：<br>$$<br>\begin{equation}<br>\left{<br>\begin{aligned}<br>x=x_1+t<em>(x_2-x_1)\<br>y=y_1+t</em>(y_2-y_1)<br>\end{aligned}<br>\right.<br>\end{equation}<br>\ \ \ \ \ 0\le t\le1<br>$$</p></li><li><p>始边和终边：</p><ul><li>始边：靠近$s_1$的窗边界线，如$xL$, $yB$</li><li>终边：靠近$s_2$的窗边界线，如$xR$, $yT$</li></ul></li><li><p>$t_1$, $t_2$</p><ul><li><p>$t_1=\max{t_1’,t_1’’,0}$，$t_1’$,$t_1’’$为$s_1$,$s_2$与两个始边的焦点参数</p></li><li><p>$t_2=\min{t_2’,t_2’’,1}$，$t_2’$,$t_2’’$为$s_1$,$s_2$与两个终边的焦点参数</p></li><li><p>当$t_1&lt;t_2$时，为可见直线段：<br>$$<br>\begin{equation}<br>\left{<br>\begin{aligned}<br>x=(x_2-x_1)<em>t+x_1\<br>y=(y_2-y_1)</em>t+y_1<br>\end{aligned}<br>\right.<br>\end{equation}<br>\ \ \ \ t_1&lt;t&lt;t_2<br>$$</p></li><li><p>当$t_1&gt;t_2$时，直线不可见</p></li></ul></li><li><p>求解$t_1’$, $t_1’’ $, $t_2’$, $t_2’’$ ：<br>$$<br>xL\le(x_2-x_1)<em>t+x_1\le xR\<br>yB\le(y_2-y_1)</em>t+y_1\le yT<br>$$</p><ul><li>简化求解为：$t*p_k\le q_k$, $k=1,2,3,4$<ul><li>$p_1=-(x_2-x_1)$, $q_1=x_1-xL$</li><li>$p_2=(x_2-x_1)$, $q_2=xR-x_1$</li><li>$p_3=-(y_2-y_1)$, $q_3=y1-yB$</li><li>$p_4=(y_2-y_1)$, $q_4=yT-y1$</li></ul></li></ul></li><li><p>可知：</p><ul><li>若$p_k&lt;0$，则$t_k$为始边之交点参数</li><li>若$p_k&gt;0$，则$t_k$为终边之交点参数</li><li>若$p_k=0$，当$q_k&lt;0$，则线段完全不可见</li></ul></li></ul></li><li><p>优点</p><ul><li>Can accept/reject as easily as with Cohen- Sutherland</li><li>Using values of <em>t</em>, we do not have to use algorithm recursively as with C-S. 不用对线段进行多次剪裁处理，从而避免了剪裁算法的多次重复执行。</li><li>Extends to 3D</li></ul></li></ul></li><li><p><strong>Polygon Fill-Area Clipping</strong></p><ul><li><p>Sutherland-Hodgman Polygon Clipping:</p><ul><li><p>思想：用四个窗边界线依次剪裁多边形的所有边</p></li><li><p>算法：</p><blockquote><p>for (窗边界线: 1 to 4){</p><p>​    for (多边形的边界线: 1 to n)</p><p>​        求输出顶点;</p><p>​    得到一个剪裁后的顶点序列</p><p>}</p><p>得到最终剪裁后的顶点序列</p></blockquote></li></ul></li></ul></li><li><p>Clipping and Normalization</p><ul><li>General clipping in 3D requires intersection of line segments against arbitrary plane</li><li>Example: oblique view</li></ul></li></ul><h2 id="2-Rasterization-Scan-Conversion"><a href="#2-Rasterization-Scan-Conversion" class="headerlink" title="2. Rasterization: Scan Conversion"></a>2. Rasterization: Scan Conversion</h2><ul><li><p>Rasterization 光栅化</p><ul><li>Process:<ul><li>Modeling, Geometric processing, Rasterization, Fragment Processing, Frame Buffer</li></ul></li><li>Rasterization (scan conversion)<ul><li>Determine which pixels that are inside primitive - specified by a set of vertices</li><li>Produces a set of fragments</li><li>Fragments have a location (pixel location) and other attributes such color and texture coordinates that are determined by interpolating values at vertices</li></ul></li><li>Pixels colors determined later using color, texture, normal and other vertex properties</li><li>Drawing edges</li></ul></li><li><p>Scan Conversion for Line – DDA Algorithm</p><ul><li><strong>DDA Algorithm</strong>, Digital Differential Analyzer</li><li>Line equation: $y=m*x+b$<ul><li>While, $|m|\le1$<ul><li>If $x_1&lt;x_2$, then $x_{i+1}=x_i+1$, $y_{i+1}=y_i+m$</li><li>If $x_1&gt;x_2$, then $x_{i+1}=x_i-1$, $y_{i+1}=y_i-m$</li></ul></li><li>While, $|m|&gt;1$<ul><li>If $y_1&lt;y_2$, then $y_{i+1}=y_i+1$, $x_{i+1}=x_i+1/m$</li><li>If $y_1&gt;y_2$, then $y_{i+1}=y_i-1$, $x_{i+1}=x_i-1/m$</li></ul></li></ul></li><li><code>0.5*sign(dx)</code>和<code>0.5sign(dy)</code></li></ul></li><li><p>Scan Conversion for Line – Bresenham Algorithm</p><ul><li>算法：</li></ul><p>$$<br>\begin{equation}<br>\left{<br>\begin{aligned}<br>&amp;p_1=2<em>\Delta y-\Delta x\<br>&amp;x_{i+1}=x_i+1\<br>&amp;y_{i+1}=\left{<br>\begin{aligned}&amp;y_i+1,\ \ if\ p_i&gt;0\<br>&amp;y_i,\ \ \ \ \ \ \ \ \ if\ p_i\le0\end{aligned}<br>\right.\<br>&amp;p_{i+1}=\left{<br>\begin{aligned}<br>&amp;p_i+2</em>(\Delta y-\Delta x),\ \ if\ p_i&gt;0\<br>&amp;p_i+2*\Delta y,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ p_i\le0\end{aligned}<br>\right.<br>\end{aligned}<br>\right.<br>\end{equation}<br>$$</p></li><li><p>Scan Conversion for Polygon</p><p><img src="./06-04.png" alt="06-04 Scan Conversion for Polygon"></p><ul><li>First find out the scanlines that intercept with the polygon. Calculate the overlapping segments</li><li>For each scanline from top to bottom, set the pixels in the segment</li><li><strong>Fragment:</strong> pixels on the scene line<ul><li>两步：<ul><li>求交：计算扫描线与多边形三个边的交点</li><li>排序：把所有的交点按x坐标递增来排序</li></ul></li><li>特殊情况，扫描线与多边形顶点相交：<ul><li>顶点是极值点，算两个交点</li><li>不是极值点，算一个</li></ul></li></ul></li></ul></li></ul><h2 id="3-Hiden-Surface-Removal"><a href="#3-Hiden-Surface-Removal" class="headerlink" title="3. Hiden-Surface Removal"></a>3. Hiden-Surface Removal</h2><ul><li><strong>The z-Buffer Algorithm</strong><ul><li>Depth Buffer same as Frame Buffer</li><li>saving the distance of the closest intersection</li></ul></li><li><strong>The Painter’s Algorithm</strong><ul><li>Rendering from back to front of the polygons</li><li>depth sort for all polygons</li><li>dividing the polygon into two parts</li></ul></li></ul><h2 id="4-Antianliasing-反走样"><a href="#4-Antianliasing-反走样" class="headerlink" title="4. Antianliasing 反走样"></a>4. Antianliasing 反走样</h2><ul><li>The <strong>jaggies</strong>（锯齿） appeared in the drawings of lines is called <em>aliasing</em>（走样）. It is due to the approximation of a continuous line with discrete pixels.</li><li>Antiliasing Computing<ul><li>First computing the overlapping proportions of the lines and the nearby pixel squares. Suppose that the overlapping proportion of a certain pixel is $\alpha$, the new $pixel_color$ is then set to $\alpha\times current_color+(1-\alpha)\times existing_color$</li></ul></li><li>Line Antianliasing<ul><li><code>glEnable(GL_LINE_SMOOTH)</code> 和 <code>glDisable(GL_LINE_SMOOTH)</code></li></ul></li><li>Polygon Antianliasing<ul><li><code>glEnable(GL_POLYGON_SMOOTH)</code>和<code>glDisable(GL_POLYGON_SMOOTH)</code></li></ul></li><li>Polygon Aliasing<ul><li>problems can be serious for polygons<ul><li>Small polygons neglected</li><li>Color of pixel depends on colors of multi-polygons</li></ul></li></ul></li></ul><h2 id="5-Color-Model-–-The-Human-Visual-System"><a href="#5-Color-Model-–-The-Human-Visual-System" class="headerlink" title="5. Color Model – The Human Visual System"></a>5. Color Model – The Human Visual System</h2><ul><li><p>eyes</p><ul><li>Rods – sense luminance or brightness</li><li>Cones – sense chroma or color</li></ul></li><li><p>颜色三要素</p><ul><li>色调（hue, chroma）：颜色的类别，对应光谱分布中的主波长</li><li>饱和度（Saturation）：所呈现颜色的深浅或纯洁程度，饱和度越高，颜色越深；饱和度越小，颜色越浅。100%饱和度的色光就代表完全没有混入白光的纯色光。</li><li>明亮度（luminance）：光作用于人眼时引起的明亮程度的感觉。</li><li>人眼能分辨128种不同色调，10-30种不同饱和度，对亮度很敏感，35万种颜色</li></ul></li><li><p>颜色模型</p><ul><li>RGB – cube for screen<ul><li>CMY: Cyan(0,1,1); Magenta(1,0,1); Yellow(1,1,0)</li><li>$Luminance = 0.30<em>red+0.59</em>green+0.11*blue$</li><li>The grayscale conversion is computer-based, not visually-based; is it right? (Not right)</li></ul></li><li>CMYK – cube for printer</li><li>HSV – cone for artist<ul><li>Hue(angle) - Saturation(radius) - Value(height)</li></ul></li><li>HLS – double cone for artist on painting<ul><li>Hue(angle) - Lightness(height) - Saturation(radius)</li></ul></li></ul></li><li><p><strong>Emissive</strong> vs <strong>Transmissive</strong> Colors</p><ul><li><p>emissive colors are from screen</p></li><li><p>transmissive colors are from inks</p></li><li><p>RGB emissive model - additive colors</p></li><li><p>CMYK transmissive model -subtractive colors</p></li><li><p>$$<br>\begin{pmatrix}C\M\Y\end{pmatrix} =<br>\begin{pmatrix}1\1\1\end{pmatrix} -<br>\begin{pmatrix}R\G\B\end{pmatrix}<br>$$</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（五）Lighting and Shading</title>
      <link href="/computer-graphics-05/"/>
      <url>/computer-graphics-05/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（五）Lighting-and-Shading"><a href="#计算机图形学（五）Lighting-and-Shading" class="headerlink" title="计算机图形学（五）Lighting and Shading"></a>计算机图形学（五）Lighting and Shading</h1><h2 id="1-Lighting-Conception"><a href="#1-Lighting-Conception" class="headerlink" title="1. Lighting Conception"></a>1. Lighting Conception</h2><ul><li><strong>Need to consider:</strong> <ul><li>Surface orientation – normal</li><li>Material properties</li><li>Light sources</li><li>Location of viewer</li></ul></li><li>Light which shines from light source to the objects transmits the <strong>reflective</strong> light, <strong>transparent</strong> light and <strong>abosrptive</strong> light (not be seen)</li><li>Reflective light includes <em>diffuse</em> and <em>specular</em> which more depends on the material of the object.</li></ul><h2 id="2-Lighting-Model"><a href="#2-Lighting-Model" class="headerlink" title="2. Lighting Model"></a>2. Lighting Model</h2><ul><li><p><strong>Local Lighting Model:</strong> all light comes from lights defined within the scene.</p></li><li><p>three components:</p><ul><li><strong>Ambient light</strong> 环境光</li><li><strong>Diffuse light</strong> 漫反射光</li><li><strong>Specular light</strong> 镜面反射光</li></ul></li><li><p><strong>Ambient Light</strong> 环境光</p><ul><li>虚拟的光，使空间获得均匀的照明，不考虑光源位置、观察者位置和表面法向量</li><li>$A=L_0+\sum_{lights}(L_A*C_A)$<ul><li>ambient light $L_A$, material ambient value $C_A$</li></ul></li></ul></li><li><p><strong>Diffuse Light</strong> 漫反射光</p><ul><li>$D=\sum_{lights}L_D*C_D(L\cdot N)$<ul><li>diffuse value $L_D$; material ambient value $C_D$;</li><li>light vector $L$; normal vector $N$</li></ul></li></ul></li><li><p><strong>Specular Light</strong> 镜面反射</p><ul><li>$S=\sum_{lights}L_S*C_S(V\cdot R)^K$<ul><li>specular value $L_S$; material value $C_S$; material shininess $K$ （聚集度 0～127）</li><li>eye vector $V$; the reflection of a light vector $R$</li></ul></li><li>$R=L-2(N(N\cdot L))$</li></ul></li><li><p><strong>Local Illumination Model</strong></p><ul><li>$I=L_0+\sum_{light}(LA<em>C_A)+\sum_{lights}L_D*C_D</em>(L\cdot N)+\sum_{lights}L_SD_S(V\cdot(L-2(N(N\cdot L))))^K$</li><li><strong>four vectors:</strong><ul><li>To Source $l$</li><li>To viewer $v$</li><li>Normal $n$</li><li>Perfect reflector $r$</li></ul></li></ul></li><li><p><strong>Blinn-Phong Lighting Model</strong></p><ul><li>the modified Blinn-Phong lighting model<ul><li>半角向量 $h=\frac{l+v}{|l+v|}$，将$(r\cdot v)^e$替换成$(n\cdot h)^{e’}$</li><li>$S=\sum_{lights}L_S<em>C_S</em>(n\cdot h)^{K_1}$</li></ul></li></ul></li></ul><h2 id="3-Surface-orientation-and-Material"><a href="#3-Surface-orientation-and-Material" class="headerlink" title="3. Surface orientation and Material"></a>3. Surface orientation and Material</h2><ul><li><strong>two need things:</strong> normals &amp; material</li></ul><h2 id="4-Light-Properties"><a href="#4-Light-Properties" class="headerlink" title="4. Light Properties"></a>4. Light Properties</h2><ul><li><p><strong>Types of Light Sources</strong></p><ul><li>Point lights: $(x,y,z,1)^T$</li><li>Directional/parallel lights: $(x,y,z,0)^T$</li><li>Spotlights: position, direction, angle(cutoff)</li><li>Ambient Lights</li></ul></li><li><p><strong>Light Position</strong></p><ul><li>$n$: the normal of the surface</li><li>$(x,y,z)$: the coordinates of a point on the surface</li><li>$s$: the direction of the light source at $(x,y,z)$</li></ul></li><li><p><strong>Directional Sources</strong></p><ul><li>$s$ remains unchangeed across a surface</li></ul></li><li><p><strong>The spot of the Light Source</strong></p><ul><li>Define: <ul><li>the position $P$</li><li>direction $D$</li><li>cutoff $\theta $</li><li>dropoff $d$</li></ul></li><li>Q is in cutoff $\theta$: $l_Q=\cos^d(\phi)=((Q-P)\cdot D)^d$, if $\phi&lt;\theta$</li><li>Q is out of range cutoff $\theta$: $I_Q=0$, if$\phi&gt;\theta$</li></ul></li><li><p><strong>Light Attenuation</strong> </p><ul><li>For a point light source, the attenuation factor is <ul><li>$A_f=\frac{1}{d^2}$  (in theory)</li><li>$A_f=\frac{1}{a+bd+cd^2}$  (in practice)</li></ul></li><li>For a directional light source, $A_f=1$<ul><li>$I=L+\sum_{lights}A_f\times L_A\times C_A+\sum_{lights}A_f\times L_D\times C_D\times(L\cdot N)+\sum_{lights}A_f\times L_S\times C_S(N\cdot H)^K$</li></ul></li></ul></li><li><p><strong>Color for a Light Source</strong> – RGB values</p><pre class=" language-c++"><code class="language-c++">vec4 diffuse0 =vec4(1.0, 1.0, 1.0, 1.0); //white color vec4 ambient0 = vec4(1.0, 1.0, 1.0, 1.0); //white color vec4 specular0 = vec4(1.0, 1.0, 1.0, 1.0); //white color // specify the position of a point light sourcevec4 light0_pos =vec4(1.0, 2.0, 3,0, 1.0); //specify the direction of a directional light sourcevec4 light1_pos =vec4(1.0, 1.0, 1,0, 0.0);</code></pre></li></ul><h2 id="5-Moving-Light-Sources"><a href="#5-Moving-Light-Sources" class="headerlink" title="5. Moving Light Sources"></a>5. Moving Light Sources</h2><ul><li>移动物体或光源，受视图-模型矩阵影响</li></ul><h2 id="6-Shading-着色、明暗绘制"><a href="#6-Shading-着色、明暗绘制" class="headerlink" title="6. Shading 着色、明暗绘制"></a>6. Shading 着色、明暗绘制</h2><ul><li><strong>Shading</strong><ul><li>计算每个图形对象的颜色</li><li>使用每个顶点的属性计算对象上每个像素的颜色</li><li>意味着颜色可以通过光照模型来设置和计算</li><li>OpenGL可以使用均匀着色（flat shading）和平滑着色（smooth shading, Gouraud）两种着色</li></ul></li><li><strong>Constant (Flat) Shading</strong> <ul><li>多边形上每个点的颜色值都相同，对每个多边形只需要进行一次明暗计算</li><li>效果不好，因为人视觉系统有侧抑制（laeral inhibition）的性质，Mach带效应（March band）。</li></ul></li><li><strong>Gouraud (Smooth) Shading</strong><ul><li>每个顶点都分配一个法向量（可能是多边形的法向量，也可能是相邻面的法向量的平均值）</li><li>插值计算<ul><li>$n_c(\alpha)=(1-\alpha)n_A+\alpha n_B$，$\alpha=\frac{distance\ of\ AC}{distance\ of\ AB}$</li><li>$n(\alpha,\beta)=(1-\beta)n_C+\beta n_D$</li><li>基于片元的着色（per-fragment shading）</li></ul></li><li>$I_{P2}=I_{P1}+\Delta I_{RQ}\times\Delta t$</li></ul></li><li><strong>Other Shading Models</strong><ul><li><strong>Phong Shading</strong><ul><li>interpolate the normals across a polygon，对多边形上的法向量进行插值</li><li>计算每个像素颜色使用独立的局部光照模型</li><li>$n_{P2}=n_{P1}+\Delta n_{RQ}\times\Delta t$</li></ul></li></ul></li></ul><h2 id="7-Computing-Light-in-OpenGL"><a href="#7-Computing-Light-in-OpenGL" class="headerlink" title="7. Computing Light in OpenGL"></a>7. Computing Light in OpenGL</h2><ul><li>Light: $(LR,LG,LB)$，material: $(MR,MG,MB)$</li><li>The color of a material mainly depends on the <strong>diffuse reflectance</strong>.</li><li>The diffuse reflection alone provides most information about the <strong>curvature</strong> and the <strong>depth</strong> of an object</li><li>The ambient reflectance of a material is often the same as the diffuse reflectance.</li><li>The <strong>highlights produced in specular reflections</strong> are the blurred images of the light sources.</li></ul><h2 id="8-Front-and-Back-Faces"><a href="#8-Front-and-Back-Faces" class="headerlink" title="8. Front and Back Faces"></a>8. Front and Back Faces</h2><ul><li><strong>Emissive Term</strong><ul><li>If we want to simulate a lamp, light source in OpenGL is defined as an emissive component</li></ul></li><li><strong>Transparency</strong><ul><li>RGBA</li></ul></li></ul><h2 id="9-Implementing-Light-Model"><a href="#9-Implementing-Light-Model" class="headerlink" title="9. Implementing Light Model"></a>9. Implementing Light Model</h2><ul><li><p>State-based shading functions have been deprecated ($glNormal$, $glMaterial$, $glLight$)</p></li><li><p>Method I </p><ul><li>Vertex Shader</li></ul><pre class=" language-c++"><code class="language-c++">void main() {// Transform vertex position into eye coordinates   vec3 pos = (ModelView * vPosition).xyz;    vec3 L = normalize( LightPosition.xyz - pos );   vec3 E = normalize( -pos );    vec3 H = normalize( L + E );// Transform vertex normal into eye coordinates    vec3 N = normalize( ModelView*vec4(vNormal, 0.0) ).xyz;// Compute terms in the illumination equation   vec4 ambient = AmbientProduct;    float Kd = max( dot(L, N), 0.0 );    vec4 diffuse = Kd*DiffuseProduct;    float Ks = pow( max(dot(N, H), 0.0), Shininess );    vec4 specular = Ks * SpecularProduct;    if( dot(L, N) < 0.0 ) specular = vec4(0.0, 0.0, 0.0, 1.0);   gl_Position =     Projection * ModelView * vPosition;    color = ambient + diffuse + specular;    color.a = 1.0; }</code></pre><ul><li>Fragment Shader</li></ul><pre class=" language-c++"><code class="language-c++">// fragment shaderin vec4 color;void main() {    gl_FragColor = color; }</code></pre></li><li><p>Method II</p><ul><li>Vertex Shader</li></ul><pre class=" language-c++"><code class="language-c++">// vertex shaderin vec4 vPosition; in vec3 vNormal;// output values that will be interpolatated per-fragment out vec3 fN;out vec3 fE;out vec3 fL;uniform mat4 ModelView; uniform mat4 Projection; uniform vec4 LightPosition;void main() {    fN = vNormal;    fE = vPosition.xyz;    fL = LightPosition.xyz;    if( LightPosition.w != 0.0 ) {        fL = LightPosition.xyz - vPosition.xyz;    }    gl_Position = Projection*ModelView*vPosition; }</code></pre><ul><li>Fragment Shader</li></ul><pre class=" language-c++"><code class="language-c++">// fragment shader// per-fragment interpolated values from the vertex shader in vec3 fN;in vec3 fL;in vec3 fE;uniform vec4 AmbientProduct, DiffuseProduct, SpecularProduct; uniform float Shininess;void main() {// Normalize the input lighting vectors vec3 N = normalize(fN);    vec3 E = normalize(fE);    vec3 L = normalize(fL);    vec3 H = normalize( L + E );   vec4 ambient = AmbientProduct;  float Kd = max(dot(L, N), 0.0);   vec4 diffuse = Kd*DiffuseProduct;    float Ks = pow(max(dot(N, H), 0.0), Shininess);   vec4 specular = Ks*SpecularProduct;// discard the specular highlight if the light's behind the vertex   if( dot(L, N) < 0.0 )        specular = vec4(0.0, 0.0, 0.0, 1.0);  gl_FragColor = ambient + diffuse + specular;    gl_FragColor.a = 1.0; }</code></pre></li></ul><h2 id="10-Other-Techniques"><a href="#10-Other-Techniques" class="headerlink" title="10. Other Techniques"></a>10. Other Techniques</h2><ul><li>Anisotropic Shading 各向异性的光照<ul><li>CD、光盘的照亮</li></ul></li><li>Bump Mapping</li><li>Global Illumination<ul><li>Ray Tracing: great specular, approx diffuse</li><li>Radiosity: great diffuse, ignore specular</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（四）Viewing 视见变换</title>
      <link href="/computer-graphics-04/"/>
      <url>/computer-graphics-04/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（四）Viewing-视见变换"><a href="#计算机图形学（四）Viewing-视见变换" class="headerlink" title="计算机图形学（四）Viewing 视见变换"></a>计算机图形学（四）Viewing 视见变换</h1><h2 id="1-Projection-Transformation"><a href="#1-Projection-Transformation" class="headerlink" title="1. Projection Transformation"></a>1. Projection Transformation</h2><ul><li><p><strong>Perspective</strong> 透视投影</p><ul><li><p>视见体 view volume：四棱台</p></li><li><p><strong>General Perspective Matrix</strong></p><ul><li><p>$h=z_{prp}-z$</p></li><li><p>$p_h=M_{pers}\cdot p$</p></li><li><p>$$<br>\begin{pmatrix}<br>x_h\y_h\z_h\h<br>\end{pmatrix}<br>=<br>\begin{bmatrix}<br>z_{prp}-z_{vp}&amp;0&amp;-x_{prp}&amp;x_{prp}z_{vp}\<br>0&amp;z_{prp}-z_{vp}&amp;-y_{prp}&amp;y_{prp}z_{vp}\<br>0&amp;0&amp;s_z&amp;t_z\<br>0&amp;0&amp;-1&amp;z_{prp}<br>\end{bmatrix}<br>\cdot<br>\begin{pmatrix}<br>x\y\z\1<br>\end{pmatrix}<br>$$</p><ul><li>$s_z=-\frac{near+far}{near-far}$</li><li>$t_z=\frac{2<em>near</em>far}{near-far}$</li></ul></li><li><p>$$<br>\begin{pmatrix}<br>x_p\y_p\z_{vp}\1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>x_p\y_p\d\1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>x_h/h\y_h/h\d\1<br>\end{pmatrix}<br>$$</p></li></ul></li><li><p><strong>Perspective in View Volume</strong></p><ul><li><em>perspective(fovy, aspect, near, far)</em></li><li>$aspect=w/h$;  </li><li>$top=h/2=near*\tan(fovy/2)$;</li><li>$right=w=aspect*h$</li><li>Six planes of view volume<ul><li>$x=\pm \frac{right-left}{-2*near}$</li><li>$y=\pm\frac{top-down}{-2*near}$</li><li>$z_{min}=-near$</li><li>$z_{max}=-far$</li></ul></li></ul></li><li><p><strong>Perspective Normalization Matrix</strong></p><ul><li>错切变换<ul><li>$((left+right)/2, (top+bottom)/2,-near)$变到$(0,0,-near)$</li><li>$H(\theta,\phi)=H(arccot\frac{left+right}{-2near},arccot(\frac{top+bottom}{-2near}))$</li></ul></li><li>scaling from view volume to normalization<ul><li>变为 $x=\pm z$; $y=\pm z$</li><li>$s_x=1/x=-2*near/(right-left)$</li><li>$s_y=1/y=-2*near/(top-bottom)$</li><li>$s_z=1$</li></ul></li><li>投影规范化矩阵<ul><li>$N=\begin{bmatrix}1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;\alpha&amp;\beta\0&amp;0&amp;-1&amp;0\end{bmatrix}$</li></ul></li></ul><p>$$<br>M_{persp}=NSH=<br>\begin{bmatrix}<br>\frac{2<em>near}{right-left}&amp;0&amp;\frac{right+left}{right-left}&amp;0\<br>0&amp;\frac{2</em>near}{top-bottom}&amp;\frac{top+bottom}{top-bottom}&amp;0\<br>0&amp;0&amp;-\frac{far+near}{far-near}&amp;\frac{-2<em>far</em>near}{far-near}\<br>0&amp;0&amp;-1&amp;0<br>\end{bmatrix}<br>$$</p></li></ul></li><li><p><strong>Orthographic</strong> 正则投影</p><ul><li><p>视见体：长方体</p></li><li><p><strong>Orthographic Matrix</strong></p></li><li><p><strong>Orthographic in View Volume</strong></p><ul><li><em>Ortho(left, right, bottom, top, near, far)</em></li></ul></li><li><p><strong>Orthographic Normalization Matrix</strong></p><ul><li>先移动到原点</li><li>Scaling from view volume to normalization<ul><li>$s_x=1/x=2/(right-left)$</li><li>$s_y=1/y=2/(top-bottom)$</li><li>$s_z=1/z=2/(near-far)$</li></ul></li><li>So,</li></ul><p>$$<br>\begin{align}<br>M_{ortho}&amp;=ST\&amp;=<br>\begin{bmatrix}<br>\frac{2}{right-left}&amp;0&amp;0&amp;0\<br>0&amp;\frac{2}{top-bottom}&amp;0&amp;0\<br>0&amp;0&amp;\frac{2}{far-near}&amp;0\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\cdot<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;-\frac{right+left}{2}\<br>0&amp;1&amp;0&amp;-\frac{top+bottom}{2}\<br>0&amp;0&amp;1&amp;-\frac{far+near}{2}\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\&amp;=\begin{bmatrix}<br>\frac{2}{right-left}&amp;0&amp;0&amp;-\frac{left+right}{right-left}\<br>0&amp;\frac{2}{top-bottom}&amp;0&amp;-\frac{top+bottom}{top-bottom}\<br>0&amp;0&amp;-\frac{2}{far-near}&amp;-\frac{far+near}{far-near}\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}\<br>\end{align}<br>$$</p></li></ul></li></ul><h2 id="2-The-Modelview-Duality"><a href="#2-The-Modelview-Duality" class="headerlink" title="2. The Modelview Duality"></a>2. The Modelview Duality</h2><ul><li><p>Inverses Matrices（此部分查看03）</p></li><li><p><strong>Viewing and Modeling transformations</strong></p><ul><li>Viewing：<code>LookAt(eyex, eyey, eyez, atx, aty, atz, upx, upy, upz)</code></li><li>Modeling：<ul><li><code>Translatef(tx, ty, tz)</code></li><li><code>Rotatef(angle, x, y, z)</code></li><li><code>Scalef(sx, sy, sz)</code></li></ul></li></ul></li><li><p><strong>Viewing Transformation</strong></p><ul><li><p><strong>eye</strong> as <strong>origin</strong>; </p></li><li><p><strong>view-plane normal</strong> $n$ as <strong>z-axis</strong>; </p></li><li><p><strong>view-up vector (VUP)</strong> $v$ as <strong>y-axis</strong>; </p></li><li><p><strong>x-axis</strong>: $u=v\times n$</p></li><li><p><code>LookAt(eye, at, up)</code> code</p><pre class=" language-c++"><code class="language-c++">mat4 LookAt( const vec4& eye, const vec4& at, const vec4& up){  vec4 n = normalize(eye - at);   vec4 u = normalize(cross(up,n));   vec4 v = normalize(cross(n,u));   vec4 t = vec4(0.0, 0.0, 0.0, 1.0);   mat4 c = mat4(u, v, n, t);  return c * Translate( -eye ); }</code></pre></li></ul></li></ul><h2 id="3-Definition-of-Viewport"><a href="#3-Definition-of-Viewport" class="headerlink" title="3. Definition of Viewport"></a>3. Definition of Viewport</h2><ul><li><strong>Viewport</strong> is a rectangular region in the window to which you can draw.</li><li><strong>Viewport Matrix</strong><ul><li>$P’=T_2<em>S</em>T_1*P$</li></ul></li></ul><h2 id="4-Sequence-of-OpenGL-Transformation"><a href="#4-Sequence-of-OpenGL-Transformation" class="headerlink" title="4. Sequence of OpenGL Transformation"></a>4. Sequence of OpenGL Transformation</h2><ul><li>Sequence Picture</li></ul><p><img src="./04-01.png" alt="04-01 Sequence of OpenGL Transformation"></p><ul><li><strong>Current Transformation Matrix</strong> CTM<ul><li>Conceptually there is a 4 x 4 homogeneous coordinate matrix, the <em>current transformation matrix</em> (CTM) that is part of the state and is applied to all vertices that pass down the pipeline</li><li>The CTM is defined in the user program and loaded into a transformation unit</li><li>Remember that <strong>last matrix specified in the program</strong> is the <strong>first applied</strong></li><li><strong>CTM in OpenGL</strong>: Model-view &amp; Projection</li></ul></li></ul><h2 id="5-Shadows"><a href="#5-Shadows" class="headerlink" title="5. Shadows"></a>5. Shadows</h2><ul><li><p><strong>shadow areas</strong> are:</p><ul><li>to be seen from the view position</li><li>not to be seen from light source position</li></ul></li><li><p><strong>Shadows from a directional light</strong><br>$$<br>\begin{pmatrix}<br>x’\y’\z’\w’<br>\end{pmatrix}<br>=<br>\begin{bmatrix}<br>b\times dy+c\times dz&amp;-b\times dx&amp;-c\times dx &amp; -d\times dx\<br>-a\times dy&amp; a\times dx+c\times dz&amp;-c\times dy&amp;-d\times dy\<br>-a\times dz&amp; -b\times dz&amp;a\times dx+b\times dy&amp;-d\times dz\<br>0&amp;0&amp;0&amp;a\times dx+b\times dy+c\times dz<br>\end{bmatrix}<br>\cdot<br>\begin{pmatrix}<br>x\y\z\1<br>\end{pmatrix}<br>$$</p></li><li><p><strong>shadows from a point light</strong><br>$$<br>\begin{pmatrix}<br>x’\y’\z’\w’<br>\end{pmatrix}<br>=<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;0\<br>0&amp;1&amp;0&amp;0\<br>0&amp;0&amp;1&amp;0\<br>\frac{a}{-d}&amp;\frac{b}{-d}&amp;\frac{c}{-d}&amp;0<br>\end{bmatrix}<br>\begin{pmatrix}<br>x\y\z\1<br>\end{pmatrix}<br>$$</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（三）Geometric Objects and Transformations</title>
      <link href="/computer-graphics-03/"/>
      <url>/computer-graphics-03/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（三）Geometric-Objects-and-Transformations"><a href="#计算机图形学（三）Geometric-Objects-and-Transformations" class="headerlink" title="计算机图形学（三）Geometric Objects and Transformations"></a>计算机图形学（三）Geometric Objects and Transformations</h1><h2 id="1-Vector-and-Vector-Operation"><a href="#1-Vector-and-Vector-Operation" class="headerlink" title="1. Vector and Vector Operation"></a>1. Vector and Vector Operation</h2><ul><li><strong>Vectors</strong> 向量<ul><li>加法 Addition：$(a_1,a_2,a_3)+(b_1,b_2,b_3)=(a_1+b_1,a_2+b_2,a_3+b_3)$</li><li>标量乘法 Scalar Multiplication：$c<em>\langle x,y,z\rangle=\langle c</em>x,c<em>y,c</em>z\rangle$</li><li>点乘 Dot Product：<ul><li>$(a_1,a_2,a_3)\cdot(b_1,b_2,b_3)=a_1b_1+a_2b_2+a_3b_3$</li><li>$A\cdot B=||A||<em>||B||</em>\cos(\theta)$</li></ul></li><li>叉乘 Cross Product：<ul><li>$(a_1,a_2,a_3)\times(b_1,b_2,b_3)=(a_2b_3-a_3b_2,a_3b_1-a_1b_3,a_1a_2-a_2b_1)$</li><li>$A\times B=-(B\times A)$</li><li>Reflection Vectors:$Q=2N(N\cdot P)-P$</li></ul></li></ul></li></ul><h2 id="2-What-is-a-2D-or-3D-Space"><a href="#2-What-is-a-2D-or-3D-Space" class="headerlink" title="2. What is a 2D or 3D Space?"></a>2. What is a 2D or 3D Space?</h2><ul><li><strong>ADTs for points and Vectors</strong><ul><li>ADT 虚拟数据结构</li></ul></li></ul><h2 id="3-Lines-and-Parameter-Equation"><a href="#3-Lines-and-Parameter-Equation" class="headerlink" title="3. Lines and Parameter Equation"></a>3. Lines and Parameter Equation</h2><ul><li><strong>ray</strong>, <strong>line segment</strong><ul><li>$P=P_0+t(P_1-P_0)=(1-t)P_0+tP_1$</li></ul></li></ul><h2 id="4-Plane-and-Normal"><a href="#4-Plane-and-Normal" class="headerlink" title="4. Plane and Normal"></a>4. Plane and Normal</h2><ul><li>Plane Equation<ul><li>$(A,B,C)\cdot (x-x_0,y-y_0,z-z_0)=0$</li><li>$Ax+By+Cz+D=0$</li></ul></li><li>Relations of a Plane and a Point<ul><li>$Ax+By+Cz&gt;-D$  （in front）</li><li>$Ax+By+Cz&lt;-D$  （in back）</li></ul></li><li>line segment intersects the plane<ul><li>$t=-(Ax_0+By_0+Cz_0+D)/(A(x_1-x_0)+B(y_1-y_0)+C(z_1-z_0))$</li><li>$0\le t\le 1$，有交点</li></ul></li><li>Distance from a Point to a Plane<ul><li>$D=|(P-Q)\cdot n|$</li></ul></li><li>Convexity 凸性</li></ul><h2 id="5-Parametric-Curves"><a href="#5-Parametric-Curves" class="headerlink" title="5. Parametric Curves"></a>5. Parametric Curves</h2><ul><li><p>Parametric curve: $x(t),y(t),z(t)$</p></li><li><p>Parametric surface: $x(s,t),y(s,t),z(s,t)$</p></li><li><p>Triangle-Based Collision Detection</p><ul><li>算法</li></ul><blockquote><ol><li><p>比较两个包围球或包围盒：两个球心距离小于两个半径的和，则可能碰撞；</p></li><li><p>可能碰撞时，则一个物体的每个三角形与另一个包围体比较，假设是包围球：比较三角形的每个顶点:如果顶点与球心距离小于三角形最长边<strong>+</strong>球的半径， 则可能碰撞；或比较三角形外接圆（<strong>circumcircle</strong>）与包围球:如果外接圆心与球心距离 小于 外接圆半径<strong>+</strong>球的半径，则可能碰撞;</p></li><li><p>比较两个三角形是否碰撞：一个三角形的每个顶点 是否 在另一个三角形平面 的一边，即$Ax_i+By_i+Cz_i+D&gt;0$ (i=1,2,3) 或$Ax_i+By_i+Cz_i+D&lt;0$ (i=1,2,3)。如果在一边，则不会碰撞，否则可能碰撞（三角形与另一三角形相交）；</p></li><li><p>判断一个三角形是否与另一个三角形相交：<br>  一个三角形的边$Q_0Q_1$与另一个三角形平面的交点<strong>Q</strong>是否在另一个三角形$P_0P_1P_2$里面，即，若以下三个不等式同时成立<br>   $N·((P_1-P_0) ×(Q-P_0)) &gt; 0$<br>   $N·((P_2-P_1) ×(Q-P_1)) &gt; 0$<br>   $N·((P_0-P_2) ×(Q-P_2))&gt; 0$</p><p>则<strong>Q</strong>在三角形$P_0P_1P_2$里面</p></li></ol></blockquote></li></ul><h2 id="6-What-is-Transformation"><a href="#6-What-is-Transformation" class="headerlink" title="6. What is Transformation?"></a>6. What is Transformation?</h2><ul><li><strong>Translation</strong>：$P’=P+T$, T is translation vector<ul><li>$T=(T_x,T_y,T_z)$</li></ul></li><li><strong>Scaling</strong>: $P’=S*P$, S is a scaling matrix<ul><li>$S=\begin{bmatrix}S_x&amp;0&amp;0\0&amp;S_y&amp;0\0&amp;0&amp;S_z\end{bmatrix}$</li></ul></li><li><strong>Rotation</strong>: $P’=R*P$, R is a rotation matrix<ul><li>$R=\begin{bmatrix}1&amp;0&amp;0\0&amp;\cos\theta&amp;-\sin\theta\0&amp;\sin\theta&amp;\cos\theta\end{bmatrix}$</li></ul></li></ul><h2 id="7-Homogeneous-Coordinates"><a href="#7-Homogeneous-Coordinates" class="headerlink" title="7. Homogeneous Coordinates"></a>7. Homogeneous Coordinates</h2><ul><li><p><strong>Homogenous Coordinates</strong> 齐次坐标系：</p><ul><li>in order to express all transformations as matrices and allow them to be combined easily: $P’ = (M_3 *(M_2 *(M_1 *P)))$</li><li>最重要的优点是所有的仿射变换（具有直线的特性）都可以借助齐次坐标表示成矩阵相乘的形式。</li></ul></li><li><p><strong>Translation</strong></p><ul><li>$P’=T\cdot P$</li></ul><p>$$<br>\begin{align}<br>\begin{bmatrix}x’\y’\z’\1\end{bmatrix} =<br>\begin{bmatrix}1&amp;0&amp;0&amp;T_x\0&amp;1&amp;0&amp;T_y\0&amp;0&amp;1&amp;T_z\0&amp;0&amp;0&amp;1\end{bmatrix}<br>\begin{bmatrix}x\y\z\1\end{bmatrix} =<br>\begin{bmatrix}x+T_x\y+T_y\z+T_z\1\end{bmatrix}<br>\end{align}<br>$$</p></li></ul><ul><li><p><strong>Scaling</strong></p><ul><li>$P’=S\cdot P$</li></ul><p>$$<br>\begin{align}<br>\begin{bmatrix}x’\y’\z’\1\end{bmatrix} =<br>\begin{bmatrix}S_x&amp;0&amp;0&amp;0\0&amp;S_y&amp;0&amp;0\0&amp;0&amp;S_z&amp;0\0&amp;0&amp;0&amp;1\end{bmatrix}<br>\begin{bmatrix}x\y\z\1\end{bmatrix} =<br>\begin{bmatrix}S_xx\S_yy\S_zz\1\end{bmatrix}<br>\end{align}<br>$$</p></li><li><p><strong>Rotation</strong>: $\theta$逆时针</p></li></ul><ul><li>$P’=R_x(\theta)\cdot P$</li></ul><p>$$<br>  \begin{align}<br>  \begin{bmatrix}x’\y’\z’\1\end{bmatrix} =<br>  \begin{bmatrix}1&amp;0&amp;0&amp;0\0&amp;\cos\theta&amp;-\sin\theta&amp;0\0&amp;\sin\theta&amp;\cos\theta&amp;0\0&amp;0&amp;0&amp;1\end{bmatrix}<br>  \begin{bmatrix}x\y\z\1\end{bmatrix}<br>  \end{align}<br>$$</p><p>$$<br>  R_y(\theta)=<br>  \begin{bmatrix}<br>  \cos\theta&amp;0&amp;\sin\theta&amp;0\<br>  0&amp;1&amp;0&amp;0\<br>  -\sin\theta&amp;0&amp;\cos\theta&amp;0\<br>  0&amp;0&amp;0&amp;1<br>  \end{bmatrix}<br>  \<br>  R_z(\theta)=<br>  \begin{bmatrix}<br>  \cos\theta&amp;-\sin\theta&amp;0&amp;0\<br>  \sin\theta&amp;\cos\theta&amp;0&amp;0\<br>  0&amp;0&amp;1&amp;0\<br>  0&amp;0&amp;0&amp;1<br>  \end{bmatrix}<br>$$</p><ul><li><strong>Inverses Matrices</strong></li></ul><ul><li><strong>Translation:</strong> $T^{-1}(d_x,d_y,d_z)=T(-d_x,-d_y,-d_z)$</li><li><strong>Rotation:</strong> $R^{-1}(\theta)=R(-\theta)=R^T$</li><li><strong>Scaling:</strong> $S^{-1}(s_x,s_y,s_z)=S(1/s_x,1/s_y,1/s_z)$</li><li>$I=AB=BA$, then $B=A^{-1}$</li></ul><h2 id="8-Composite-Transformations"><a href="#8-Composite-Transformations" class="headerlink" title="8. Composite Transformations"></a>8. Composite Transformations</h2><ul><li><p>Ex1. Scaling with respect to a fixed position (a,b,c)</p><ol><li>Translate fixed point to origin $T(-a,-b,-c)=T_1$</li><li>Scale $S$</li><li>translate fixed point back to its starting positions $T_2$</li></ol><ul><li>$P’=(T_2<em>(S</em>(T_1<em>P)))=(T_2</em>S<em>T_1)</em>P=M*P$</li></ul></li><li><p>Ex2. rotation with respect to a fixed position (a,b,c)</p></li><li><p>Ex3. scaling with respect to a fixed direction $\theta$</p><ol><li>rotation a fixed angle counterclockwise $R(\theta)=R_1$</li><li>scaling $S$</li><li>rotation a fixed angle clockwise $R(\theta)=R_2$</li></ol><ul><li>$P’=(R_2<em>(S</em>(R_1*P)))$</li></ul></li><li><p>Ex4. rotation with respect to an arbitrary line</p><ul><li>$P’=T(p_0)<em>R_x(-\theta_x)</em>R_y(-\theta_y)<em>R_z(\theta_z)</em>R_y(\theta_y)<em>R_x(\theta_x)</em>T(-p_0)*P$</li></ul></li></ul><h2 id="9-Reflection-Transformation-反射变换"><a href="#9-Reflection-Transformation-反射变换" class="headerlink" title="9. Reflection Transformation 反射变换"></a>9. Reflection Transformation 反射变换</h2><ul><li>x轴，y轴，z轴（相对于坐标原点），y=x</li></ul><p>$$<br>\begin{bmatrix}1&amp;0&amp;0\0&amp;-1&amp;0\0&amp;0&amp;1\end{bmatrix}\ \ \<br>\begin{bmatrix}-1&amp;0&amp;0\0&amp;1&amp;0\0&amp;0&amp;1\end{bmatrix}\ \ \<br>\begin{bmatrix}-1&amp;0&amp;0\0&amp;-1&amp;0\0&amp;0&amp;1\end{bmatrix}\ \ \<br>\begin{bmatrix}0&amp;1&amp;0\1&amp;0&amp;0\0&amp;0&amp;1\end{bmatrix}\ \ \<br>$$</p><h2 id="10-Shear-Transformation-错切变换"><a href="#10-Shear-Transformation-错切变换" class="headerlink" title="10. Shear Transformation 错切变换"></a>10. Shear Transformation 错切变换</h2><ul><li><p>相对于X轴的x方向错切的变换矩阵</p><ul><li>$x=x+sh_x*y$;  $y=y$</li></ul></li><li><p>相对于Y轴的y方向错切的变换矩阵</p><ul><li>$x=x$;  $y=y+sh_y*x$</li></ul><p>$$<br>\begin{bmatrix}1&amp;sh_x&amp;0\0&amp;1&amp;0\0&amp;0&amp;1\end{bmatrix}<br>\ \ \<br>\begin{bmatrix}1&amp;0&amp;0\sh_y&amp;1&amp;0\0&amp;0&amp;1\end{bmatrix}<br>$$</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（二）Graphics Programming</title>
      <link href="/computer-graphics-02/"/>
      <url>/computer-graphics-02/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（二）Graphics-Programming"><a href="#计算机图形学（二）Graphics-Programming" class="headerlink" title="计算机图形学（二）Graphics Programming"></a>计算机图形学（二）Graphics Programming</h1><h2 id="1-OpenGL-Evolution"><a href="#1-OpenGL-Evolution" class="headerlink" title="1. OpenGL Evolution"></a>1. OpenGL Evolution</h2><ul><li><p><strong>start</strong></p><ul><li>Silicon Graphics （SGI）revolutionized the graphics workstation by implementing the pipeline in hardware（1982）.</li><li>The success of GL lead to OpenGL（1992）, a platform-independent API.</li></ul></li><li><p><strong>Modern OpenGL</strong></p><ul><li><p>流程图</p><pre class=" language-mermaid"><code class="language-mermaid">graph LR  A[Vertices]-->B[Vertex prcessor]-->C[Clipper and primitive assembler]-->D[Rasterizer]-->E[Fragment processor]-->Pixel</code></pre></li><li><p><strong>Shaders:</strong> control GPU through programs</p></li><li><p>GPU does all rendering</p></li></ul></li><li><p><strong>OpenGL 3.1</strong></p><ul><li>Totally shader-based</li><li>No <strong>immediate mode</strong><ul><li>立即绘制（immediate mode） &amp; 延迟绘制（retained mode）</li></ul></li></ul></li><li><p><strong>Direct X</strong></p><ul><li>windows only</li><li>Advantages<ul><li>Better control of resources</li><li>Access to high level functionality</li></ul></li><li>Disadvantages<ul><li>New versions not backward compatible</li><li>Windows only</li></ul></li></ul></li></ul><h2 id="2-OpenGL-Libraries"><a href="#2-OpenGL-Libraries" class="headerlink" title="2. OpenGL Libraries"></a>2. OpenGL Libraries</h2><ul><li>OpenGL core library</li><li>OpenGL Utility Library （GLU）<ul><li>Provides functionality in OpenGL core but avoids having to rewrite code</li></ul></li><li>OpenGL Utility Toolkit（GLUT）<ul><li>Provides functionality common to all window systems</li><li>Code is portable but GLUT lacks the functionality of a good toolkit for a specific platform</li></ul></li><li>FreeGLUT</li><li>GLEW</li></ul><h2 id="3-OpenGL-Introduction"><a href="#3-OpenGL-Introduction" class="headerlink" title="3. OpenGL Introduction"></a>3. OpenGL Introduction</h2><ul><li><p><strong>OpenGL Function</strong></p><ul><li><p>图元函数 Primitives：定义了系统可以显示的低级对象或最基本的实体（如Points, Line Segments, Triangles）</p></li><li><p>属性函数 Attribue：如图形颜色信息，光源属性，材质属性</p></li><li><p>变换函数 Transformations：</p><ul><li>Viewing 观察函数：定义各种视图</li><li>Modeling 模型函数</li></ul></li><li><p>控制函数 Control（GLUT）：与窗口系统通信</p></li><li><p>查询函数 Query：如照相机的参数或者帧缓存中的值</p></li><li><p>函数命名格式：</p><blockquote><p> Lib name:gl, glu, glut, glew + Command name + {dimension: 2,3,4} + {parameter data type: sifdb(wb)} + {array identification: v} (parameter)</p><p>如 glUniform3f(x,y,z)</p></blockquote></li></ul></li><li><p><strong>OpenGL State</strong></p><ul><li>OpenGL is a <strong>state machine</strong><ul><li>状态机，即一个包含有限状态机的黑盒子</li></ul></li><li>OpenGL functions are of two types<ul><li>Primitive generating：定义图元</li><li>State changing：改变机器内部的状态或者返回状态信息</li></ul></li></ul></li><li><p>Lack of Object Orientation</p></li><li><p><strong>GLSL</strong> ：OpenGL Shaing Language</p><ul><li>Vertex Data</li><li>Vertex Shader</li><li>Tessellation Control Shader</li><li>Tessellation Evalution Shader</li><li>Geometry Shader</li><li>Primitive Setup</li><li>Clipping</li><li>Rasterization</li><li>Fragment Shader</li></ul></li></ul><h2 id="4-A-Simple-Program"><a href="#4-A-Simple-Program" class="headerlink" title="4. A Simple Program"></a>4. A Simple Program</h2><ul><li>Display, init, glutMainLoop</li></ul><h2 id="5-OpenGL-Primitives"><a href="#5-OpenGL-Primitives" class="headerlink" title="5. OpenGL Primitives"></a>5. OpenGL Primitives</h2><ul><li>GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_TRIANGLES, GL_LINE_LOOP, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN（扇形）</li><li>OpenGL will only display triangles<ul><li>Simple: 线没有交叉</li><li>Convex 凸性：多边形任意两点连线上的点仍然在多边形内部</li><li>Flat: 所有的点在相同的平面</li></ul></li></ul><h2 id="6-OpenGL-Shaders-Programming"><a href="#6-OpenGL-Shaders-Programming" class="headerlink" title="6. OpenGL Shaders Programming"></a>6. OpenGL Shaders Programming</h2><ul><li><p>流程</p><ul><li>Vertex processing：计算每个顶点的颜色</li><li>Clipping and primitive assembly：剪裁，图元计算</li><li>Rasterization：光栅化，将图元转换为像素点</li><li>Fragment Processing：计算每个像素点的颜色</li></ul></li><li><p>Vertex Array Object（VAO）</p><ul><li>绑定所有顶点数据（位置，颜色等）</li><li><em>glBindVertexArray</em>：和VBO能够交互</li></ul></li><li><p>Vertex Buffer Object （VBO）</p><ul><li><p>Buffers objects allow us to transfer large amount of data to the GPU</p></li><li><p>Need to create, bind and identify data</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">glGenBuffers</span><span class="token punctuation">(</span>NumBuffers<span class="token punctuation">,</span> Buffers<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> Buffers<span class="token punctuation">[</span>ArrayBuffer<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">,</span> vertices<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><p>执行模型图</p><ul><li><p>顶点着色</p><p><img src="./02-02.png" alt="02-02 顶点着色过程"></p></li><li><p>片元着色</p><p><img src="./02-03.png" alt="02-03 片元着色"></p></li></ul></li></ul><h2 id="7-2D-Sierpinski-gasket"><a href="#7-2D-Sierpinski-gasket" class="headerlink" title="7. 2D Sierpinski gasket"></a>7. 2D Sierpinski gasket</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学（一）Graphics Systems and Models</title>
      <link href="/computer-graphics-01/"/>
      <url>/computer-graphics-01/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学（一）Graphics-Systems-and-Models"><a href="#计算机图形学（一）Graphics-Systems-and-Models" class="headerlink" title="计算机图形学（一）Graphics Systems and Models"></a>计算机图形学（一）Graphics Systems and Models</h1><p>  课本：<em>Iteractive Computer Graphics (sixth)</em></p><h2 id="1-Applications-Areas-应用领域"><a href="#1-Applications-Areas-应用领域" class="headerlink" title="1. Applications Areas 应用领域"></a>1. Applications Areas 应用领域</h2><ul><li><strong>Showing photos, pictures</strong></li><li><strong>Presenting Information</strong></li><li><strong>Animation</strong> 仿真和动画</li><li><strong>GUI</strong> 用户界面<ul><li>CAD, Computer Aided Design</li></ul></li></ul><h2 id="2-What-is-Computer-Graphics"><a href="#2-What-is-Computer-Graphics" class="headerlink" title="2. What is Computer Graphics?"></a>2. What is Computer Graphics?</h2><ul><li><p><strong>Relative Disciplines</strong></p><ul><li><strong>Image</strong> Processing – 2D</li><li>Pattern Recognize – picture</li><li>Computer <strong>Graphics</strong> – 3D</li><li>Geometry Computing</li></ul><pre class=" language-mermaid"><code class="language-mermaid">graph LR;  A[Image]--Pattern Recognize-->B[Data and Geometry Model];  B--Computer Graphics-->A;  A--Image Processing-->A;  B--Geometry Computing-->B;</code></pre></li><li><p><strong>Graphics System</strong></p><ul><li><p>六个元素：</p><ul><li>输入设备（input Device)</li><li>中央处理单元（CPU）</li><li>图形处理单元（GPU）：Graphics Cards<ul><li>Operating geometry data: vector, matrix, normal product</li><li>Rasterization Processing</li><li>Shader Language for programming</li><li>With graphics memory – <strong>Frame Buffer</strong></li></ul></li><li>存储器（Memory）</li><li>帧缓存（Frame Buffer）：Screen</li><li>输出设备（Output Device）</li></ul></li><li><p>结构：</p><p><img src="./01-02.png" alt="01-02 图形系统结构"></p></li></ul></li><li><p><strong>一些术语</strong></p><ul><li>像素（pixel）：Picture Element</li><li>光栅（raster）：像素阵列</li><li>帧缓存（frame buffer）：存储像素的存储区域</li><li>分辨率（resolution）：帧缓存中像素的数目，决定了从图像中可以分辨出多少细节。</li><li>帧缓存的深度（depth）或精度（precision）：每个像素所用的比特数，决定了可以表示多少颜色之类的性质。全彩色，24个比特（或更多）；真彩色，RGB；高动态范围（HDR）系统，每种原色12或更多的比特数。</li><li>光栅化（rasterization）或扫描转换（scan conversion）：从几何实体到帧缓存中像素的颜色和位置的转换。</li></ul></li></ul><h2 id="3-History"><a href="#3-History" class="headerlink" title="3. History"></a>3. History</h2><ul><li>1960s, Sketchpad</li><li>1970s, Raster Graphics</li><li>1980s, Computer Graphics, Realism</li><li>1990s, OpenGL API</li><li>2000-, Photorealism, Graphics Cards, Game, Movie, Programmable Pipelines</li></ul><h2 id="4-The-Graphics-Pipeline"><a href="#4-The-Graphics-Pipeline" class="headerlink" title="4. The Graphics Pipeline"></a>4. The Graphics Pipeline</h2><ul><li><p>计算机图形学的两个阶段：</p><ul><li><strong>Modeling</strong> 从几何模型到屏幕空间</li><li>在屏幕空间创建目标图像</li></ul></li><li><p>图形流水线的两个部分：</p><ul><li><strong>Modeling Pipeline</strong></li><li><strong>Rendering Pipeline</strong></li></ul></li><li><p><strong>Modeling Pipeline</strong></p><ul><li>流水线体系结构</li></ul><p><img src="./01-03.png" alt="01-03 Modeling Pipeline"></p><ul><li>Projection：透视 Perspective，梯形；正则 Orthographic，长方体</li></ul></li><li><p>Rendering Pipeline**</p><ul><li>渲染流水线</li></ul><p><img src="./01-04.png" alt="01-04 渲染流水线"></p><ul><li>Vertices Shader, Primitives, Rasterization, Fragments Shader, Pixels（Frame Buffer）</li><li>顶点处理（坐标变换和计算每个顶点的颜色值）、剪裁和图元组装、光栅化、片元处理（更新帧缓存中的像素）</li></ul></li></ul><h2 id="5-Image-Formation"><a href="#5-Image-Formation" class="headerlink" title="5. Image Formation"></a>5. Image Formation</h2><ul><li><strong>元素：</strong>Objects, Viewer, Light sources, 材质信息</li><li><strong>Imaging System</strong><ul><li>Cameras</li><li>Microscopes</li><li>Telescopes</li><li>Human Visual System</li><li>3D film</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> School </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试与维护（十一）软件维护</title>
      <link href="/software-test-maintance-11/"/>
      <url>/software-test-maintance-11/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试与维护（十一）：软件维护"><a href="#软件测试与维护（十一）：软件维护" class="headerlink" title="软件测试与维护（十一）：软件维护"></a>软件测试与维护（十一）：软件维护</h1><h2 id="软件维护的定义"><a href="#软件维护的定义" class="headerlink" title="软件维护的定义"></a>软件维护的定义</h2><ul><li><strong>软件维护</strong>是指软件系统交付使用以后，为了改正错误或满足新的需求而修改软件的过程。</li><li>要求进行维护的原因：<ul><li>改正程序中的错误和缺陷。</li><li>改进软件以适应新的软、硬件环境。</li><li>增加新的应用范围。</li></ul></li></ul><h2 id="软件维护的类型"><a href="#软件维护的类型" class="headerlink" title="软件维护的类型"></a>软件维护的类型</h2><ul><li><strong>改正性维护</strong><ul><li>在软件交付使用后，因开发阶段的问题以及测试不彻底、不完全，必然会有部分隐藏的错误遗留到运行阶段。</li><li>为了<strong>识别和纠正</strong>软件错误、改正软件功能、非功能（性能）上的缺陷、排除实施中的误使用， 应当进行的<strong>诊断和改正错误的过程</strong>就叫做改正性维护。</li></ul></li><li><strong>适应性维护</strong><ul><li>在使用过程中，<ul><li>外部环境（新的硬、软件配置）</li><li>数据环境（数据库、数据格式、数据输入/输出方式、数据存储介质）可能发生变化。</li></ul></li><li>为使软件<strong>适应这种变化</strong>，而去修改软件的过程叫做适应性维护。</li></ul></li><li><strong>完善性维护</strong><ul><li>在软件的使用过程中，用户往往会对软件提出<strong>新的功能与性能要求</strong>。</li><li>为满足这些要求，需要<strong>修改或再开发软件软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性</strong>。</li><li>这种情况下进行的维护活动叫做完善性维护。</li></ul></li><li><strong>预防性维护</strong><ul><li>预防性维护即<strong>软件再工程</strong>，是为了提高软件的可维护性、可靠性等，为以后进一步改进软件打下良好基础。</li><li>采用先进的软件工程方法对需要维护的软件或软件中的某一部分（重新）进行设计、编制和测试，称为预防性维护。</li></ul></li><li><strong>各种占比</strong><ul><li>完善性维护：50-66%、适应性维护：18-25%</li><li>改正性维护：17-21%、其它维护：4%</li><li>维护占比：70.8%</li></ul></li></ul><h2 id="结构化维护-VS-非结构化维护"><a href="#结构化维护-VS-非结构化维护" class="headerlink" title="结构化维护 VS 非结构化维护"></a>结构化维护 VS 非结构化维护</h2><ul><li><strong>结构性维护：</strong>如果采用软件工程的方法进行软件开发，保证<strong>每个阶段都有完整且详细的文档</strong>，这样维护会相对容易。</li><li><strong>非结构化的维护：</strong>如果不采用软件工程方法开发软件，软件只有程序而欠缺文档，则维护工作变得十分困难。</li></ul><h2 id="影响软件维护工作量的因素"><a href="#影响软件维护工作量的因素" class="headerlink" title="影响软件维护工作量的因素"></a>影响软件维护工作量的因素</h2><ul><li><strong>系统的大小</strong></li><li><strong>程序设计语言</strong></li><li><strong>系统年龄</strong></li><li><strong>先进的软件开发技术</strong></li><li><strong>其它一些因素</strong></li></ul><h2 id="软件维护的过程"><a href="#软件维护的过程" class="headerlink" title="软件维护的过程"></a>软件维护的过程</h2><h3 id="系统开发流程"><a href="#系统开发流程" class="headerlink" title="系统开发流程"></a>系统开发流程</h3><p><img src="./11-01.png" alt="11-01 系统开发流程"></p><h3 id="实现变更"><a href="#实现变更" class="headerlink" title="实现变更"></a>实现变更</h3><ul><li>修改软件需求说明</li><li>修改软件设计</li><li>设计评审</li><li>对源程序做必要的修改</li><li>单元测试</li><li>集成测试（回归测试）</li><li>确认测试</li><li>软件配置评审</li></ul><h3 id="整体变更控制"><a href="#整体变更控制" class="headerlink" title="整体变更控制"></a>整体变更控制</h3><p><img src="./11-02.png" alt="11-02 软件变更控制流程"></p><h3 id="维护的流程"><a href="#维护的流程" class="headerlink" title="维护的流程"></a>维护的流程</h3><ul><li>维护申请 -&gt; 影响分析与评价 -&gt; 维护修改报告 -&gt; 维护记录保存 -&gt; 维护后评审 -&gt; 维护后测试 -&gt; 维护后验收</li></ul><h2 id="可维护性（maintenanceability）"><a href="#可维护性（maintenanceability）" class="headerlink" title="可维护性（maintenanceability）"></a>可维护性（maintenanceability）</h2><ul><li><strong>软件可维护性</strong>是指纠正软件系统系统出现的错误和缺陷，以及为满足新的要求进行修改、扩充或压缩的<strong>容易程度</strong>。</li><li><strong>七个特性</strong>：<ul><li>可理解性：表明人们通过阅读源代码和相关文档，了解程序功能及其如何运行的容易程度。</li><li>可靠性：表明一个程序按照用户的要求和设计目标，再给定的一段时间内正确执行的概率。</li><li>可测试性：表明论证程序正确性的容易程度。程序越简单，证明其正确性就越容易。而且设计合用的测试用例，取决于对程序的全面理解。<ul><li>一个可测试的程序应当是可理解的，可靠的，简单的。</li></ul></li><li>可修改性：程序容易修改的程度</li><li>可移植性：表明程序转移到一个新的计算环境的可能性大小。或者它表明程序可以容易地、有效地在各种各样的计算环境中运行的容易程度。</li><li>效率：表明一个程序能执行预定功能而又不浪费机器资源的程度。资源包括内存容量、外存容量、通道容量和执行时间。</li><li>可使用性：从用户观点出发，可使用性定义为程序方便、实用、及易于使用的程度。</li></ul></li></ul><h2 id="软件维护的管理"><a href="#软件维护的管理" class="headerlink" title="软件维护的管理"></a>软件维护的管理</h2><ul><li><strong>维护的文档</strong><ul><li>维护合同、维护方案、维护手册、维护申请表、维护记录、维护报告。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> School </tag>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试与维护（十）报告缺陷和测试报告</title>
      <link href="/software-test-maintance-10/"/>
      <url>/software-test-maintance-10/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试与维护（十）：报告缺陷和测试报告"><a href="#软件测试与维护（十）：报告缺陷和测试报告" class="headerlink" title="软件测试与维护（十）：报告缺陷和测试报告"></a>软件测试与维护（十）：报告缺陷和测试报告</h1><h2 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h2><h3 id="软件缺陷的基本描述"><a href="#软件缺陷的基本描述" class="headerlink" title="软件缺陷的基本描述"></a>软件缺陷的基本描述</h3><ul><li><strong>软件缺陷的描述</strong>是软件缺陷报告中测试人员对问题的陈述的一部分并且是软件缺陷报告的基础部分。</li><li><strong>软件缺陷的有效描述规则：</strong><ul><li>单一准确、可以再现、完整统一、短小简介、特定条件、补充完善、不做评价。</li></ul></li></ul><h3 id="软件缺陷属性"><a href="#软件缺陷属性" class="headerlink" title="软件缺陷属性"></a>软件缺陷属性</h3><ul><li><strong>软件缺陷属性</strong>包括：<ul><li>缺陷标识：标记某个缺陷的唯一表示，可以用数字序号表示。</li><li>缺陷类型：根据缺陷的自然属性划分缺陷种类。</li><li>缺陷严重程度：因缺陷引起的故障对软件产品的影响程度。</li><li>缺陷优先级：指缺陷必须被修复的紧急程度。</li><li>缺陷产生可能性：通常可以用频率来表示。</li><li>缺陷状态：指缺陷通过一个跟踪修复过程的进展情况，也就是在软件生命周期中的状态基本定义（激活或打开、已修正或修复、关闭或非激活、重新打开、推迟、保留、不能重现、需要更多信息、重复、不是缺陷、需要修改软件规格说明书）。</li><li>缺陷起源：缺陷引起的故障或事件第一次被检测到的阶段。</li><li>缺陷来源：缺陷存在的地方，如文档、代码等。</li><li>缺陷根源（背后因素）</li><li>加上时间因素和人的因素</li></ul></li></ul><h3 id="软件缺陷生命周期"><a href="#软件缺陷生命周期" class="headerlink" title="软件缺陷生命周期"></a>软件缺陷生命周期</h3><p><img src="./10-01.png" alt="10-01 软件缺陷生命周期"></p><h3 id="软件缺陷跟踪系统"><a href="#软件缺陷跟踪系统" class="headerlink" title="软件缺陷跟踪系统"></a>软件缺陷跟踪系统</h3><ul><li>主要包括<strong>缺陷管理功能</strong>和<strong>统计功能</strong>。</li></ul><h3 id="缺陷管理工具"><a href="#缺陷管理工具" class="headerlink" title="缺陷管理工具"></a>缺陷管理工具</h3><ul><li>常见免费：Mantis、Bugzilla</li><li>付费：Testdirector、JIRA</li></ul><h2 id="软件缺陷报告-amp-测试报告"><a href="#软件缺陷报告-amp-测试报告" class="headerlink" title="软件缺陷报告&amp;测试报告"></a>软件缺陷报告&amp;测试报告</h2><h3 id="软件缺陷报告"><a href="#软件缺陷报告" class="headerlink" title="软件缺陷报告"></a>软件缺陷报告</h3><ul><li>任何一个缺陷跟踪系统的核心都是“软件缺陷报告”</li><li>详细信息：<ul><li>分类、项目、描述</li><li>可跟踪信息、软件缺陷基本信息、缺陷的详细描述（步骤、期望的结果、实际发生的结果）、测试环境说明、必要的附件</li></ul></li></ul><h3 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h3><ul><li>测试报告是<strong>把测试的过程和结果</strong>写成文档，并<strong>对发现的问题和缺陷进行分析</strong>，为纠正软件存在的质量问题<strong>提供依据</strong>，同时为软件验收和交付<strong>打下基础</strong>。</li><li>测试报告是测试阶段<strong>最后的文档产出物</strong>，优秀的测试经理应该具备良好的文档编写能力，一 份详细的测试报告包含足够的信息，包括<strong>产品质量</strong>和<strong>测试过程的评价</strong>，测试报告<strong>基于测试中的数据采集以及对最终的测试结果分析</strong>。</li><li>测试报告的<strong>内容</strong>：<ul><li>首页</li><li>引言（目的、背景、缩略语、参考文献）</li><li>测试概要（测试方法、范围、测试环境、工具）</li><li>测试结果与缺陷分析（功能、非功能）</li><li>测试建议与结论（项目概况、测试时间、测试情况、结论性能汇总）</li><li>附录（缺陷统计）</li></ul></li></ul><h3 id="测试报告与缺陷报告的区别"><a href="#测试报告与缺陷报告的区别" class="headerlink" title="测试报告与缺陷报告的区别"></a>测试报告与缺陷报告的区别</h3><ul><li><strong>定义</strong><ul><li>缺陷报告：描述清楚缺陷，是测试过程的结果。</li><li>测试报告：分析与总结，是阶段性的总结。</li></ul></li><li><strong>时间</strong></li><li><strong>撰写人</strong></li><li><strong>二者关系</strong><ul><li>缺陷报告为测试报告提供数据与依据，测试报告是缺陷报告的总结。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> School </tag>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试与维护（九）Acceptance Testing</title>
      <link href="/software-test-maintance-09/"/>
      <url>/software-test-maintance-09/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试与维护（九）：Acceptance-Testing"><a href="#软件测试与维护（九）：Acceptance-Testing" class="headerlink" title="软件测试与维护（九）：Acceptance Testing"></a>软件测试与维护（九）：Acceptance Testing</h1><h2 id="验收测试的基本概念"><a href="#验收测试的基本概念" class="headerlink" title="验收测试的基本概念"></a>验收测试的基本概念</h2><ul><li><strong>验收测试</strong>：在软件产品完成了<strong>功能测试和系统测试之后</strong>、<strong>产品发布之前</strong>所进行的软件测试活动，是技术测试的<strong>最后</strong>一个阶段，也称为<strong>交付测试</strong>。</li><li><strong>过程和主要内容</strong><ul><li>前提：系统或软件产品已通过系统测试的软件系统。</li><li>测试内容：验证系统是否达到了<strong>用户需求规格说明书</strong>（可能包括项目或产品验收准则）中的要求，测试试图尽可能地发现软件中存留的缺陷，从而为软件进一步改善提供帮助，并保证系统或软件产品最终被用户接受。还需进行<strong>易用性测试、兼容性测试、安装测试、 文档（如用户手册、操作手册等）测试</strong>等几个方面的内容。</li></ul></li><li><strong>验收标准和注意事项</strong><ul><li>验收标准<ul><li>完全执行了验收测试计划中的每个<strong>测试用例</strong>。</li><li>在验收测试中发现的错误已经<strong>得到修改</strong>并且<strong>通过了测试</strong>或者经过评估<strong>留待到下一版本中修改</strong>。</li><li>完成软件<strong>验收测试报告</strong>。</li></ul></li><li>注意事项<ul><li>必须编写正式的、单独的验收测试报告</li><li>验收测试必须在<strong>实际用户运行环境</strong>中进行</li><li><strong>由用户和测试部门共同执行</strong>。</li></ul></li></ul></li><li><strong>其他的验收</strong><ul><li>a测试：内部人员模拟各类用户测试</li><li>B测试：组织典型用户在日常中使用，报告异常情况，提出批评意见</li></ul></li></ul><h2 id="验收测试的测试"><a href="#验收测试的测试" class="headerlink" title="验收测试的测试"></a>验收测试的测试</h2><ul><li><p><strong>用户界面和可用性测试</strong></p><ul><li>用户界面的7个要素：符合标准和规范、直观性、一致性、灵活性、舒适性、正确性、实用性</li><li>易用性测试没有具体的量化指标</li></ul></li><li><p><strong>兼容性测试</strong></p></li><li><p>软件兼容性测试是指验证软件之间是否正确地交互和共享信息。</p><ul><li>包括：硬件兼容、软件之间兼容、数据之间兼容</li></ul></li><li><p><strong>向前和向后兼容</strong></p><ul><li>向后兼容：可以使用以前版本</li><li>向前兼容：可以使用未来版本</li></ul></li><li><p><strong>可安装性和可恢复性测试</strong></p><ul><li>可安装性：系统软件安装、应用软件安装、服务器安装、客户端安装、产品升级安装</li></ul></li><li><p><strong>文档测试</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> School </tag>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试与维护（八）Integration Test &amp; System Test</title>
      <link href="/software-test-maintance-08/"/>
      <url>/software-test-maintance-08/</url>
      
        <content type="html"><![CDATA[<h2 id="软件测试与维护（八）：Integration-Test-amp-System-Test"><a href="#软件测试与维护（八）：Integration-Test-amp-System-Test" class="headerlink" title="软件测试与维护（八）：Integration Test &amp; System Test"></a>软件测试与维护（八）：Integration Test &amp; System Test</h2><h2 id="测试环境的建立"><a href="#测试环境的建立" class="headerlink" title="测试环境的建立"></a>测试环境的建立</h2><h3 id="测试环境的五要素"><a href="#测试环境的五要素" class="headerlink" title="测试环境的五要素"></a>测试环境的五要素</h3><ul><li><strong>基本要素：</strong>软件、硬件</li><li><strong>派生要素：</strong>网络环境、数据准备、测试工具</li></ul><h3 id="测试部门建设模式"><a href="#测试部门建设模式" class="headerlink" title="测试部门建设模式"></a>测试部门建设模式</h3><ul><li>独立运作、与第三方测试机构合作、与相关企业合作、测试外包、项目经理式外包</li><li>例：TPC事物处理性能委员会</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ul><li><strong>软件逻辑架构（软件技术架构）</strong></li><li><strong>系统物理架构</strong><ul><li>将具体的软件元件放在物理元件上</li><li>具体用了几台机器做什么用，机器上装了什么软件</li></ul></li></ul><h2 id="集成测试-Integration-Test"><a href="#集成测试-Integration-Test" class="headerlink" title="集成测试 Integration Test"></a>集成测试 Integration Test</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>集成</strong> Integration：putting the pieces together</li><li><strong>集成测试：</strong>将单元组装起来再进行测试，以检查这些单元之间的<strong>接口</strong>是否存在问题，如：数据丢失、模块间相互影响、组合后不能实现主功能等。</li><li>集成测试前的准备：人员安排、测试计划、测试内容、集成策略、测试方法</li><li><strong>集成测试目标</strong> Objectives：<ul><li>保证系统设计的完整性 Gain confidence in the integraity of overall system design</li><li>保证各个组件间正常的交互 Ensure proper interaction of compoents</li><li>运行简单系统层的测试 Run simple system-level tests</li></ul></li></ul><h3 id="集成策略"><a href="#集成策略" class="headerlink" title="集成策略"></a>集成策略</h3><ul><li><p><strong>集成测试的模式</strong></p><ul><li><strong>非渐增式测试模式</strong>：先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序，如大棒模式。</li><li><strong>渐增式测试模式</strong>：把下一个要测试的模块同已经测试好的模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合起来测试。</li></ul></li><li><p><strong>非渐增式测试模式</strong></p><ul><li><strong>大棒集成</strong> Big bang<ul><li>知道全部的模块测试完成，再组合起来测试。</li><li>问题：<ul><li>避免了脚手架（桩模块和驱动模块的开销）</li><li>不易发现错误</li></ul></li></ul></li></ul></li><li><p><strong>渐增式测试模式</strong></p><ul><li>自顶向下集成测试 Top-Down<ul><li><strong>驱动程序/驱动模块</strong>（driver）：用以模拟被测模块的上级模块。启动被测模块，并打印出相应的结果。</li><li><strong>桩程序/桩模块</strong>（stub）：用以模拟被测模块工作过程中所调用的模块。 桩模块由被测模块调用。</li><li>好处：<ul><li>总是有顶层的系统</li><li>桩模块可以从接口说明书来书写</li></ul></li><li>坏处：<ul><li>可能会太迟发现性能问题</li><li>桩模块花费多</li></ul></li></ul></li><li>自底向上集成测试 Bottom-up<ul><li>好处：<ul><li>基础函数得到最多的测试</li><li>驱动程序相对便宜</li></ul></li><li>坏处：<ul><li>只有在最后才能测试完整的系统</li></ul></li></ul></li><li>混合策略测试 Modified Top-down Integration</li><li><strong>关键先行</strong> Critical-first<ul><li>首先集成最重要最关键的模块，之后增加其他的模块</li><li>保护了最重要的模块</li></ul></li></ul></li><li><p><strong>Function-at-a-time</strong></p></li><li><p><strong>几种集成测试方法性能的比较</strong></p><table><thead><tr><th></th><th>自底向上</th><th>自顶向下</th><th>混合策略</th><th>大棒集成</th></tr></thead><tbody><tr><td>集成</td><td>早</td><td>早</td><td>早</td><td>晚</td></tr><tr><td>基本程序能工作时间</td><td>晚</td><td>早</td><td>早</td><td>晚</td></tr><tr><td>需要驱动程序</td><td>是</td><td>否</td><td>是</td><td>否</td></tr><tr><td>需要桩程序</td><td>否</td><td>是</td><td>是</td><td>否</td></tr><tr><td>计划与控制</td><td>容易</td><td>难</td><td>中</td><td>容易</td></tr></tbody></table></li></ul><h2 id="系统测试-System-Test"><a href="#系统测试-System-Test" class="headerlink" title="系统测试 System Test"></a>系统测试 System Test</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>系统测试目标</strong><ul><li>获得对整个系统完整性的信心 Gain confidence in the integrity of the system as a whole</li><li>确保符合功能需求 Ensure compliance with functional requirements</li><li>确保符合非功能需求 Ensure compliance with non-functional requirements</li></ul></li></ul><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><ul><li><p><strong>概念</strong></p><ul><li>在集成测试结束之后，依据系统的<strong>需求规格说明书和产品功能说明书</strong>对系统的整体功能进行的全面测试。</li><li>采用<strong>黑盒测试</strong>方法。</li></ul></li><li><p><strong>功能测试要求</strong></p><ul><li>根据系统功能规格说明书准备测试计划 Prepare a test plan from the functional specification of the system</li><li>对全部功能设计测试 Prepare tests for all areas of functionality</li><li>审查测试计划和测试 Review test plan and tests</li><li>执行测试 Execute tests</li><li>监控缺陷率 Monitor fault rate</li><li>功能测试报告</li></ul></li><li><p><strong>功能测试主要内容</strong></p><ul><li>功能流程、界面、菜单按钮、各种输入域、各种链接、各种文字图片、与外系统的接口、软硬件的兼容、版本的兼容</li></ul></li><li><p><strong>回归测试</strong></p><ul><li><strong>定义</strong><ul><li>对<strong>修正缺陷后</strong>的软件进行再次的测试，不仅测试被修复的<strong>软件缺陷</strong>是否已经解决，还要测试软件<strong>旧有的功能与非功能</strong>是否满足要求。</li></ul></li><li><strong>方法</strong><ul><li>再测试全部用例</li><li>基于风险选择测试：测试关键的、重要的、可疑的，跳过非关键的、稳定的</li><li>基于操作剖面选择测试</li><li>再测试修改的部分</li></ul></li></ul></li><li><p><strong>冒烟测试</strong></p><ul><li><p><strong>定义</strong></p><ul><li>冒烟测试就是在每日build建立后，对系统的基本功能进行简单的测试。这种测试强调<strong>功能的覆盖率</strong>。</li></ul></li><li><p><strong>目的</strong></p><ul><li>通过<strong>最基本的测试</strong>，如果最基本的测试都有问题，就直接打回开发部了，减少测试部门时间的浪费。</li></ul></li></ul></li></ul><h3 id="非功能测试-Non-functional-Test"><a href="#非功能测试-Non-functional-Test" class="headerlink" title="非功能测试 Non-functional Test"></a>非功能测试 Non-functional Test</h3><ul><li><p><strong>性能指标</strong></p><ul><li>客户端指标：响应时间、并发数</li><li>服务器端指标：CPU占有率，内存占有情况等</li></ul></li><li><p><strong>压力测试</strong> Stress Testing</p><ul><li>定义：<ul><li>一种需要<strong>反常数量、频率或资源</strong>的方式下，执行可重复的<strong>负载测试或强度测试</strong>，以检查程序对异常情况的<strong>抵抗能力</strong>，找出<strong>性能瓶颈</strong>。</li><li>异常情况主要指的是<strong>峰值</strong>（瞬间使用高峰）、<strong>大量数据的处理能力</strong>、<strong>长时间运行</strong>等情况。压力测试总是迫使系统在异常的资源配置下运行。</li></ul></li><li>测试压力估算<ul><li>给出合理的<strong>压力估算值</strong>（结合峰值），为压力测试提供数据依据</li></ul></li><li>测试环境准备<ul><li>软硬件、网络、数据、测试程序</li><li>两种压力测试：稳定性压力测试、破坏性压力测试</li></ul></li><li><strong>稳定性压力测试</strong><ul><li>稳定性压力测试，也叫<strong>可靠性测试</strong>（reliability testing），或<strong>疲劳测试</strong>，是指以<strong>合理的估算压力</strong>连续运行被测系统，检查系统运行时的<strong>稳定程度</strong>。</li><li>通常用mtbf（mean time between failure，错误发生的平均时间间隔）来衡量系统的稳定性。</li><li>24*7的方式</li><li>使用场合：为了给出系统一个<strong>实际使用的指标和范围</strong>、<strong>使用边界条件</strong>。</li></ul></li><li><strong>破坏性压力测试</strong><ul><li>定义<ul><li>通常是指<strong>持续不断</strong>的给被测系统<strong>增加压力</strong>，直到将被测系统<strong>压垮为止</strong>。</li><li>是采用<strong>破坏的手段</strong>，目的是为了<strong>找到系统的瓶颈</strong>。</li></ul></li></ul></li></ul></li><li><p><strong>容量测试</strong> Capacity Testing</p><ul><li>目的：通过测试预先分析出反映软件系统应用特征的某项<strong>指标的极限值</strong>（如最大并发用户数、数据库记录数等），系统在其<strong>极限值状态下</strong>还能保持<strong>主要功能正常运行</strong>。容量测试还将确定测试对象在<strong>给定时间</strong>内能够<strong>持续处理</strong>的<strong>最大负载或工作量</strong>。</li></ul></li><li><p>通过压力测试的稳定性测试，可以得到<strong>容量值</strong>。</p></li><li><p><strong>性能测试</strong> Performance Testing</p><ul><li>定义：通过测试确定系统运行期间的<strong>性能表现与性能数据</strong>，如：CPU使用的效率、运行速度、响应时间、占有系统资源等方面的系统数据，<strong>给出合理的系统配置</strong>。</li><li>作用：<ul><li>去定在什么样的压力下系统达到最佳状态（稳定性压力测试），什么压力是系统的极限（破坏性压力测试）</li><li>根据性能指标确定实际的软硬件运行环境</li></ul></li><li>性能合理的范围<ul><li>服务器CPU的占有率：一般在85%以内</li><li>内存占有率：80%以内</li></ul></li><li><strong>性能测试与瓶颈分析</strong><ul><li>步骤<ul><li>性能测试与数据收集</li><li>性能瓶颈分析</li><li>性能调优解决方案</li></ul></li></ul></li></ul></li><li><p><strong>压力测试工具 LoadRunner</strong></p><ul><li>Virtual User Generator 创建脚本<ul><li>创建脚本，选择协议</li><li>录制脚本</li><li>编辑脚本</li><li>检查修改脚本是否有误</li></ul></li><li>中央控制器（Controller）来调度虚拟用户<ul><li>创建Scenario（一个测试用例），选择脚本</li><li>设置机器虚拟用户数</li><li>设置Schedule</li><li>如果模拟多机测试，设置IP Spoofer</li></ul></li><li>运行脚本<ul><li>分析scenario</li></ul></li><li>分析测试结果</li></ul></li><li><p><strong>安全测试</strong> Security Testing</p><ul><li>检查系统对<strong>非法侵入</strong>的<strong>防范能力</strong>。</li><li>准则：使非法侵入的代价超过被保护信息的价值，此时非法侵入者无利可图。</li></ul></li><li><p><strong>容错测试</strong> Recovery Testing</p><ul><li>检查软件在异常条件下自身是否具有<strong>防护性的措施</strong>或者某种<strong>灾难性恢复的手段</strong>。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> School </tag>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试与维护（七）Unit Test</title>
      <link href="/software-test-maintance-07/"/>
      <url>/software-test-maintance-07/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试与维护（七）：Unit-Test"><a href="#软件测试与维护（七）：Unit-Test" class="headerlink" title="软件测试与维护（七）：Unit Test"></a>软件测试与维护（七）：Unit Test</h1><h2 id="单元测试基本概念"><a href="#单元测试基本概念" class="headerlink" title="单元测试基本概念"></a>单元测试基本概念</h2><h3 id="单元测试的定义"><a href="#单元测试的定义" class="headerlink" title="单元测试的定义"></a>单元测试的定义</h3><ul><li><strong>定义：</strong>单元测试是对软件基本组成单元进行的测试。</li><li><strong>时机：</strong>一般是在代码完成后由开发人员完成，QA人员辅助。</li><li><strong>概念</strong><ul><li>单元：有明确的功能、性能定义、接口定义的软件设计最小单元–模块。</li><li>不是函数或类中的方法！而是模块或者类。</li></ul></li></ul><h3 id="单元测试的内容"><a href="#单元测试的内容" class="headerlink" title="单元测试的内容"></a>单元测试的内容</h3><ul><li>单元模块：局部数据结构、模块接口、出错处理、独立路径、边界条件</li></ul><h3 id="辅助模块"><a href="#辅助模块" class="headerlink" title="辅助模块"></a>辅助模块</h3><ul><li><strong>单元测试示意图</strong></li></ul><p><img src="./07-01.png" alt="07-01 单元测试模型示意图"></p><ul><li><p><strong>驱动模块</strong>（driver）：用来模拟被测试模块的上一级模块，相当于被测模块的主程序。它接收数据，将相关数据传送给被测模块，启用被测模块，并打印出相应的结果。</p></li><li><p><strong>桩模块</strong>（Stub）：模拟被测试的模块所调用的模块，而不是软件产品的组成的部分。主模块作为驱动模块,与之直接相连的模块用桩模块代替。</p></li></ul><h2 id="单元测试策略"><a href="#单元测试策略" class="headerlink" title="单元测试策略"></a>单元测试策略</h2><ul><li><strong>白盒测试与黑盒测试</strong><ul><li>静态白盒测试在现实中较少使用</li></ul></li><li><strong>正式代码审查的基本要素</strong> Essential elements of a formal code review<ul><li>识别问题 Idetify problems</li><li>遵循规则 Follow rules</li><li>准备 Prepare</li><li>书写报告 Write a report</li></ul></li><li><strong>非正式代码检查</strong> Informal code inspections<ul><li>同级审查 Peer Reviews<ul><li>采用讲解、提问方式进行，一般有正式的计划、流程和结果。主要方法采用缺陷检查表。</li><li>会议形式、报告、缺陷检查表</li></ul></li><li>走查 Walk throughs<ul><li>采用讲解、讨论和模拟运行的方式进行的查找错误的活动</li></ul></li></ul></li><li><strong>正式的代码检查</strong><ul><li>正式的代码检查有利于发现代码和设计中的问题</li></ul></li><li><strong>TDD 测试驱动开发</strong> Test-Driven Development<ul><li>先编写测试用例，再进行开发</li></ul></li></ul><p><img src="./07-02.png" alt="07-02 TDD流程"></p><h2 id="单元测试工具"><a href="#单元测试工具" class="headerlink" title="单元测试工具"></a>单元测试工具</h2><ul><li><strong>xUnit框架</strong><ul><li>JUnit, CppUnit</li><li>针对自动化单元测试框架的实际标准</li><li>测试、测试装置、测试套件、测试运行器</li></ul></li><li><strong>JUnit</strong><ul><li>开发源代码的Java测试框架，用于编写和运行可重复的测试。一般用来进行单元测试。</li><li>测试类（TestCase）、测试套件（TestSuite）、测试方法、测试运行器</li></ul></li><li><strong>Parasoft Jtest</strong>、<strong>Parasoft C++ Test</strong></li></ul><h2 id="单元测试的过程和文档管理"><a href="#单元测试的过程和文档管理" class="headerlink" title="单元测试的过程和文档管理"></a>单元测试的过程和文档管理</h2><ul><li><strong>过程</strong><ul><li>在详细设计阶段完成单元测试计划</li><li>建立单元测试环境，完成测试设计和开发</li><li>执行单元测试用例，并且详细记录测试结果</li><li>判定测试用例是否通过</li><li>提交《单元测试报告》</li></ul></li><li><strong>文档</strong><ul><li>软件需求规格说明书、软件详细说明书 –&gt; 单元测试计划</li><li>单元测试计划、软件详细设计说明书 –&gt; 单元测试用例</li><li>单元测试用例、软件需求规格说明书、软件详细设计说明书 –&gt; 缺陷跟踪报告/缺陷检查表</li><li>单元测试用例、缺陷跟踪报告、缺陷检查表 –&gt; 评估 –&gt; 单元测试报告</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> School </tag>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试与维护（六）White Box Text</title>
      <link href="/software-test-maintance-06/"/>
      <url>/software-test-maintance-06/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试与维护（六）：White-Box-Test"><a href="#软件测试与维护（六）：White-Box-Test" class="headerlink" title="软件测试与维护（六）：White Box Test"></a>软件测试与维护（六）：White Box Test</h1><h2 id="白盒测试（White-Box-Testing）"><a href="#白盒测试（White-Box-Testing）" class="headerlink" title="白盒测试（White-Box Testing）"></a>白盒测试（White-Box Testing）</h2><ul><li><strong>基本原理</strong>：基于过程设计的控制结构导出测试用例。</li><li><strong>白盒测试分类</strong><ul><li>Control Flow-Testing<ul><li>逻辑分支覆盖法<ul><li>语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖</li></ul></li><li>路径法<ul><li>路径覆盖、基本（独立）路径测试法</li></ul></li></ul></li><li>DataFlow-Testing</li></ul></li></ul><h2 id="控制流测试"><a href="#控制流测试" class="headerlink" title="控制流测试"></a>控制流测试</h2><h3 id="逻辑分支覆盖法"><a href="#逻辑分支覆盖法" class="headerlink" title="逻辑分支覆盖法"></a>逻辑分支覆盖法</h3><h4 id="1-语句覆盖（statement）"><a href="#1-语句覆盖（statement）" class="headerlink" title="1. 语句覆盖（statement）"></a>1. 语句覆盖（statement）</h4><ul><li><p><strong>概念</strong></p><ul><li>语句覆盖就是设计若干个测试用例，运行被测程序，使得<strong>每一可执行语句至少执行一次</strong>。</li><li>这种覆盖又称为<strong>点覆盖</strong>，它使得程序中每个可执行语句都得到执行，但它是<strong>最弱的逻辑覆盖</strong>，效果有限，必须与其它方法交互使用。  </li></ul></li><li><p><strong>示例</strong></p><p><img src="./02-01.png" alt="02-01"></p></li></ul><h4 id="2-判定覆盖（Decision-Coverage-Branch-Coverage）"><a href="#2-判定覆盖（Decision-Coverage-Branch-Coverage）" class="headerlink" title="2. 判定覆盖（Decision Coverage, Branch Coverage）"></a>2. 判定覆盖（Decision Coverage, Branch Coverage）</h4><ul><li><strong>概念</strong><ul><li>判定覆盖就是设计若干个测试用例，运行被测程序，使得程序中<strong>每个判断的取真分支和取假分支至少经历一次</strong>。判定覆盖又称为<strong>分支覆盖</strong>。 </li></ul></li></ul><h4 id="3-条件覆盖（Condition-Coverage）"><a href="#3-条件覆盖（Condition-Coverage）" class="headerlink" title="3. 条件覆盖（Condition Coverage）"></a>3. 条件覆盖（Condition Coverage）</h4><ul><li><strong>概念</strong><ul><li>条件覆盖就是设计若干个测试用例，运行被测程序，使得程序中<strong>每个判断的每个条件的可能取值至少执行一次</strong>。 </li></ul></li><li><strong>关系</strong><ul><li>条件覆盖深入到判定中的每个条件，但可能不满足判定覆盖</li></ul></li></ul><h4 id="4-判定-条件覆盖"><a href="#4-判定-条件覆盖" class="headerlink" title="4. 判定/条件覆盖"></a>4. 判定/条件覆盖</h4><ul><li><strong>概念</strong><ul><li>判定-条件覆盖要求设计足够的测试用例，使得<strong>判定中每个条件的所有可能 （真/假）至少出现一次</strong>，并且<strong>每个判定本身的判定结果（真/假）也至少出现一次</strong>。</li></ul></li><li><strong>复合判定</strong>：改为单个条件判定</li></ul><h4 id="5-条件组合覆盖"><a href="#5-条件组合覆盖" class="headerlink" title="5. 条件组合覆盖"></a>5. 条件组合覆盖</h4><ul><li><p><strong>概念</strong></p><ul><li>条件组合覆盖就是设计足够的测试用例，运行被测程序，使得<strong>每个判断的所有可能的条件取值组合至少执行一次</strong>。 </li></ul></li><li><p><strong>关系</strong></p><ul><li>满足“条件组合覆盖”的测试用例是一定满足“判定覆盖”、“条件覆盖”和“判定-条件覆盖”的。 </li></ul></li><li><p><strong>示例</strong></p><p><img src="./02-02.png" alt="02-02"></p></li></ul><h3 id="路径法"><a href="#路径法" class="headerlink" title="路径法"></a>路径法</h3><h4 id="1-路径覆盖（Path-Coverage）"><a href="#1-路径覆盖（Path-Coverage）" class="headerlink" title="1. 路径覆盖（Path Coverage）"></a>1. 路径覆盖（Path Coverage）</h4><ul><li><strong>概念</strong><ul><li>路径测试就是设计足够的测试用例，<strong>覆盖程序中所有可能的路径</strong>。这是<strong>最强的覆盖准则</strong>。但在路径数目很大时，真正做到完全覆盖是很困难的，必须把覆盖路径数目压缩到一定限度。 </li><li>保证程序中每条可能的路径都至少执行一次，因此更具代表性，暴露错误的能力也比较强。 </li><li>但为了做到路径覆盖，只需考虑每个判定式的取值组合，并没有检验表达式中条件的各种可能组合。如果将路径覆盖和条件组合覆盖结合起来，可以设计出检错能力更强的测试数据。 </li><li><strong>路径表达式：</strong>$a(b+c)(d+e)f=abdf+abef+acdf+acef$</li></ul></li></ul><p>####2. 基本（独立）路径测试法</p><ul><li><strong>概念</strong><ul><li>独立路径：从入口到出口的路径，至少经历一个从未走过的边。这样形成的路径叫独立路径。</li></ul></li><li><strong>步骤</strong><ul><li>根据程序的逻辑结构画出<strong>程序框图</strong></li><li>根据程序框图导出<strong>流图</strong></li><li>计算流图<strong>G</strong>的<strong>环路复杂度$V(G)$</strong><ul><li><strong>流图的区域数量</strong>应该对应于环复杂度 </li><li>给定流图G的环复杂度定义为：$V(G)=E-N+2$<ul><li>E为流图中的边数量，N为流图中的节点数量 </li></ul></li><li>给定流图G的环复杂度也可以定义为：$V(G)=P+1$<ul><li>P为流图中的判断节点数量</li></ul></li></ul></li><li>确定只包含独立路径的基本路径集</li><li>设计测试用例</li></ul></li></ul><h2 id="数据流测试"><a href="#数据流测试" class="headerlink" title="数据流测试"></a>数据流测试</h2><ul><li><p><strong>含义</strong>：数据流测试使用控制流图来进行测试。</p><ul><li>能填补路径和分支测试的缝隙（span the gap between all paths and branch testing）</li></ul></li><li><p><strong>数据对象类别：</strong></p><ul><li><strong>（d）</strong>：Defined, Created, Initialized</li><li><strong>（k）</strong>：Killed, Undefined, Released</li><li><strong>（u）</strong>：Used<ul><li><strong>（c）</strong>：Used in a calculation</li><li><strong>（p）</strong>：Used in a predicate</li></ul></li></ul></li><li><p><strong>路径段</strong>（du Path Segments）</p><ul><li><p>Def-use Association: $(x , d, u)$</p><ul><li>x: 变量</li><li>d: 含有x定义的节点</li><li>u: 含有x使用的判断或语句</li><li>路径段中不存在其它x的定义</li></ul></li><li><p><strong>例子</strong></p><p><img src="./02-03.png" alt="02-03"></p></li></ul></li><li><p><strong>数据流测试策略：ADUP</strong>（All du Paths）</p><ul><li>找出测试所有的du paths路径</li></ul></li></ul><h2 id="终极示例"><a href="#终极示例" class="headerlink" title="终极示例"></a>终极示例</h2><ul><li>其实就是课程作业啦…</li></ul><h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><pre class=" language-python"><code class="language-python">scanf<span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">and</span> x<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>    pow <span class="token operator">=</span> <span class="token operator">-</span>y<span class="token punctuation">;</span><span class="token keyword">else</span>    pow <span class="token operator">=</span> y<span class="token punctuation">;</span>z <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>pow <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    z <span class="token operator">=</span> z <span class="token operator">*</span> x<span class="token punctuation">;</span>    pow <span class="token operator">=</span> pow <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">and</span> z<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>    z <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> z<span class="token punctuation">;</span>printf <span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>用判定条件覆盖法、基本路径法完成测试用例设计（要求画程序流程图和控制流图）</p><h3 id="【答案】"><a href="#【答案】" class="headerlink" title="【答案】"></a>【答案】</h3><ol><li><p>程序流程图</p><pre class=" language-flow"><code class="language-flow">st=>start: starte=>end: endstatement1=>operation: scanf("%d %d",&x, &y);cond1=>condition: if(y < 0 and x>0)statement2=>operation: pow = -y; statement3=>operation: pow = y;statement4=>operation: z = 1.0;cond2=>condition: pow != 0statement5=>operation: z = z*x; pow = pow-1;cond3=>condition:  if (y < 0 and z>0)statement6=>operation: z = 1.0/z;statement7=>operation: printf("%f",z);st->statement1->cond1cond1(yes)->statement2->statement4cond1(no)->statement3->statement4statement4->cond2cond2(yes)->statement5->cond2cond2(no)->cond3cond3(yes)->statement6->statement7cond3(no)->statement7->e</code></pre></li></ol><ol start="2"><li><p>控制流图</p><pre class=" language-mermaid"><code class="language-mermaid">graph LR    id1((start,a))-->id2((b))    id2--yes-->id3((c))    id2--no-->id4((d))    id3-->id5((e))    id4-->id5    id5-->id6((f))    id6--yes-->id7((g))    id7-->id6    id6--no-->id8((h))    id8--yes-->id9((i))    id9-->id10((j))    id8--no-->id10    id10-->id11(k,end)</code></pre></li><li><p>判定条件覆盖法</p><p>$T_1: y&lt;0;\ \ T_2: x&gt;0;\ \ T_3: pow\ !=0;\ \ T_4:y&lt;0;\ \ T_5:z&gt;0$</p><table><thead><tr><th>测试序号</th><th>测试情况</th><th>输入(x, y)</th><th>理想输出(z)</th></tr></thead><tbody><tr><td>1</td><td>$T_1T_2T_3\overline{T_3}T_4T_5$</td><td>(1, -1)</td><td>1.0</td></tr><tr><td>2</td><td>$\overline{T_1}\overline{T_2}T_3\overline{T_3}\overline{T_4}\overline{T_5}$</td><td>(-1, 1)</td><td>-1.0</td></tr></tbody></table></li><li><p>基本路径法</p><p>本因有四条基本路径，但由于判定1与判定3存在矛盾，所以无法找出四条基本路径的实际用例。</p><table><thead><tr><th>测试序号</th><th>测试路径</th><th>输入(x, y)</th><th>理想输出(z)</th></tr></thead><tbody><tr><td>1</td><td>abdefhjk</td><td>(1, 0)</td><td>1.0</td></tr><tr><td>2</td><td>abdefgfhjk</td><td>(-1, -1)</td><td>-1.0</td></tr><tr><td>3</td><td>abcefgfhijk</td><td>(1, -1)</td><td>1.0</td></tr><tr><td>4</td><td></td><td></td><td></td></tr></tbody></table></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> School </tag>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试与维护（五）Black Box Text</title>
      <link href="/software-test-maintance-05/"/>
      <url>/software-test-maintance-05/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试与维护（五）：Black-Box-Test"><a href="#软件测试与维护（五）：Black-Box-Test" class="headerlink" title="软件测试与维护（五）：Black Box Test"></a>软件测试与维护（五）：Black Box Test</h1><h2 id="动态黑盒测试（Black-Box-Test）"><a href="#动态黑盒测试（Black-Box-Test）" class="headerlink" title="动态黑盒测试（Black-Box Test）"></a>动态黑盒测试（Black-Box Test）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>不深入代码细节测试软件的方法称为<strong>动态黑盒测试</strong>。</li><li><strong>动态</strong>（dynamic）：程序在运行；<strong>黑盒</strong>（black-box）：不知道如何运行。</li><li>动态黑盒测试常被称为<strong>行为测试</strong>（behavioral testing），因为测试的是软件在使用过程中的实际行动。</li></ul><h2 id="测试用例设计技术"><a href="#测试用例设计技术" class="headerlink" title="测试用例设计技术"></a>测试用例设计技术</h2><h3 id="1-等价类划分法（Equivalence-Partitioning）"><a href="#1-等价类划分法（Equivalence-Partitioning）" class="headerlink" title="1. 等价类划分法（Equivalence Partitioning）"></a>1. 等价类划分法（Equivalence Partitioning）</h3><ul><li><p><strong>概念</strong>：把程序的输入域划分成若干部分，然后从每个部分中选取少数代表性数据当作测试用例。（可以减少测试用例的量）</p></li><li><p><strong>有效等价类</strong> &amp; <strong>无效等价类</strong></p><ul><li>有效等价类：指对于程序的规格说明来说是<strong>合理的、有意义的输入数据构成的集合</strong>。利用有效等价类可<strong>检验程序是否实现了规格说明中所规定的功能和非功能</strong>。 </li><li>无效等价类：与有效等价类的定义恰巧相反。 </li></ul></li><li><p>测试：<strong>完备性</strong>、<strong>无冗余性</strong></p></li><li><p><strong>确定等价类的原则：</strong></p><ul><li>在输入条件规定了取值范围或值的个数的情况下，则可以确立一个有效等价类和两个无效等价类。 </li><li>在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可以确立一个有效等价类和一个无效等价类。 </li><li>在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类。 </li><li>在规定了输入数据的一组值 ，并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类。</li><li>在规定了输入数据必须遵守的规则的情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）。 </li><li>如果确知，已划分的等价类中各个元素在程序中的处理方式不同，则应将此等价类进一步划分成更小的等价类。 </li></ul></li><li><p><strong>示例</strong></p><ul><li><p>等价类划分：</p><table><thead><tr><th>被测项</th><th>边长</th><th>等价类编号</th></tr></thead><tbody><tr><td>有效等价类</td><td>正数</td><td>1</td></tr><tr><td>无效等价类</td><td>小于0</td><td>2</td></tr></tbody></table></li><li><p>测试用例设计：</p><table><thead><tr><th>测试用例编号</th><th>输入值</th><th>覆盖的等价类编号</th><th>合理输出</th></tr></thead><tbody><tr><td>T1</td><td>2</td><td>(1)</td><td>正确</td></tr><tr><td>T2</td><td>0</td><td>(2)</td><td>错误</td></tr></tbody></table></li></ul></li></ul><h3 id="2-边界值分析法（VBA-Boundary-Value-Analysis）"><a href="#2-边界值分析法（VBA-Boundary-Value-Analysis）" class="headerlink" title="2. 边界值分析法（VBA, Boundary Value Analysis）"></a>2. 边界值分析法（VBA, Boundary Value Analysis）</h3><ul><li><strong>概念：</strong>对等价划分类的补充，不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。</li><li><strong>设计方法：</strong><ul><li>确定边界情况（输入或输出等价类的边界）</li><li>选取正好等于、刚刚大于或刚刚小于边界值作为测试数据 </li><li>一般情况，一个边界可以给出3个边界测试用例，<strong>自身+左右值</strong></li></ul></li></ul><h3 id="3-错误推测方法"><a href="#3-错误推测方法" class="headerlink" title="3. 错误推测方法"></a>3. 错误推测方法</h3><ul><li><strong>概念：</strong><ul><li>通过经验和直觉推测出程序的错误所在；</li><li>主观、灵感、反向思维，难以复制等等；</li><li>不是一个系统的方法，用作辅助手段。</li></ul></li></ul><h3 id="4-判定表驱动测试方法（Decision-Table）"><a href="#4-判定表驱动测试方法（Decision-Table）" class="headerlink" title="4. 判定表驱动测试方法（Decision Table）"></a>4. 判定表驱动测试方法（Decision Table）</h3><ul><li><p><strong>概念：</strong>是分析和表达多逻辑条件下执行不同操作的工具，也叫判定表。</p></li><li><p><strong>组成：</strong>条件桩（Condition Stub）、动作桩（Action Stub）、条件项、动作项、规则</p><table><thead><tr><th>条件桩</th><th>条件项</th></tr></thead><tbody><tr><td>动作桩</td><td>动作项</td></tr></tbody></table></li><li><p><strong>示例：</strong></p><ul><li><p>判定表：</p><p><img src="./01-01.png" alt="01-01"></p></li><li><p>测试用例：</p><p><img src="./01-02.png" alt="01-02"></p></li></ul></li></ul><h3 id="5-因果图法"><a href="#5-因果图法" class="headerlink" title="5. 因果图法"></a>5. 因果图法</h3><ul><li><p><strong>概念：</strong></p><ul><li>借助图的方式，设计测试用例，被测程序有多种输入条件，输出结果依赖于输入条件的组合; </li><li>着重分析输入条件的各种组合，每个条件就是一个“因”，这些“因”的组合必然有一个输出的结果，这就是“果”; </li><li>与其他的方法相比，更侧重于输入条件的组合 。</li></ul></li><li><p><strong>约束符号</strong></p><ul><li>E：互斥，不能同时出现</li><li>I：包含，至少一个出现</li><li>O：唯一，有且只有一个出现</li><li>R：要求，若a=1那么要求b必须是1，反之如果a=0，那么b无所谓</li><li>M：屏蔽，当a=1时，b=0，当a=0，b的值有可能是1，也有可能是0</li></ul></li><li><p><strong>示例：</strong></p><p><img src="./01-03.png" alt="01-03"></p></li><li><p><strong>步骤：</strong></p><ul><li>分析软件规格说明描述中, 哪些是原因（即输入条件或输入条件的等价类），哪些是结果（即输出条件），并给每个原因和结果赋予一个标识符。 </li><li>分析软件规格说明描述中的语义，找出原因与结果之间、原因与原因之间对应的关系。根据这些关系，画出因果图。 </li><li>把因果图转换为判定表。</li><li>把判定表的每一列拿出来作为依据,设计测试用例。 </li></ul></li></ul><h3 id="6-场景法"><a href="#6-场景法" class="headerlink" title="6. 场景法"></a>6. 场景法</h3><ul><li><p><strong>概念：</strong></p><ul><li>用例场景：用来描述流经用例的路径，从用例开始到结束遍历这条路径上所有基本流和备选流。</li><li><strong>基本流</strong>和<strong>备选流</strong></li><li><strong>场景</strong></li></ul></li><li><p>测试用例设计<strong>步骤</strong>与<strong>示例</strong></p><ul><li><p><strong>设计场景</strong>：通过用例的主事件流和备选事件流的组合给出不同的场景</p><table><thead><tr><th>场景</th><th>基本流&amp;备选流</th></tr></thead><tbody><tr><td>场景1</td><td>基本流</td></tr><tr><td>场景2</td><td>基本流 备选流1</td></tr><tr><td>场景3</td><td>基本流 备选流1 备选流2</td></tr><tr><td>场景4</td><td>基本流 备选流3</td></tr></tbody></table></li><li><p><strong>设计测试用例标准</strong>：覆盖场景</p><table><thead><tr><th>测试用例编号</th><th>覆盖的场景</th><th>PIN</th><th>账号</th><th>输入（选择）的金额</th><th>账面金额</th><th>ATM中的金额</th><th>预测结果</th></tr></thead><tbody><tr><td>1</td><td>场景1-成功提款</td><td>V</td><td>V</td><td>V</td><td>V</td><td>V</td><td>成功提款</td></tr><tr><td>2</td><td>场景2-ATM内无现金</td><td>V</td><td>V</td><td>V</td><td>V</td><td>I</td><td>提款选项不可用，用例结束</td></tr><tr><td>…</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>根据测试用例标准给出<strong>具体的测试数据</strong></p></li><li><table><thead><tr><th>测试用例编号</th><th>覆盖的场景</th><th>PIN</th><th>账号</th><th>输入（选择）的金额</th><th>账面金额</th><th>ATM中的金额</th><th>预测结果</th></tr></thead><tbody><tr><td>1</td><td>场景1-成功提款</td><td>1987</td><td>809-498</td><td>100</td><td>500</td><td>2000</td><td>成功提款</td></tr><tr><td>2</td><td>场景2-ATM内无现金</td><td>1987</td><td>809-398</td><td>100</td><td>500</td><td>0</td><td>提款选项不可用，用例结束</td></tr><tr><td>…</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></li></ul></li><li><p><strong>应用场景</strong></p><ul><li>一般用于<strong>功能测试</strong>，基本上所有的功能流程测试都会用到；</li><li>业务复杂时，针对关键业务场景进行业务的流程测试。</li></ul></li></ul><h2 id="黑盒测试策略总结"><a href="#黑盒测试策略总结" class="headerlink" title="黑盒测试策略总结"></a>黑盒测试策略总结</h2><ul><li>针对功能具体页面中具体的输入域进行细化测试，采用等价类、边界值；</li><li>用静态检查法检查按钮、链接、内容、图片等；</li><li>针对每个功能的流程，采用场景法，进行该功能（用例）的全方位流程测试；</li><li>如果是多个条件的组合可以采用判定表或因果图法；</li><li>在任何情况下都必须使用边界值分析方法；</li><li>用错误推测法再追加一些测试用例。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> School </tag>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试与维护（四）Test Cases</title>
      <link href="/software-test-maintance-04/"/>
      <url>/software-test-maintance-04/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试与维护（四）：Test-Cases"><a href="#软件测试与维护（四）：Test-Cases" class="headerlink" title="软件测试与维护（四）：Test Cases"></a>软件测试与维护（四）：Test Cases</h1><h2 id="测试系统"><a href="#测试系统" class="headerlink" title="测试系统"></a>测试系统</h2><ul><li><strong>架构 Architecture</strong><ul><li>测试套件 Test Suite：与需求相关的一系列测试</li><li>测试 Test：针对单个功能或需求的一个或多个测试用例</li><li>测试用例 Test Case：最小的测试单元</li></ul></li></ul><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><ul><li><strong>定义</strong><ul><li>满足特定目的的<strong>测试数据、测试代码、测试规程的集合</strong></li><li>是发现软件缺陷的<strong>最小测试执行单元</strong></li><li>有<strong>特殊的书写标准和基本原则</strong></li></ul></li><li>书写格式：<ul><li>标志符、测试项、测试环境（环境要求，实际测试环境）、输入（输入标准，实际输入）、输出（输出标准，实际输出）、测试用例间的关联</li></ul></li><li><strong>测试用例生成的基本准则</strong><ul><li>代表性、可判断性、可再现性</li></ul></li><li><strong>测试用例设计步骤</strong><ul><li>为测试需求确定测试用例</li><li>为测试用例确定输入输出</li><li>编写测试用例</li><li>评审测试用例</li><li>跟踪测试用例</li></ul></li><li><strong>测试用例的作用</strong><ul><li>避免盲目测试；</li><li>估算测试工作量；</li><li>减少回归测试的复杂程度；</li><li>方便地书写软件测试缺陷报告；</li><li>实施不同级别的测试。</li><li>总结：软件测试是有组织性、步骤性和计划性的，为了能将软件测试的行为转换为可管理的、具体量化的模式，需要创建和维护测试用例。</li></ul></li><li><strong>测试用例工具：</strong> TestDirector, Testlink</li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> School </tag>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试与维护（三）Test Planning</title>
      <link href="/software-test-maintance-03/"/>
      <url>/software-test-maintance-03/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试与维护（三）：Test-Planning"><a href="#软件测试与维护（三）：Test-Planning" class="headerlink" title="软件测试与维护（三）：Test Planning"></a>软件测试与维护（三）：Test Planning</h1><h2 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h2><ul><li><strong>概念：</strong>测试策略通常是描述<strong>测试工程</strong>的<strong>总体方法和目标</strong>。描述目前在进行哪一阶段的测试（如单元测试、集成测试、系统测试）以及<strong>每个阶段内进行的测试种类</strong>（如功能测试、性能测试、压力测试等）和方法，以确定合理的测试方案使测试更有效</li></ul><h2 id="测试计划"><a href="#测试计划" class="headerlink" title="测试计划"></a>测试计划</h2><ul><li><strong>16个组件</strong><ul><li>测试计划标识 Test Plan Idertifier</li><li>引言 Instruction</li><li>定义或主题词 Test Items</li><li>需要被测试的特性 Features to be tested</li><li>无需被测试的特性 Features not to be tested</li><li>方法和途径 Approach</li><li>测试通过/失败的标准 Items Pass / fail criteria </li><li>暂停和再启动的标准 Suspension criteria and resumption requirements</li><li>测试交付的内容 Test Deliverables</li><li>测试任务 Testing Tasks</li><li>必备的环境 Environmental need </li><li>职责 Responsibilities</li><li>人员和必须的培训 Staffing and training needs</li><li>时间进度表 Schedule</li><li>风险和相关费用 Risk and Contingencies</li><li>批准 Approvals</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> School </tag>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试与维护（二）Test Realities</title>
      <link href="/software-test-maintance-02/"/>
      <url>/software-test-maintance-02/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试与维护（二）：Test-Realities"><a href="#软件测试与维护（二）：Test-Realities" class="headerlink" title="软件测试与维护（二）：Test Realities"></a>软件测试与维护（二）：Test Realities</h1><h2 id="组建测试团队"><a href="#组建测试团队" class="headerlink" title="组建测试团队"></a>组建测试团队</h2><ul><li><strong>测试团队的任务与责任</strong><ul><li>基本任务：测试计划、测试用例设计、执行测试、评估测试结果、递交测试报告</li><li>尽早地发现问题，发现软件程序、文档、系统或产品中所有的问题，督促相关人员尽快地解决产品中的缺陷；</li><li>对问题进行分析、分类总结和跟踪；</li><li>帮助项目管理人员制定合理的开发计划；</li><li>帮助改善开发流程、提高产品开发效率；</li><li>提高程序、文档编写的规范性、易读性、可维护性等</li></ul></li><li><strong>测试团队的基本构成</strong><ul><li>测试组长</li><li>测试配置人员</li><li>测试设计人员/资深测试工程师</li><li>一般（初级）测试工程师</li></ul></li><li><strong>以项目经理为核心的组织模型</strong><ul><li>项目经理–测试经理、开发经历、文档人员</li></ul></li><li><strong>优秀软件测试工程师的必备素质</strong><ul><li>沟通能力、技术能力、信心、外交能力和幽默感、耐心、很强的记忆力、怀疑精神、洞察力、适度的好奇心、反向思维和发散思维能力</li></ul></li></ul><h2 id="测试的原则"><a href="#测试的原则" class="headerlink" title="测试的原则"></a>测试的原则</h2><ul><li><strong>完全测试是不可能的</strong><ul><li>原因：输入量太大、输出结果太多、软件执行路径太多、软件说明书是主观的</li></ul></li><li><strong>软件测试是有风险的行为</strong><ul><li>找出最优的测试量，使测试不多不少</li></ul></li><li><strong>测试无法显示潜伏的软件缺陷</strong> cannot show the absence of bugs</li><li><strong>找到的软件缺陷越多，就说明软件缺陷越多</strong><ul><li>程序员也有心情不好的时候</li><li>程序员往往会犯同样的错误</li><li>某些软件缺陷是冰山一角</li></ul></li><li><strong>杀虫剂怪事：软件测试越多，其对测试的免疫力越强</strong></li><li><strong>并非所有软件缺陷都要修复</strong><ul><li>没有足够的时间</li><li>不算真正的软件缺陷</li><li>修复的风险太大</li><li>不值得修复</li></ul></li><li><strong>什么时候才叫缺陷难以说清</strong></li><li><strong>产品说明书从没有最终版本</strong></li><li><strong>软件测试员在产品小组中不受欢迎</strong><ul><li>早点找出缺陷</li><li>控制情绪</li><li>不要总是报告坏消息</li></ul></li><li><strong>软件测试是一项讲究条理的技术专业</strong> disciplined</li><li><strong>补充原则</strong><ul><li>“质量第一”</li><li>质量标准</li><li>第三方测试会更客观，更有效</li><li>重视文档</li></ul></li></ul><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>对软件产品进行充分测试，尽早找出其中的缺陷(Bug),并督促相关人员进行解决。</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>软件测试分类</li></ul><p><img src="./02-01.png" alt="02-01 软件测试分类"></p><ul><li>单元、集成、系统、验收测试</li></ul><table><thead><tr><th>测试类型</th><th>对象</th><th>目的</th><th>依据</th><th>方法</th></tr></thead><tbody><tr><td>单元测试</td><td>模块内部程序错误</td><td>消除局部模块的逻辑和功能上的错误和缺陷</td><td>详细设计</td><td>白盒为主，黑盒为辅</td></tr><tr><td>集成测试</td><td>模块间的集成和调用关系</td><td>找出与软件设计相关的程序结构，模块调用关系，模块间借口方面的问题</td><td>概要设计</td><td>白盒与黑盒结合</td></tr><tr><td>系统测试</td><td>整个系统中的软硬件</td><td>对整个系统进行一系列的整体、有效性测试</td><td>需求规格说明书、概要设计</td><td>黑盒</td></tr><tr><td>验收测试</td><td>用户实际环境</td><td>对整个系统进行整体有效测试</td><td>需求规格说明书</td><td>黑盒</td></tr></tbody></table><h3 id="测试与调试"><a href="#测试与调试" class="headerlink" title="测试与调试"></a>测试与调试</h3><ul><li>测试发展的初期，测试就是调试，而现在测试是一个<strong>系统化工程化</strong>的概念，有自己的生命周 期，<strong>调试的范畴更小一些</strong>。</li><li>调试不属于测试，是<strong>编码阶段的工作</strong>，由程序员完成;而测试由测试员或程序员完成</li><li>测试是为了<strong>找出软件中存在的缺陷，并督促相关人员解决</strong>，为了提升软件质量; 而调试是 为了<strong>解决存在的缺陷</strong>。</li><li>成功的测试发现了错误的症状，从而引起调试的进行。</li></ul><h3 id="测试管理体系"><a href="#测试管理体系" class="headerlink" title="测试管理体系"></a>测试管理体系</h3><ul><li>测试计划、测试设计、测试实施、测试评估</li></ul><h2 id="相关术语-Some-Terminology"><a href="#相关术语-Some-Terminology" class="headerlink" title="相关术语 Some Terminology"></a>相关术语 Some Terminology</h2><h3 id="精度（precision）和准确（accuracy）"><a href="#精度（precision）和准确（accuracy）" class="headerlink" title="精度（precision）和准确（accuracy）"></a>精度（precision）和准确（accuracy）</h3><ul><li><strong>精度</strong>：聚焦；<strong>准度</strong>：对准</li></ul><h3 id="确认（certification）和验证（validation）"><a href="#确认（certification）和验证（validation）" class="headerlink" title="确认（certification）和验证（validation）"></a>确认（certification）和验证（validation）</h3><ul><li>确认：是否正确地创建了产品</li><li>验证：是否创建了正确的产品</li></ul><h3 id="质量（quality）和可靠性"><a href="#质量（quality）和可靠性" class="headerlink" title="质量（quality）和可靠性"></a>质量（quality）和可靠性</h3><ul><li>可靠性，稳定，只是质量的一部分</li></ul><h3 id="测试和质量保证（Software-Quality-Assurance）"><a href="#测试和质量保证（Software-Quality-Assurance）" class="headerlink" title="测试和质量保证（Software Quality Assurance）"></a>测试和质量保证（Software Quality Assurance）</h3><ul><li><strong>SQA：</strong>软件质量保证是通过对软件<strong>产品和活动</strong>有<strong>计划</strong>地进行<strong>评审和审计</strong>来验证软件是否合乎<strong>标准的系统工程活动</strong>。</li><li><strong>SQA与软件测试的关系</strong><ul><li>SQA是管理工作，审查对象是流程，强调以预防为主；测试是技术实施工作，测试对象是产品，主要以事后检查（文档、程序）为主。</li><li>SQA指导测试、监控测试；测试为SQA提供依据，测试是SQA的一个环节、一个手段。</li><li>软件测试员的目标是尽可能早地找出软件缺陷，并确保缺陷得以修复；软件质量保证人员的主要职责是创建和执行改进软件开发过程并防止软件缺陷发生的标准和方法。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> School </tag>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试与维护（一）Introduction</title>
      <link href="/software-test-maintance-01/"/>
      <url>/software-test-maintance-01/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试与维护（一）：Introduction"><a href="#软件测试与维护（一）：Introduction" class="headerlink" title="软件测试与维护（一）：Introduction"></a>软件测试与维护（一）：Introduction</h1><h2 id="测试概念"><a href="#测试概念" class="headerlink" title="测试概念"></a>测试概念</h2><h3 id="Bug-缺陷"><a href="#Bug-缺陷" class="headerlink" title="Bug 缺陷"></a>Bug 缺陷</h3><ul><li><strong>别名：</strong>缺点（defect）、偏差（variance）、故障（fault）、失败（failure）、问题（problem）、矛盾（inconsistency）、错误（error）、特殊（feature）、事件（incident）、缺陷（bug）、异常（anomaly）</li><li><strong>问题的来源：</strong><ul><li>需求定义 Requirements Definition</li><li>设计 Design</li><li>实现 Implementation</li><li>支持系统 Support Systems</li><li>缺少测试 Inadequate  Testing of Software</li><li>进化 Evolution</li></ul></li><li><strong>软件缺陷存在</strong>当以下至少一项规则发生之时：<ul><li>软件未实现产品说明书（specification）要求的功能；</li><li>软件出现了产品说明书指明不应该出现的错误；</li><li>软件实现了产品说明书未提到的功能；</li><li>软件未实现产品说明书虽未明确提及但应该实现的目标；</li><li>软件难以理解、不易使用、运行缓慢或者–从测试员的角度看–最终用户会认为不好。</li></ul></li><li><strong>软件缺陷的分布：</strong><ul><li>说明书 Specification 55%</li><li>设计 Design 25%</li><li>编码 Code 15%</li><li>其他 Other 5%</li></ul></li></ul><h3 id="Software-Testing-软件测试"><a href="#Software-Testing-软件测试" class="headerlink" title="Software Testing 软件测试"></a>Software Testing 软件测试</h3><ul><li>软件测试员的目标是发现软件缺陷（to find bugs）</li><li>软件测试员的目标是尽可能早地找出软件缺陷（as early in the software development process as possible）</li><li>软件测试员的目标是尽可能地找出软件缺陷，并确保其得以修复（make sure they are fixed）</li></ul><h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><h3 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h3><p><img src="./01-01.png" alt="01-01 V模型"></p><h3 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h3><p><img src="./01-02.png" alt="01-02 W模型"></p><ul><li>解决了V模型的部分问题：未将测试流程的完整性表示出来。</li></ul><h3 id="H模型"><a href="#H模型" class="headerlink" title="H模型"></a>H模型</h3><p><img src="./01-03.png" alt="01-03 H模型"></p><ul><li><strong>测试流程</strong><ul><li>测试准备活动：测试计划、测试设计、测试开发</li><li>测试执行活动：测试运行、测试评估</li></ul></li><li><strong>应用</strong><ul><li>测试不仅仅是测试执行，还包括其他活动。</li><li>测试是一个独立流程，贯穿产品整个周期，与其他流程并行进行。</li><li>测试要尽早准备，尽早执行。</li></ul></li></ul><h3 id="其他模型"><a href="#其他模型" class="headerlink" title="其他模型"></a>其他模型</h3><ul><li><strong>X模型</strong></li></ul><p><img src="./01-04.png" alt="01-04 X模型"></p><ul><li><strong>V 模型（进一步丰富）</strong></li></ul><p><img src="./01-05.png" alt="01-05 V模型（进一步丰富）"></p>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> School </tag>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020论文阅读笔记&lt;02&gt;</title>
      <link href="/article-2020-02/"/>
      <url>/article-2020-02/</url>
      
        <content type="html"><![CDATA[<h1 id="2020论文阅读笔记-lt-02-gt"><a href="#2020论文阅读笔记-lt-02-gt" class="headerlink" title="2020论文阅读笔记 &lt;02&gt;"></a>2020论文阅读笔记 &lt;02&gt;</h1><h2 id="【基本信息】"><a href="#【基本信息】" class="headerlink" title="【基本信息】"></a>【基本信息】</h2><ul><li><strong>论文题目：</strong><a href="https://www.researchgate.net/publication/334115921_A_Graph-theoretic_Summary_Evaluation_for_ROUGE" target="_blank" rel="noopener">A Graph-theoretic Summary Evaluation for ROUGE</a></li><li><strong>作者：</strong>Elaheh ShafieiBavani, Mohammad Ebrahimi, Raymond Wong, Fang Chen</li><li><strong>日期：</strong>Jan 2018</li><li><strong>标签：</strong>NLG</li><li><strong>简介：</strong>由于ROUGE仅仅依赖于生成文本（peer）和参考文本（model）之间的表面相似度，而忽略了词汇的变化和释义，所以无法正确地评估摘要。本文使用了一种基于图的方法（sense-based represtation，PPR向量，Path-based and Rank and Weight measure）修改ROUGE，基于词汇和语义相似性，提高评估效果。并使用显著性评估来表明，改进后的指标ROUGE-G与手工判断的相关性更高。</li></ul><h2 id="【论文概要】"><a href="#【论文概要】" class="headerlink" title="【论文概要】"></a>【论文概要】</h2><h3 id="1-研究问题"><a href="#1-研究问题" class="headerlink" title="1. 研究问题"></a>1. 研究问题</h3><p>a. 当前ROUGE对摘要评估存在的问题？（忽略了词汇的语义相关性）</p><p>b. 如何修改ROUGE，增加对词汇相关性的考量。（基于图的方法，PPR向量、基于路径、增加权重、消除歧义等）</p><p>c. 在增加相关性的时候，如何提高效率。（剪裁）</p><p>c. 如何评估新指标ROUGE-G与原指标的“好坏”。（显著性评估，Pearson、Sperman、Kendall）</p><h3 id="2-ROUGE与其存在的问题"><a href="#2-ROUGE与其存在的问题" class="headerlink" title="2. ROUGE与其存在的问题"></a>2. ROUGE与其存在的问题</h3><ul><li>ROUGE （Recall-Oriented Understanding for Gisting Evaluation)<ul><li>最早且应用最广泛的文本摘要评价指标之一。</li><li>$ROUGE-N=\frac{\sum_{S\in {Ref\ Summaries}}\sum_{n-gram\in S}Count_{match}(n-gram)}{\sum_{S\in {Ref\ Summaries}}\sum_{n-gram\in S}Count(n-gram)}$</li></ul></li><li>存在的问题<ul><li>问题：忽略了词汇相关性的考量</li><li>示例：<ul><li>The strolled around the city.</li><li>They took a walk to explore the town.</li><li>两句话的语义含义相同，但用词不同，如果只有一个在参考中则另一个评分低。</li></ul></li></ul></li></ul><h3 id="3-ROUGE-G-解决方案"><a href="#3-ROUGE-G-解决方案" class="headerlink" title="3. ROUGE-G 解决方案"></a>3. ROUGE-G 解决方案</h3><h4 id="a-PPR向量表示"><a href="#a-PPR向量表示" class="headerlink" title="a. PPR向量表示"></a>a. PPR向量表示</h4><ul><li><strong>WordNet图：</strong>忽略各种边的类型，但增加不同词性（Part-of-Speech POS）的考虑，用连接点的个数来表示维数。</li><li>S位置的PPR向量：<ul><li>$p^{(k)}(S)=dAp^{(k-1)}(S)+(1-d)p^{(0)}(S)$</li><li>随机漫步（random walker）：d的概率跳到下一节点，1-d的概率返回出发点。</li><li>A：邻接矩阵，跳动</li></ul></li></ul><h4 id="b-向量的语义相似度"><a href="#b-向量的语义相似度" class="headerlink" title="b. 向量的语义相似度"></a>b. 向量的语义相似度</h4><ul><li><p>比较存在的问题：随机漫步特定顶点的特定迭代次数，可能产生假相似</p><ul><li>例子：law-suit-tailor-dress中，law 和dress是假相似</li><li>增加到一个特定点的路径长度考量</li></ul></li><li><p>每次迭代x中，排序维度（dimensions, senses）</p><ul><li>$Sim_{sem}(I,J)=\sum^{k}_{x=0}c^x\times RW(p^{(x)}(I),p^{(x)}(J))$</li></ul></li><li><p>加权之间的重叠</p><ul><li><p>$$<br>\begin{equation}<br>RW(Y,Z)=\left{<br>\begin{aligned}<br>&amp;\frac{\sum_{h\in H}(r_h(Y)+r_h(Z))^{-1}}{\sum_{i=1}^{|H|}(2i)^{-1}},\ &amp;if\ |H|&gt;0\<br>&amp;0,\ &amp;otherwise<br>\end{aligned}<br>\right.<br>\end{equation}<br>$$</p></li></ul></li></ul><h4 id="c-ROUGE-G计算"><a href="#c-ROUGE-G计算" class="headerlink" title="c. ROUGE-G计算"></a>c. ROUGE-G计算</h4><ul><li><p>ROUGE-G 综合词汇和语义相似性计算：</p><ul><li>$ROUGE-G-N=\frac{\sum_{M\in{ModelSums}}\sum_{n-gram_m\in M,\n-gram_p\in PeerSum}Sim_{LS}(n-gram_m,n-gram_p)}{\sum_{M\in {ModelSums}}\sum_{n-gram_m\in M}Count(n-gram_m)}$</li></ul></li><li><p>$Sim_{LS}$：模型摘要和文本摘要</p><ul><li>$$<br>\begin{aligned}<br>Sim_{LS}(n-gram_m,n-gram_p)=<br>&amp;\beta\times Count_{match}(n-gram_m,n-gram_p)\<br>&amp;+(1-\beta)\times Sim_{sem}(n-gram_m,n-gram_p)<br>\end{aligned}<br>$$</li></ul></li></ul><h4 id="d-上下文信息的缺失处理"><a href="#d-上下文信息的缺失处理" class="headerlink" title="d. 上下文信息的缺失处理"></a>d. 上下文信息的缺失处理</h4><ul><li>使用语义对齐（semantic alignment）最大化比较词的相似性。</li><li>例：<ul><li>句$P_{a1}.officer^3_n,fire^4_v$</li><li>句$P_{a2}.policeman^1_n,terminate^4_v,corruption^6_n,probe^1_n$</li><li>$t^i_p$表示：WordNet中的p词性的词汇t的第i维感官</li><li>会有结果：$Sim_{sem}(fire^4_v,terminate^4_v)=1$</li></ul></li></ul><h4 id="e-OOV处理"><a href="#e-OOV处理" class="headerlink" title="e. OOV处理"></a>e. OOV处理</h4><ul><li>OOV：词汇资源中没有定义的单词</li><li>在PPR中增加一个额外的变量。</li></ul><h3 id="4-实验验证方法"><a href="#4-实验验证方法" class="headerlink" title="4. 实验验证方法"></a>4. 实验验证方法</h3><ul><li>显著性检验（significance tests）<ul><li>由于在与人类的竞争关系中存在的大/小的差异并不能作为一种度量优于另一种度量的证明，因此应采用显著性检验。</li><li>采用Graham提出的两两配对Williams显著性检验</li><li>先对ROUGE进行重新采样</li></ul></li><li>三个指标分析：Person、Spearman、Kendall</li></ul><h2 id="【收获小节】"><a href="#【收获小节】" class="headerlink" title="【收获小节】"></a>【收获小节】</h2><ol><li>文章的大致思路清楚了，但对于语义对齐、WordNet和显著性检验的具体操作方法可能还需要再多了解一点（目前知道其作用和意思，但具体实现还是有一些疑惑）。</li><li>对于实验指标的好坏比较，与人工评估的对比，直接的大小差异不能作为直接的证明，可以使用显著性检验。</li><li>语义相似度、词汇的缺失等内容也可以加入考虑之中。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Article </tag>
            
            <tag> NLG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020论文阅读笔记&lt;01&gt;</title>
      <link href="/article-2020-01/"/>
      <url>/article-2020-01/</url>
      
        <content type="html"><![CDATA[<h1 id="2020论文阅读笔记-lt-01-gt"><a href="#2020论文阅读笔记-lt-01-gt" class="headerlink" title="2020论文阅读笔记 &lt;01&gt;"></a>2020论文阅读笔记 &lt;01&gt;</h1><h2 id="【基本信息】"><a href="#【基本信息】" class="headerlink" title="【基本信息】"></a>【基本信息】</h2><ul><li><strong>论文题目：</strong><a href="https://www.researchgate.net/publication/327336071_Towards_a_Better_Metric_for_Evaluating_Question_Generation_Systems" target="_blank" rel="noopener">Towards a Better Metric for Evaluating Question Generation Systems</a></li><li><strong>作者：</strong>Preksha Nema, Mitesh M. Khapra</li><li><strong>日期：</strong>August 2018</li><li><strong>标签：</strong>AQG、NLG</li><li><strong>简介：</strong>本文分析了传统NLG评价指标（BLEU、METEOR、NIST、ROUGE）在AQG问题上的效果，通过在噪声问题上与人工评分的比较，指出这些传统指标无法准确、有效地反映生成问题的好坏。本文的作者用可回答性（answerability）来反映一个生成的问题的优劣，并提出了利用不同词性（关联内容词、命名实体、问题类型、功能词）加权与传统指标相结合的新指标，使得新指标更加接近人工结果。</li></ul><h2 id="【论文概要】"><a href="#【论文概要】" class="headerlink" title="【论文概要】"></a>【论文概要】</h2><h3 id="1-研究问题"><a href="#1-研究问题" class="headerlink" title="1. 研究问题"></a>1. 研究问题</h3><p>a. 传统的自然语言生成（NLG）指标在自动问题生成（AQG）方面是否仍然有效？</p><p>b. 如何来衡量或分析这些指标的有效性或好坏？</p><p>c. 如何创造一个更符合AQG问题需要的新的指标？</p><h3 id="2-传统的指标"><a href="#2-传统的指标" class="headerlink" title="2. 传统的指标"></a>2. 传统的指标</h3><h4 id="a-BLEU"><a href="#a-BLEU" class="headerlink" title="a. BLEU"></a>a. BLEU</h4><ul><li>一种基于精度（precision）的评估指标。</li><li>考虑n-gram的形式：$p_n=\frac{\sum_{c\in candidates}\sum_{n-gram\in c}Count_{clip}(n-gram)}{\sum_{c’\in candidates}\sum_{n-gram’\in c’}Count_{clip}(n-gram’)}$</li><li>举例：<ul><li><strong>candidate:</strong> the cat sat on the mat</li><li><strong>reference:</strong> the cat is on the mat</li><li>$p_1=\frac{5}{6}$, $p_2=\frac{3}{5}$, $p_3=\frac{1}{4}$, $p_4=\frac{0}{3}$</li></ul></li></ul><h4 id="b-METEOR"><a href="#b-METEOR" class="headerlink" title="b. METEOR"></a>b. METEOR</h4><ul><li><p>考虑了精度和召回率（recall），也考虑词性、同义词等问题，也能给以功能词和内容词的权重。</p></li><li><p>是基于单精度的加权调和平均数和单子召回率的调和平均。</p></li><li><p>$$<br>惩罚系数\ Pen=\gamma(\frac{ch}{m})^\theta \<br>F_{mean}=\frac{P_mR_m}{\alpha P_m+(1-\alpha)R_m} \<br>P_m=\frac{|m|}{\sum_kh_k(c_i)} \<br>R_m=\frac{|m|}{\sum_kh_k(s_{ij})} \<br>METEOR=(1-Pen)F_{mean}<br>$$</p></li></ul><h4 id="c-NIST"><a href="#c-NIST" class="headerlink" title="c. NIST"></a>c. NIST</h4><ul><li>是标准BLEU的一个变体。</li><li>给在语料库中低频的词增高权重。</li></ul><h4 id="d-ROUGE"><a href="#d-ROUGE" class="headerlink" title="d. ROUGE"></a>d. ROUGE</h4><ul><li>自动摘要方面的指标，通过统计翻译的摘要与人工生成的标准摘要的重叠基本单元（n元语法、词序列和词对）的数目，来评价摘要的质量。</li></ul><h3 id="3-评价指标好坏的方法"><a href="#3-评价指标好坏的方法" class="headerlink" title="3. 评价指标好坏的方法"></a>3. 评价指标好坏的方法</h3><ul><li>从已有的三个主流问题生成数据库中选出数据：<ul><li>SQuAD：阅读理解数据库（约500文章，100k的问题）</li><li>WikiMovies：电影知识图谱（约43k实体，9种关系，100k的问题）</li><li>VQA：图片问题数据库（265,016图片，平均每张图5.4个问题）</li></ul></li><li>对问题随机进行四类噪声处理：<ul><li>删除功能词（如be, do, can, shall, will, have, let, make等词）</li><li>删除命名实体</li><li>删除内容词（如killed/married）</li><li>更改提问类型（who, what, which, how, why, when, where, 7-Wh）</li></ul></li><li>人工对这些噪声处理后的问题进行评价，分为五类<ul><li>重要信息缺失，不可能回答</li><li>大部分重要信息缺失，无法回答</li><li>一些重要信息缺失，答案不确定</li><li>大部分重要信息保留，可以推导回答</li><li>全部重要信息保留，完全可以回答</li></ul></li><li>通过指标的数据结果和人工结果的比较，来评价指标的合理性、有效性。</li></ul><h3 id="4-新的指标"><a href="#4-新的指标" class="headerlink" title="4. 新的指标"></a>4. 新的指标</h3><ul><li>将词汇分为四类：<ul><li>关联内容词（relevant content words）</li><li>命名实体（named entities）</li><li>问题类型（question types）</li><li>功能词（function words）</li></ul></li><li>计算四类词的加权精度和召回率<ul><li>$P_{avg}=\sum_iw_i\frac{c(S_i)}{|l_i|}$</li><li>$R_{avg}=\sum_iw_i\frac{S_i}{|r_i|}$</li></ul></li><li>调和平均计算可回答性（answerability）<ul><li>$Answerability=2\frac{P_{avg}R_{avg}}{P_{avg}+R_{avg}}$</li></ul></li><li>与现有指标进行加权<ul><li>$Q-BLEU4=\delta Answerability+(1-\delta)BLEU4$</li></ul></li></ul><h3 id="5-结果结论"><a href="#5-结果结论" class="headerlink" title="5. 结果结论"></a>5. 结果结论</h3><ul><li>新的指标更为接近人工评分。</li><li>对于不同的数据集，权重效果不同。</li><li>仍有很大的空间。</li></ul><h2 id="【收获小结】"><a href="#【收获小结】" class="headerlink" title="【收获小结】"></a>【收获小结】</h2><ol><li>本文虽然针对问题生成问题，但主要是分析评价指标，不涉及生成方法，所以读起来还是蛮轻松、开心的，嘿嘿。</li><li>问题生成问题和传统的翻译之类的文本生成问题有很大的不同，传统指标的不适用是显然的，但本文团队通过人工评分的对比来评价传统指标，并能从数据的分析中发现问题，提出一种可行的新的指标思路，这是很可取的一种方法。</li><li>此文似乎没能解决一个问题：现在的可回答性是基于人工就问题本身的分析，而到底能否从原文（知识图谱或图片）中得出答案，还是这个问题虽然合理但无法从原材料中找出答案（或者说问题与原材料的相关性）似乎目前模型仍是未能解决的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Article </tag>
            
            <tag> QG </tag>
            
            <tag> NLG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020论文阅读列表</title>
      <link href="/article-2020-00/"/>
      <url>/article-2020-00/</url>
      
        <content type="html"><![CDATA[<h1 id="2020论文阅读列表"><a href="#2020论文阅读列表" class="headerlink" title="2020论文阅读列表"></a>2020论文阅读列表</h1><p>​    2019年后半由于其他事物的忙碌，所以没有怎么看论文，所以重新开始了，从2019年12月8日进入新的部分了。</p><ol><li>Towards a Better Metric for Evaluating Question Generation Systems</li><li>A Graph-theoretic Summary Evaluation for ROUGE</li></ol>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Article </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data方法篇（一）决策树</title>
      <link href="/data-model-01/"/>
      <url>/data-model-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Data方法篇（一）决策树"><a href="#Data方法篇（一）决策树" class="headerlink" title="Data方法篇（一）决策树"></a>Data方法篇（一）决策树</h1><ul><li>对应《数据挖掘导论（完整版）》第4章、《机器学习》第4章、《统计学习方法》第5章。</li></ul><h2 id="1-决策树模型"><a href="#1-决策树模型" class="headerlink" title="1. 决策树模型"></a>1. 决策树模型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><strong>决策树</strong>（Decision Tree）是一种基本的分类与回归方法。<ul><li>可以认为是if-then规则的集合、定义在特征空间与类空间与类空间上的条件概率分布。</li></ul></li><li><strong>主要优点：</strong>模型具有可读性，分类速度快。</li><li>学习时，利用训练数据，根据<strong>损失函数最小化</strong>的原则建立决策树模型。</li></ul><h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p><img src="./01-01.png" alt="01-01 决策树示意图"></p><ul><li><strong>「元素」</strong><ul><li><strong>叶结点（left node）或终结点（terminal node）：</strong>决策结果</li><li><strong>内部结点（internal node）或非终止结点（non-terminal node）：</strong>属性测试条件</li></ul></li></ul><h3 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h3><ul><li><p><strong>本质</strong>：是<strong>从训练数据集中归纳出一组分类规则</strong>。</p></li><li><p>决策树学习使用<strong>损失函数</strong>，通常是正则化的极大似然函数，决策树学习的策略是<strong>以损失函数为目标函数的最小化</strong>。</p></li><li><p><strong>三个关键步骤：</strong> <strong>特征选择</strong>（划分选择）、<strong>决策树的生成</strong>和<strong>决策树的修剪</strong>。</p><ul><li>决策树的生成对应于模型的<strong>局部</strong>选择，决策树的剪枝对应于模型的<strong>全局</strong>选择。</li><li>特征选择是在决策树的生成过程之中使用，而修剪是可以在生成前后都可以进行的。</li></ul></li><li><p><strong>常用的算法：</strong>ID3、C4.5与CART</p></li></ul><h2 id="2-特征选择"><a href="#2-特征选择" class="headerlink" title="2. 特征选择"></a>2. 特征选择</h2><ul><li><strong>特征选择</strong>（划分选择）是决策树学习的关键，即如何选择最优划分属性。特征选择在于选取对训练数据具有分类能力的特征，即提高结点的<strong>纯度</strong>（purtiy）。</li><li>以下是用于特征选择常用的几种指标：<strong>信息增益</strong>、<strong>信息增益比</strong>、<strong>基尼指数</strong></li></ul><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><ul><li><strong>信息熵</strong>（information entropy）：度量样本集合纯度最常用的一种指标。<ul><li>样本集合$D$中第k类样本所占的比例为$p_k(k=1,2,..,|y|)$，则D的信息熵定义为：<ul><li>$Ent(D)=-\sum^{|y|}_{k=1}p_k\log_2p_k$</li></ul></li><li>$Ent(D)$的值越小，则$D$的纯度越高</li></ul></li><li><strong>信息增益</strong>（information gain）<ul><li>属性a对样本集D进行划分所获的”信息增益“<ul><li>$Gain(D,a)=Ent(D)-\sum^V_{v=1}\frac{|D^v|}{|D|}Ent(D^v)$</li></ul></li><li>一般而言，信息增益越大，则意味着使用属性a来进行划分所获得的“纯度提升”越大。</li><li><strong>存在的问题：</strong>偏向于选择取值较多的特征的问题。</li></ul></li></ul><h3 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h3><ul><li><strong>信息增益比</strong>（增益率，information gain ratio）<ul><li>$Gain_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}$</li><li><strong>固有值</strong>（intrinsic value）：$IV(a)=-\sum^V_{v=1}\frac{|D|^v}{|D|}\log_2(\frac{|D^v|}{|D|})$</li></ul></li><li><strong>缺陷：</strong>增益率准则对可取数目较少的属性有所偏好<ul><li>C4.5中使用启发式算法，先从候选划分属性中选出信息增益高于平均水平的属性，再从中选择增益率最高的最高的</li></ul></li></ul><h3 id="基尼系数"><a href="#基尼系数" class="headerlink" title="基尼系数"></a>基尼系数</h3><ul><li><strong>基尼系数</strong>（Gini index）：被CART决策树使用<ul><li>$Gini(D)=\sum^{|y|}<em>{k=1}\sum</em>{k’\neq k}p_kp_{k’}=1-\sum^{|y|}_{k=1}p_k^2$</li><li>$Gini(D)$反应了从数据集D中随机抽取两个样本，其类别标记不一致的概率。</li><li>$Gini(D)$越小，则数据集D的纯度越高</li></ul></li><li>属性a的基尼指数定义为：<ul><li>$Gini_index(D,a)=\sum^V_{v=1}\frac{|D^v|}{|D|}Gini(D^v)$</li></ul></li><li>选择划分后基尼指数最小的属性作为最优划分属性，即$a_*=\arg \min_{a\in A}Gini_index(D,a)$</li></ul><h2 id="3-决策树的生成"><a href="#3-决策树的生成" class="headerlink" title="3. 决策树的生成"></a>3. 决策树的生成</h2><ul><li>由于搜索空间是指数规模的，找出最佳决策树在计算上是不可行的。所以人们开发了一些有效的算法来构造<strong>次最优决策树</strong>。这些算法通常都采用<strong>贪心策略</strong>，采取一系列的<strong>局部最优策略</strong>来构造决策树。</li></ul><h3 id="Hunt-算法"><a href="#Hunt-算法" class="headerlink" title="Hunt 算法"></a>Hunt 算法</h3><ul><li><strong>Hunt算法</strong>通过将训练记录相继划分成较纯的子集，以递归方式建立决策树，是许多决策树算法的基础，包括ID3、C4.5和CART。</li><li><strong>算法：</strong>设$D_t$是与结点t关联的训练记录集，而$y={y_1,y_2,…,y_c}$是类标签<ul><li>如果$D_t$中所有记录都属于同一个类$y_t$，则$t$是叶节点，用$y_t$表示</li><li>如果$D_t$中包含属于多个类的记录，则选择一个<strong>属性测试条件</strong>，将记录划分成较小的子集。对于测试条件的每个输出，创建一个子女结点，并根据测试结果将$D_t$中的记录分布到子女结点中。然后，对于每个子女结点，递归地调用该算法。</li></ul></li><li><strong>补充附加条件：</strong>处理特殊情况<ul><li>当创建的子女结点为空，即不存在与这些结点相关联的记录时，则该结点为叶结点，类标号为父结点上训练记录的多数类。</li><li>当与$D_t$相关联的所有记录都具有相同的属性值，无法划分，但类又不同时，标号记为与结点相关联的训练记录中的多数类。</li></ul></li></ul><h3 id="ID3-算法"><a href="#ID3-算法" class="headerlink" title="ID3 算法"></a>ID3 算法</h3><ul><li><p><strong>ID3算法</strong>的核心是在决策树各个节点上应用<strong>信息增益</strong>准则选择特征，递归地构建决策树。</p><ul><li>相当于用极大似然法进行概率模型的选择。</li></ul></li><li><p><strong>算法</strong>：</p><ul><li><p><strong>输入：</strong>训练数据集$D$，特征集$A$阈值$\epsilon $</p></li><li><p><strong>输出：</strong>决策树$T$</p><ol><li><p>若$D$中所有实例属于同一类$C_k$，则$T$为单结点树，并将类$C_k$作为该结点的类标记，返回$T$；</p></li><li><p>若$A=\phi$，则$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$；</p></li><li><p>否则，计算$A$中各特征对$D$的<strong>信息增益</strong>，选择<strong>信息增益最大的特征</strong>$A_g$</p><p>$Gain(D,a)=Ent(D)-\sum^V_{v=1}\frac{|D^v|}{|D|}Ent(D^v)$；</p></li><li><p>如果$A_g$的信息增益小于阈值$\epsilon$，则置$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$；</p></li><li><p>否则，对$A_g$的每一可能值$a_i$，依$A_g=a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子结点，由结点及其子结点构成树$T$，返回$T$；</p></li><li><p>对第$i$个结点，以$D_i$作为训练集，以$A-{A_g}$为特征集，递归地调用1~5步，得到子树$T_i$，返回$T_i$。</p></li></ol></li></ul></li></ul><h3 id="C4-5-算法"><a href="#C4-5-算法" class="headerlink" title="C4.5 算法"></a>C4.5 算法</h3><ul><li><strong>C4.5 算法</strong>在生成过程中用<strong>信息增益比</strong>来选择特征，其它步骤相同。</li><li><strong>信息增益比：</strong>$Gain_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}$<ul><li><strong>固有值</strong>（intrinsic value）：$IV(a)=-\sum^V_{v=1}\frac{|D|^v}{|D|}\log_2(\frac{|D^v|}{|D|})$</li></ul></li></ul><h3 id="CART-算法"><a href="#CART-算法" class="headerlink" title="CART 算法"></a>CART 算法</h3><ul><li><strong>分类与回归树</strong>（classification and regression tree, CART）模型，是<strong>广泛的决策树学习方法</strong>。同样由<strong>特征选择</strong>、<strong>树的生成</strong>和<strong>剪枝</strong>组成，既可以用于分类也可以用于回归。</li><li><strong>组成</strong>：<ul><li><strong>生成</strong>：基于训练数据集生成决策树，生成的决策树要尽量大；</li><li><strong>剪枝</strong>：用<strong>验证数据集</strong>对已生成的树进行剪枝并选择最优子树，用<strong>损失函数最小</strong>作为剪枝的标准。</li></ul></li><li><strong>生成</strong><ul><li><strong>回归树：</strong>平方误差最小化准则<ul><li><strong>平方误差：</strong>$\sum_{x_i\in R_{m}}(y_i-f(x_i))^2$</li><li>寻找最优<strong>切分变量</strong>（splitting variable）、<strong>切分点</strong>（splitting point），即求解：<ul><li>$\min_{j,s}[\min_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2+\min_{c_2}\sum_{x_i\in R_2(j,s)}(y_i-c_2)^2]$</li><li>$R_1(j,s)={x|x^{(j)}\le s}$；$R_2(j,s)={x|x^{(j)}&gt; s}$</li></ul></li></ul></li><li><strong>分类树：</strong>基尼指数最小化准则<ul><li><strong>基尼指数最小化</strong><ul><li>$Gini_index(D,a)=\sum^V_{v=1}\frac{|D^v|}{|D|}Gini(D^v)$</li></ul></li></ul></li></ul></li><li><strong>剪枝</strong><ul><li><strong>两步</strong><ul><li><strong>剪枝，形成一个子树序列</strong>（关于损失函数参照下一节剪枝内容，来便于理解）<ul><li>计算<strong>损失函数</strong>：$C_\alpha(T)=C(T)+\alpha |T|$</li><li>将$\alpha$从小增大，形成一系列的区间$[\alpha_i,\alpha_{i+1})$，得到对应区间的最优子树$T_i$</li><li>对$T_0$的任意内部结点$t$<ul><li>以$t$为单结点树的损失函数：$C_\alpha(t)=C(t)+\alpha$</li><li>以$t$为根结点的子树$T_t$的损失函数：$C_\alpha(T_t)=C(T_t)+\alpha|T_t|$</li><li>$\alpha=\frac{C(t)-C(T_t)}{|T_t|-1}$，即$C_\alpha(T_t)=C_\alpha(t)$时，$T_t$与$t$具有相同的损失函数，而$t$的结点少，因此$t$比$T_t$更可取，对$T_t$进行剪枝</li><li>因此，<ul><li>$g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}$，表示剪枝后<strong>整体损失函数减少的程度</strong></li><li>将$\alpha_k=\alpha,T_k=T$，不断剪枝下去，直到根结点。</li></ul></li></ul></li></ul></li><li><strong>在得到的子树序列$T_0,T_1,…,T_n$中通过交叉验证选取最优子树</strong><ul><li>利用独立的验证数据集，测试子树序列中各棵子树的平方误差或基尼指数，最小的被认为是最优的决策树。</li></ul></li></ul></li><li><strong>步骤</strong><ol><li>设$k=0,T=T_0$。</li><li>设$\alpha=+\infty$。</li><li>自下而上地对各内部结点$t$计算$C(T_t)$，$|T_t|$以及$g(t)$和$\alpha$<ul><li>$T_t$为以$t$为根结点的子树，$C(T_t)$为对训练数据的预测误差，$|T_t|$是$T_t$的叶结点个数</li><li>$g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}$，$\alpha=\min(\alpha,g(t))$</li></ul></li><li>对$g(t)=\alpha$的内部结点$t$进行剪枝，并对叶结点$t$以多数表决法决定其类，得到树$T$。</li><li>设$k=k+1,\alpha_k=\alpha,T_k=T$</li><li>如果$T_k$不是由根结点及两个叶结点构成的树，则回到步骤（2）；否则令$T_k=T_n$</li><li>采用交叉验证法在子树序列$T_0,T_1,…,T_n$中选取最优子树$T_\alpha$</li></ol></li></ul></li></ul><h2 id="4-剪枝处理"><a href="#4-剪枝处理" class="headerlink" title="4. 剪枝处理"></a>4. 剪枝处理</h2><ul><li>在上一节的CART算法中已经提及了它的剪枝处理，在本节将对剪枝处理本身进行一些描述。这里主要做一些描述性的介绍，不再进行具体细化的描述，不清楚可以自行寻找一些例子。</li><li><strong>剪枝</strong>（pruning）是决策树学习算法应对<strong>过拟合</strong>的主要手段，可以通过主动去掉一些分支来降低过拟合的风险，基本策略有“<strong>预剪枝</strong>“（prepruning）和“<strong>后剪枝</strong>“（postpruning）两种。</li><li><strong>预剪枝</strong>是指在<strong>决策树生成过程中</strong>，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树<strong>泛化性能</strong>的提升则停止划分，并将当前结点标记为叶结点；<strong>后剪枝</strong>则是先从训练集<strong>生成一棵完整的决策树</strong>，然后<strong>自底向上</strong>地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能的提升，则将该子树替换为叶结点。</li><li><strong>剪枝方法</strong>：极小化决策树整体的损失函数（loss function）或代价函数（cost function）来实现。<ul><li><strong>损失函数：</strong>$C_\alpha(T)=C(T)+\alpha |T|$<ul><li>$C(T)$：对训练数据的预测误差，即模型与训练数据的拟合程度（如基尼指数）</li><li>$|T|$：子树的叶结点个数，即模型复杂度</li><li>$\alpha\ge0$：参数，参数$\alpha$权衡训练数据的拟合程度与模型的复杂程度<ul><li>较大：较简单的模型；较小：较复杂的模型</li><li>$\alpha=0$：只考虑模型与训练数据的拟合程度，不考虑模型的复杂程度</li></ul></li></ul></li><li>剪枝，就是<strong>当$\alpha$确定时，选择损失函数最小的模型</strong>，即损失函数最小的子树。</li></ul></li><li>决策树生成学习<strong>局部</strong>的模型，而决策树剪枝学习<strong>整体</strong>的模型。</li></ul><h2 id="5-其它相关内容"><a href="#5-其它相关内容" class="headerlink" title="5. 其它相关内容"></a>5. 其它相关内容</h2><ul><li>还有一些内容与决策树相关，但对决策树的基础而言不显得十分重要，所以不再介绍，只是提及词汇，有兴趣可以参考三本书中的内容。包括，<strong>连续值与缺失值的处理</strong>（《机器学习》4.4、《数据挖掘（导论）完整版》）、<strong>多变量决策树</strong>（《机器学习》4.5、《数据挖掘（导论））。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data </tag>
            
            <tag> Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试（三）黑白盒测试练习</title>
      <link href="/software-test-03/"/>
      <url>/software-test-03/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试（三）黑白盒测试练习"><a href="#软件测试（三）黑白盒测试练习" class="headerlink" title="软件测试（三）黑白盒测试练习"></a>软件测试（三）黑白盒测试练习</h1><ul><li>内容来自老师的课堂练习，偷偷留下。</li></ul><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><p>​        用等价类划分法和边界值法设计一个“日期检查功能”的测试用例，输入为6位数字字符，前四位表示年份，后两位表示月份，限定从1990年1月到2049年12月。</p><h3 id="【答案】"><a href="#【答案】" class="headerlink" title="【答案】"></a>【答案】</h3><ul><li><p><strong>等价类</strong></p><p><img src="./01-01.png" alt="01-01 等价类划分"></p></li><li><p><strong>测试用例</strong></p><table><thead><tr><th>用例编号</th><th>输入值</th><th>覆盖的等价类编号</th><th>合理输出值</th></tr></thead><tbody><tr><td>1</td><td>201910</td><td>（1）</td><td>正确</td></tr><tr><td>2</td><td>2019</td><td>（2）</td><td>提示位数错误</td></tr><tr><td>3</td><td>2019A1</td><td>（3）</td><td>提示存在非法字符</td></tr><tr><td>4</td><td>192911</td><td>（4）</td><td>提示年份过小</td></tr><tr><td>5</td><td>208011</td><td>（5）</td><td>提示年份过大</td></tr><tr><td>6</td><td>201900</td><td>（6）</td><td>提示月份过小</td></tr><tr><td>7</td><td>201914</td><td>（7）</td><td>提示月份过大</td></tr></tbody></table></li><li><p><strong>边界值</strong></p><ul><li>（1）数字6位</li><li>（2）年份：1990</li><li>（3）年份：2049</li><li>（4）月份：01</li><li>（5）月份：02</li></ul></li><li><p><strong>边界值测试用例</strong></p><p><img src="./01-02.png" alt="01-02 边界值测试用例"></p></li></ul><h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><h3 id="【题目】-1"><a href="#【题目】-1" class="headerlink" title="【题目】"></a>【题目】</h3><p>​    对以下伪代码绘制程序框图、程序流图，进行判定-条件、条件组合、路径覆盖、基本路径覆盖测试，设计测试用例：</p><pre class=" language-pascal"><code class="language-pascal">DIM a<span class="token punctuation">,</span>b As IntegerDIM c As Integer<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> b<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">then</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">then</span>        c <span class="token operator">=</span> a<span class="token operator">+</span>b    <span class="token keyword">else</span> c<span class="token operator">=</span>c<span class="token number">+1</span>    <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token keyword">else</span> c<span class="token operator">=</span>c<span class="token number">+2</span><span class="token keyword">end</span> <span class="token keyword">if</span></code></pre><h3 id="【答案】-1"><a href="#【答案】-1" class="headerlink" title="【答案】"></a>【答案】</h3><ul><li><p><strong>程序框图</strong></p><p><img src="./02-01.png" alt="02-01 程序框图"></p></li><li><p><strong>程序流图</strong></p><p><img src="./02-02.png" alt="02-02 程序流图"></p></li><li><p><strong>判定-条件</strong></p><ul><li><p>执行路径可以不用写，写的话帮助分析路径走法，保证判定、条件被覆盖到</p><p><img src="./02-03.png" alt="02-03 判定-条件用例设计"></p></li></ul></li><li><p><strong>条件组合</strong></p><ul><li><p>条件组合：</p><ul><li>1: $T_1T_2$</li><li>2: $T_1-T_2$</li><li>3: $-T_1T_2$</li><li>4: $-T_1-T_2$</li><li>5: $T_3$</li><li>6: $-T_3$</li></ul></li><li><p>用例设计：</p><table><thead><tr><th>测试用例</th><th>a,b,c</th><th>执行路径</th><th>覆盖条件</th><th>预期结果</th></tr></thead><tbody><tr><td>1</td><td>1,1,1</td><td>bdfg</td><td>1，5</td><td>2</td></tr><tr><td>2</td><td>1,1,-1</td><td>bceg</td><td>1，6</td><td>0</td></tr><tr><td>3</td><td>1,-1,1</td><td>ah</td><td>2</td><td>3</td></tr><tr><td>4</td><td>-1,1,1</td><td>ah</td><td>3</td><td>3</td></tr><tr><td>5</td><td>-1,-1,1</td><td>ah</td><td>4</td><td>3</td></tr></tbody></table></li></ul></li><li><p><strong>路径覆盖</strong></p><ul><li><p>路径分析：</p><ul><li>$ah+b(ce+df)g=ah+bceg+bdfg$ （共三条）</li></ul></li><li><p>测试用例：</p><table><thead><tr><th>测试用例</th><th>a,b,c</th><th>执行路径</th><th>预期结果</th></tr></thead><tbody><tr><td>1</td><td>1,-1,1</td><td>ah</td><td>3</td></tr><tr><td>2</td><td>1,1,-1</td><td>bceg</td><td>0</td></tr><tr><td>3</td><td>1,1,1</td><td>bdfg</td><td>2</td></tr></tbody></table></li></ul></li><li><p><strong>基本路径覆盖</strong></p><ul><li><p>数量：$V(G)=流程图中区域数=3$</p></li><li><p>测试用例：</p><table><thead><tr><th>测试用例</th><th>a,b,c</th><th>执行路径</th><th>预期结果</th></tr></thead><tbody><tr><td>1</td><td>1,-1,1</td><td>ah</td><td>3</td></tr><tr><td>2</td><td>1,1,-1</td><td>bceg</td><td>0</td></tr><tr><td>3</td><td>1,1,1</td><td>bdfg</td><td>2</td></tr></tbody></table></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试（二）白盒测试</title>
      <link href="/software-test-02/"/>
      <url>/software-test-02/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试（二）白盒测试"><a href="#软件测试（二）白盒测试" class="headerlink" title="软件测试（二）白盒测试"></a>软件测试（二）白盒测试</h1><h2 id="白盒测试（White-Box-Testing）"><a href="#白盒测试（White-Box-Testing）" class="headerlink" title="白盒测试（White-Box Testing）"></a>白盒测试（White-Box Testing）</h2><ul><li><strong>基本原理</strong>：基于过程设计的控制结构导出测试用例。</li><li><strong>白盒测试分类</strong><ul><li>Control Flow-Testing<ul><li>逻辑分支覆盖法<ul><li>语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖</li></ul></li><li>路径法<ul><li>路径覆盖、基本（独立）路径测试法</li></ul></li></ul></li><li>DataFlow-Testing</li></ul></li></ul><h2 id="控制流测试"><a href="#控制流测试" class="headerlink" title="控制流测试"></a>控制流测试</h2><h3 id="逻辑分支覆盖法"><a href="#逻辑分支覆盖法" class="headerlink" title="逻辑分支覆盖法"></a>逻辑分支覆盖法</h3><h4 id="1-语句覆盖（statement）"><a href="#1-语句覆盖（statement）" class="headerlink" title="1. 语句覆盖（statement）"></a>1. 语句覆盖（statement）</h4><ul><li><p><strong>概念</strong></p><ul><li>语句覆盖就是设计若干个测试用例，运行被测程序，使得<strong>每一可执行语句至少执行一次</strong>。</li><li>这种覆盖又称为<strong>点覆盖</strong>，它使得程序中每个可执行语句都得到执行，但它是<strong>最弱的逻辑覆盖</strong>，效果有限，必须与其它方法交互使用。  </li></ul></li><li><p><strong>示例</strong></p><p><img src="./02-01.png" alt="02-01 语句覆盖"></p></li></ul><h4 id="2-判定覆盖（Decision-Coverage-Branch-Coverage）"><a href="#2-判定覆盖（Decision-Coverage-Branch-Coverage）" class="headerlink" title="2. 判定覆盖（Decision Coverage, Branch Coverage）"></a>2. 判定覆盖（Decision Coverage, Branch Coverage）</h4><ul><li><strong>概念</strong><ul><li>判定覆盖就是设计若干个测试用例，运行被测程序，使得程序中<strong>每个判断的取真分支和取假分支至少经历一次</strong>。判定覆盖又称为<strong>分支覆盖</strong>。 </li></ul></li></ul><h4 id="3-条件覆盖（Condition-Coverage）"><a href="#3-条件覆盖（Condition-Coverage）" class="headerlink" title="3. 条件覆盖（Condition Coverage）"></a>3. 条件覆盖（Condition Coverage）</h4><ul><li><strong>概念</strong><ul><li>条件覆盖就是设计若干个测试用例，运行被测程序，使得程序中<strong>每个判断的每个条件的可能取值至少执行一次</strong>。 </li></ul></li><li><strong>关系</strong><ul><li>条件覆盖深入到判定中的每个条件，但可能不满足判定覆盖</li></ul></li></ul><h4 id="4-判定-条件覆盖"><a href="#4-判定-条件覆盖" class="headerlink" title="4. 判定/条件覆盖"></a>4. 判定/条件覆盖</h4><ul><li><strong>概念</strong><ul><li>判定-条件覆盖要求设计足够的测试用例，使得<strong>判定中每个条件的所有可能 （真/假）至少出现一次</strong>，并且<strong>每个判定本身的判定结果（真/假）也至少出现一次</strong>。</li></ul></li><li><strong>复合判定</strong>：改为单个条件判定</li></ul><h4 id="5-条件组合覆盖"><a href="#5-条件组合覆盖" class="headerlink" title="5. 条件组合覆盖"></a>5. 条件组合覆盖</h4><ul><li><p><strong>概念</strong></p><ul><li>条件组合覆盖就是设计足够的测试用例，运行被测程序，使得<strong>每个判断的所有可能的条件取值组合至少执行一次</strong>。 </li></ul></li><li><p><strong>关系</strong></p><ul><li>满足“条件组合覆盖”的测试用 例是一定满足“判定覆盖”、“条件覆盖”和“判定-条件覆盖”的。 </li></ul></li><li><p><strong>示例</strong></p><p><img src="./02-02.png" alt="02-02 条件组合覆盖"></p></li></ul><h3 id="路径法"><a href="#路径法" class="headerlink" title="路径法"></a>路径法</h3><h4 id="1-路径覆盖（Path-Coverage）"><a href="#1-路径覆盖（Path-Coverage）" class="headerlink" title="1. 路径覆盖（Path Coverage）"></a>1. 路径覆盖（Path Coverage）</h4><ul><li><strong>概念</strong><ul><li>路径测试就是设计足够的测试用例，<strong>覆盖程序中所有可能的路径</strong>。这是<strong>最强的覆盖准则</strong>。但在路径数目很大时，真正做到完全覆盖是很困难的，必须把覆盖路径数目压缩到一定限度。 </li><li>保证程序中每条可能的路径都至少执行一次，因此更具代表性，暴露错误的能力也比较强。 </li><li>但为了做到路径覆盖，只需考虑每个判定式的取值组合，并没有检验表达式中条件的各种可能组合。如果将路径覆盖和条件组合覆盖结合起来，可以设计出检错能力更强的测试数据。 </li></ul></li></ul><h4 id="2-基本（独立）路径测试法"><a href="#2-基本（独立）路径测试法" class="headerlink" title="2. 基本（独立）路径测试法"></a>2. 基本（独立）路径测试法</h4><ul><li><strong>概念</strong><ul><li>独立路径：从入口到出口的路径，至少经历一个从未走过的边。这样形成的路径叫独立路径。</li></ul></li><li><strong>步骤</strong><ul><li>根据程序的逻辑结构画出<strong>程序框图</strong></li><li>根据程序框图导出<strong>流图</strong></li><li>计算流图<strong>G</strong>的<strong>环路复杂度$V(G)$</strong><ul><li><strong>流图的区域数量</strong>应该对应于环复杂度 </li><li>给定流图G的环复杂度定义为：$V(G)=E-N+2$<ul><li>E为流图中的边数量，N为流图中的节点数量 </li></ul></li><li>给定流图G的环复杂度也可以定义为：$V(G)=P+1$<ul><li>P为流图中的判断节点数量</li></ul></li></ul></li><li>确定只包含独立路径的基本路径集</li><li>设计测试用例</li></ul></li></ul><h2 id="数据流测试"><a href="#数据流测试" class="headerlink" title="数据流测试"></a>数据流测试</h2><ul><li><p><strong>含义</strong>：数据流测试使用控制流图来进行测试。</p><ul><li>能填补路径和分支测试的缝隙</li></ul></li><li><p><strong>数据对象类别：</strong></p><ul><li><strong>（d）</strong>：Defined, Created, Initialized</li><li><strong>（k）</strong>：Killed, Undefined, Released</li><li><strong>（u）</strong>：Used<ul><li><strong>（c）</strong>：Used in a calculation</li><li><strong>（p）</strong>：Used in a predicate</li></ul></li></ul></li><li><p><strong>路径段</strong>（du Path Segments）</p><ul><li><p>Def-use Association: $(x , d, u)$</p><ul><li>x: 变量</li><li>d: 含有x定义的节点</li><li>u: 含有x使用的判断或语句</li><li>路径段中不存在其它x的定义</li></ul></li><li><p><strong>例子</strong></p><p><img src="./03-01.png" alt="03-01 Du Path 示例"></p></li></ul></li><li><p><strong>数据流测试策略：ADUP</strong>（All du Paths）</p><ul><li>找出测试所有的du paths路径</li></ul></li></ul><h2 id="终极示例"><a href="#终极示例" class="headerlink" title="终极示例"></a>终极示例</h2><ul><li>其实就是课程作业啦…</li></ul><h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><pre class=" language-python"><code class="language-python">scanf<span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">and</span> x<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>    pow <span class="token operator">=</span> <span class="token operator">-</span>y<span class="token punctuation">;</span><span class="token keyword">else</span>    pow <span class="token operator">=</span> y<span class="token punctuation">;</span>z <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>pow <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    z <span class="token operator">=</span> z <span class="token operator">*</span> x<span class="token punctuation">;</span>    pow <span class="token operator">=</span> pow <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">and</span> z<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>    z <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> z<span class="token punctuation">;</span>printf <span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>用判定条件覆盖法、基本路径法完成测试用例设计（要求画程序流程图和控制流图）</p><h3 id="【答案】"><a href="#【答案】" class="headerlink" title="【答案】"></a>【答案】</h3><ol><li><p>程序流程图</p><p><img src="./04-01.png" alt="04-01 程序流程图"></p></li><li><p>控制流图</p><p><img src="./04-02.png" alt="04-02 控制流图"> </p></li><li><p>判定条件覆盖法</p><p><img src="./04-03.png" alt="04-03 判定条件覆盖"></p></li><li><p>基本路径法</p><p>本因有四条基本路径，但由于判定1与判定3存在矛盾，所以无法找出四条基本路径的实际用例。</p><table><thead><tr><th>测试序号</th><th>测试路径</th><th>输入(x, y)</th><th>理想输出(z)</th></tr></thead><tbody><tr><td>1</td><td>abdefhjk</td><td>(1, 0)</td><td>1.0</td></tr><tr><td>2</td><td>abdefgfhjk</td><td>(-1, -1)</td><td>-1.0</td></tr><tr><td>3</td><td>abcefgfhijk</td><td>(1, -1)</td><td>1.0</td></tr><tr><td>4</td><td></td><td></td><td></td></tr></tbody></table></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试（一）黑盒测试</title>
      <link href="/software-test-01/"/>
      <url>/software-test-01/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试（一）黑盒测试"><a href="#软件测试（一）黑盒测试" class="headerlink" title="软件测试（一）黑盒测试"></a>软件测试（一）黑盒测试</h1><h2 id="动态黑盒测试（Black-Box-Test）"><a href="#动态黑盒测试（Black-Box-Test）" class="headerlink" title="动态黑盒测试（Black-Box Test）"></a>动态黑盒测试（Black-Box Test）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>不深入代码细节测试软件的方法称为<strong>动态黑盒测试</strong>。</li><li><strong>动态</strong>（dynamic）：程序在运行；<strong>黑盒</strong>（black-box）：不知道如何运行。</li><li>动态黑盒测试常被称为<strong>行为测试</strong>，因为测试的是软件在使用过程中的实际行动。</li></ul><h2 id="测试用例设计技术"><a href="#测试用例设计技术" class="headerlink" title="测试用例设计技术"></a>测试用例设计技术</h2><h3 id="1-等价类划分法（Equivalence-Partitioning）"><a href="#1-等价类划分法（Equivalence-Partitioning）" class="headerlink" title="1. 等价类划分法（Equivalence Partitioning）"></a>1. 等价类划分法（Equivalence Partitioning）</h3><ul><li><p><strong>概念</strong>：把程序的输入域划分成若干部分，然后从每个部分中选取少数代表性数据当作测试用例。</p></li><li><p><strong>有效等价类</strong> &amp; <strong>无效等价类</strong></p><ul><li>有效等价类：指对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现 了规格说明中所规定的功能和非功能。 </li><li>无效等价类：与有效等价类的定义恰巧相反。 </li></ul></li><li><p>测试：<strong>完备性</strong>、<strong>无冗余性</strong></p></li><li><p><strong>确定等价类的原则：</strong></p><ul><li>在输入条件规定了取值范围或值的个数的情况下，则可以确立一个有效等价类和两个无效等价类。 </li><li>在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可以确立一个有效等价类和一个无效等价类。 </li><li>在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类。 </li><li>在规定了输入数据的一组值 ，并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类。</li><li>在规定了输入数据必须遵守的规则的情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）。 </li><li>如果确知，已划分的等价类中各个元素在程序中的处理方式不同，则应将此等价类进一步划分成更小的等价类。 </li></ul></li><li><p><strong>示例</strong></p><ul><li><p>等价类划分：</p><table><thead><tr><th>被测项</th><th>边长</th><th>等价类编号</th></tr></thead><tbody><tr><td>有效等价类</td><td>正数</td><td>1</td></tr><tr><td>无效等价类</td><td>小于0</td><td>2</td></tr></tbody></table></li><li><p>测试用例设计：</p><table><thead><tr><th>测试用例编号</th><th>输入值</th><th>覆盖的等价类编号</th><th>合理输出</th></tr></thead><tbody><tr><td>T1</td><td>2</td><td>(1)</td><td>正确</td></tr><tr><td>T2</td><td>0</td><td>(2)</td><td>错误</td></tr></tbody></table></li></ul></li></ul><h3 id="2-边界值分析法（VBA-Boundary-Value-Analysis）"><a href="#2-边界值分析法（VBA-Boundary-Value-Analysis）" class="headerlink" title="2. 边界值分析法（VBA, Boundary Value Analysis）"></a>2. 边界值分析法（VBA, Boundary Value Analysis）</h3><ul><li><strong>概念：</strong>对等价划分类的补充，不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。</li><li><strong>设计方法：</strong><ul><li>确定边界情况（输入或输出等价类的边界）</li><li>选取正好等于、刚刚大于或刚刚小于边界值作为测试数据 </li><li>一般情况，一个边界可以给出3个边界测试用例，<strong>自身+左右值</strong></li></ul></li></ul><h3 id="3-错误推测方法"><a href="#3-错误推测方法" class="headerlink" title="3. 错误推测方法"></a>3. 错误推测方法</h3><ul><li><strong>概念：</strong><ul><li>通过经验和直觉推测出程序的错误所在；</li><li>主观、灵感、反向思维，难以复制等等；</li><li>不是一个系统的方法，用作辅助手段。</li></ul></li></ul><h3 id="4-判定表驱动测试方法（Decision-Table）"><a href="#4-判定表驱动测试方法（Decision-Table）" class="headerlink" title="4. 判定表驱动测试方法（Decision Table）"></a>4. 判定表驱动测试方法（Decision Table）</h3><ul><li><p><strong>概念：</strong>是分析和表达多逻辑条件下执行不同操作的工具，也叫判定表。</p></li><li><p><strong>组成：</strong>条件桩（Condition Stub）、动作桩（Action Stub）、条件项、动作项、规则</p><table><thead><tr><th>条件桩</th><th>条件项</th></tr></thead><tbody><tr><td>动作桩</td><td>动作项</td></tr></tbody></table></li><li><p><strong>示例：</strong></p><ul><li><p>判定表：</p><p><img src="./01-01.png" alt="01-01 判定表"></p></li><li><p>测试用例：</p><p><img src="./01-02.png" alt="01-02 判定表测试用例"></p></li></ul></li></ul><h3 id="5-因果图法"><a href="#5-因果图法" class="headerlink" title="5. 因果图法"></a>5. 因果图法</h3><ul><li><p><strong>概念：</strong></p><ul><li>借助图的方式，设计测试用例，被测程序有多种输入条件，输出结果依赖于输入条件的组合; </li><li>着重分析输入条件的各种组合，每个条件就是一个“因”，这些“因”的组合必然有一个输出的结果，这就是“果”; </li><li>与其他的方法相比，更侧重于输入条件的组合 。</li></ul></li><li><p><strong>约束符号</strong></p><ul><li>E：互斥，不能同时出现</li><li>I：包含，至少一个出现</li><li>O：唯一，有且只有一个出现</li><li>R：要求，若a=1那么要求b必须是1，反之如果a=0，那么b无所谓</li><li>M：屏蔽，当a=1时，b=0，当a=0，b的值有可能是1，也有可能是0</li></ul></li><li><p><strong>示例：</strong></p><p><img src="./01-03.png" alt="01-03 因果图"></p></li><li><p><strong>步骤：</strong></p><ul><li>分析软件规格说明描述中, 哪些是原因（即输入条件或输入条件的等价类），哪些是结果（即输出条件），并给每个原因和结果赋予一个标识符。 </li><li>分析软件规格说明描述中的语义，找出原因与结果之间、原因与原因之间对应的关系。根据这些关系，画出因果图。 </li><li>把因果图转换为判定表。</li><li>把判定表的每一列拿出来作为依据,设计测试用例。 </li></ul></li></ul><h3 id="6-场景法"><a href="#6-场景法" class="headerlink" title="6. 场景法"></a>6. 场景法</h3><ul><li><p><strong>概念：</strong></p><ul><li>用例场景：用来描述流经用例的路径，从用例开始到结束遍历这条路径上所有基本流和备选流。</li><li><strong>基本流</strong>和<strong>备选流</strong></li><li><strong>场景</strong></li></ul></li><li><p>测试用例设计<strong>步骤</strong>与<strong>示例</strong></p><ul><li><p><strong>设计场景</strong>：通过用例的主事件流和备选事件流的组合给出不同的场景</p><table><thead><tr><th>场景</th><th>基本流&amp;备选流</th></tr></thead><tbody><tr><td>场景1</td><td>基本流</td></tr><tr><td>场景2</td><td>基本流 备选流1</td></tr><tr><td>场景3</td><td>基本流 备选流1 备选流2</td></tr><tr><td>场景4</td><td>基本流 备选流3</td></tr></tbody></table></li><li><p><strong>设计测试用例标准</strong>：覆盖场景</p></li></ul><table><thead><tr><th>测试用例编号</th><th>覆盖的场景</th><th>PIN</th><th>账号</th><th>输入（选择）的金额</th><th>账面金额</th><th>ATM中的金额</th><th>预测结果</th></tr></thead><tbody><tr><td>1</td><td>场景1-成功提款</td><td>V</td><td>V</td><td>V</td><td>V</td><td>V</td><td>成功提款</td></tr><tr><td>2</td><td>场景2-ATM内无现金</td><td>V</td><td>V</td><td>V</td><td>V</td><td>I</td><td>提款选项不可用，用例结束</td></tr><tr><td>…</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>根据测试用例标准给出<strong>具体的测试数据</strong><table><thead><tr><th>测试用例编号</th><th>覆盖的场景</th><th>PIN</th><th>账号</th><th>输入（选择）的金额</th><th>账面金额</th><th>ATM中的金额</th><th>预测结果</th></tr></thead><tbody><tr><td>1</td><td>场景1-成功提款</td><td>1987</td><td>809-498</td><td>100</td><td>500</td><td>2000</td><td>成功提款</td></tr><tr><td>2</td><td>场景2-ATM内无现金</td><td>1987</td><td>809-398</td><td>100</td><td>500</td><td>0</td><td>提款选项不可用，用例结束</td></tr><tr><td>…</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></li></ul></li><li><p><strong>应用场景</strong></p><ul><li>一般用于<strong>功能测试</strong>，基本上所有的功能流程测试都会用到；</li><li>业务复杂时，针对关键业务场景进行业务的流程测试。</li></ul></li></ul><h2 id="黑盒测试策略总结"><a href="#黑盒测试策略总结" class="headerlink" title="黑盒测试策略总结"></a>黑盒测试策略总结</h2><ul><li>针对功能具体页面中具体的输入域进行细化测试，采用等价类、边界值；</li><li>用静态检查法检查按钮、链接、内容、图片等；</li><li>针对每个功能的流程，采用场景法，进行该功能（用例）的全方位流程测试；</li><li>如果是多个条件的组合可以采用判定表或因果图法；</li><li>在任何情况下都必须使用边界值分析方法；</li><li>用错误推测法再追加一些测试用例。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记（三）第一个渲染程序</title>
      <link href="/opengl-03/"/>
      <url>/opengl-03/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenGL学习笔记（三）第一个渲染程序"><a href="#OpenGL学习笔记（三）第一个渲染程序" class="headerlink" title="OpenGL学习笔记（三）第一个渲染程序"></a>OpenGL学习笔记（三）第一个渲染程序</h1><p>​    上一篇中简单介绍了渲染管线和FLEW、FreeGLUT库的安装，但示例程序仍是使用已经废止的glBegin和glEnd来实现的，这次将进行第一个真正的渲染程序的编写（毕竟将对管线的认知转到实际的代码中的体现，仍是需要示例来帮助的）。第一次计算机图形学课的实验，由于没弄清楚要求，以为侧重三D建模和图形旋转就参考了一个复杂的示例，结果就被检查的师兄提问到“失去理想”了（问各种参数和流程交互，嘤嘤嘤），此文也是为了弥补缺憾。</p><p>​    此文的代码来自传说中的红宝书<a href="https://github.com/openglredbook" title="openGL RedBook Github" target="_blank" rel="noopener">[1]</a>并参考老师课件，感谢<a href="https://www.cnblogs.com/caster99/p/4752354.html" title="OpenGL红宝书：第一个渲染程序Triangles常见问题归总 - caster99" target="_blank" rel="noopener">[2]</a><a href="http://www.360doc.com/content/14/1028/10/19175681_420522404.shtml" title="OpenGL学习脚印：基本图形绘制方式比较（glBegin, glCallList, glVertexPointer, VBO）- 方海龙的书馆" target="_blank" rel="noopener">[3]</a><a href="https://blog.csdn.net/chunyexiyu/article/details/89224004" title="Mac上构建OpenGL红宝书上的triangles程序-春夜喜雨" target="_blank" rel="noopener">[4]</a>，帮助我解决了很多的碰到的问题。</p><h2 id="OpenGL传统与现代的绘制方式"><a href="#OpenGL传统与现代的绘制方式" class="headerlink" title="OpenGL传统与现代的绘制方式"></a>OpenGL传统与现代的绘制方式</h2><p>​    在<a href>OpenGL学习笔记（一）</a>中，曾简单提到了<strong>核心模式</strong>（Core-Profile）与<strong>立即渲染模式</strong>（Immediate mode）这两个词，在开始编写渲染程序之前，有必要再次提到这两个词，并说明介绍一下OpenGL传统与现代的绘制方式，来帮助大家更清楚地了解使用渲染管线编程（自己在图形学课的第一次实验前，在两种方式上吃了很大的亏，弄了好多使用glBegin和glEnd的示例来看，结果发现不符合要求，蓝瘦）。</p><h3 id="传统方式绘制"><a href="#传统方式绘制" class="headerlink" title="传统方式绘制"></a>传统方式绘制</h3><h4 id="1-立即渲染模式（Immediate-Mode）"><a href="#1-立即渲染模式（Immediate-Mode）" class="headerlink" title="1. 立即渲染模式（Immediate Mode）"></a>1. 立即渲染模式（Immediate Mode）</h4><p>​    使用glBegin…glEnd的方式制定绘制方式，<a href>学习笔记（二）</a>最后的示例就是通过这种方式绘制的，在OpenGL新版本中已被废弃。简单示例如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">glBegin</span><span class="token punctuation">(</span>GL_LINE_LOOP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将以下点逐一连线</span>    <span class="token function">glVertex3d</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">,</span>a<span class="token punctuation">.</span>y<span class="token punctuation">,</span>a<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glVertex3d</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>x<span class="token punctuation">,</span>b<span class="token punctuation">.</span>y<span class="token punctuation">,</span>b<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glVertex3d</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>x<span class="token punctuation">,</span>c<span class="token punctuation">.</span>y<span class="token punctuation">,</span>c<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glVertex3d</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>x<span class="token punctuation">,</span>d<span class="token punctuation">.</span>y<span class="token punctuation">,</span>d<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="2-显示列表（Display-List）"><a href="#2-显示列表（Display-List）" class="headerlink" title="2. 显示列表（Display List）"></a>2. 显示列表（Display List）</h4><p>​    将一组OpenGL函数存储在一起，在以后执行，调用时，存储的函数会按顺序执行。示例如下：</p><pre class=" language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//创建显示列表</span> displayListId <span class="token operator">=</span> <span class="token function">glGenLists</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">glNewList</span><span class="token punctuation">(</span>displayListId<span class="token punctuation">,</span> GL_COMPILE<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">glBegin</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">glVertex3f</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">glVertex3f</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">glVertex3f</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">glEndLIst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="现代方式绘制"><a href="#现代方式绘制" class="headerlink" title="现代方式绘制"></a>现代方式绘制</h3><h4 id="1-顶点数组绘图"><a href="#1-顶点数组绘图" class="headerlink" title="1. 顶点数组绘图"></a>1. 顶点数组绘图</h4><blockquote><p>​    使用顶点数组方式，需要利用glEnableClientState开启一些特性。</p><p>​    使用顶点数组时，用户定义好存储顶点的数据，在调用glDrawArrays、glDrawElements之类的函数时，用过glVertexPointer设定的指针，传送数据到GPU。当调用完glDrawArrays后，GPU中已经有了绘图所需数据，用户可以释放数据空间。<a href="https://www.cnblogs.com/caster99/p/4752354.html" title="OpenGL红宝书：第一个渲染程序Triangles常见问题归总 - caster99" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/caster99/p/4752354.html" title="OpenGL红宝书：第一个渲染程序Triangles常见问题归总 - caster99" target="_blank" rel="noopener">2</a></a></p></blockquote><p>​    示例：</p><pre class=" language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">//利用顶点数组，绘制三角形  </span>    <span class="token keyword">const</span> <span class="token keyword">int</span> num_indices <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建保存顶点的结构体数组</span>    vec3f <span class="token operator">*</span>vertices <span class="token operator">=</span> <span class="token keyword">new</span> vec3f<span class="token punctuation">[</span>num_indices<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 顶点1 </span>    vertices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">;</span>     vertices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">;</span>     vertices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 顶点2 </span>    vertices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0.5f</span><span class="token punctuation">;</span>      vertices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>       vertices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//顶点3  </span>    vertices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>    vertices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0.5f</span><span class="token punctuation">;</span>     vertices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 启用vertex arrays </span>    <span class="token function">glEnableClientState</span><span class="token punctuation">(</span>GL_VERTEX_ARRAY<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//定义顶点数组 </span>    <span class="token function">glVertexPointer</span><span class="token punctuation">(</span>          <span class="token number">3</span><span class="token punctuation">,</span>         <span class="token comment" spellcheck="true">// 每个顶点的维度 </span>        GL_FLOAT<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 顶点数据类型 </span>      <span class="token number">0</span><span class="token punctuation">,</span>         <span class="token comment" spellcheck="true">// 连续顶点之间的间隙，这里为0  </span>      vertices   <span class="token comment" spellcheck="true">//指向第一个顶点的第一个坐标的指针</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> num_indices<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">glDisableClientState</span><span class="token punctuation">(</span>GL_VERTEX_ARRAY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//释放内存空间</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> vertices<span class="token punctuation">;</span> </code></pre><h4 id="2-现代VBO-VAO绘图"><a href="#2-现代VBO-VAO绘图" class="headerlink" title="2. 现代VBO VAO绘图"></a>2. 现代VBO VAO绘图</h4><p>​    VAO（Vertex Array Object），包含一个或多个VBO对象，被设计来存储一个完整被渲染对象所需的信息；VBO（Vertex Buffer Object），在高速视频卡中的内存缓冲，保存顶点数据以及归一化向量、纹理和索引等数据。</p><h4 id="3-结合Shader绘图"><a href="#3-结合Shader绘图" class="headerlink" title="3. 结合Shader绘图"></a>3. 结合Shader绘图</h4><p>​    参考<a href>学习笔记（一）</a>不做详细解释。</p><h2 id="第一个渲染程序"><a href="#第一个渲染程序" class="headerlink" title="第一个渲染程序"></a>第一个渲染程序</h2><p>​    仍是一个绘制三角形的程序吼。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li>使用GLFW和FreeGLUT库<strong>（还是不行的，由于FreeGLUT在MAC上无法编译着色器代码，所以在此仍然使用Xcode自带的OpenGL.framework和GLUT.framework）</strong>，创建项目和配置库不再做解释，有需要请参考前两篇学习笔记。</li></ul><h3 id="1-LoadShaders"><a href="#1-LoadShaders" class="headerlink" title="1. LoadShaders"></a>1. LoadShaders</h3><p>​    包含一些宏定义，主要用于debug处理，红宝书提供的。</p><h4 id="LoadShaders-hpp"><a href="#LoadShaders-hpp" class="headerlink" title="LoadShaders.hpp"></a>LoadShaders.hpp</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> __LOAD_SHADERS_H__</span><span class="token macro property">#<span class="token directive keyword">define</span> __LOAD_SHADERS_H__</span><span class="token comment" spellcheck="true">//#include &lt;GL/gl.h></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;OpenGL/gl.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;OpenGL/gl3.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;GLUT/glut.h></span></span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">endif</span>  </span><span class="token comment" spellcheck="true">// __cplusplus</span> <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    GLenum       type<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>  filename<span class="token punctuation">;</span>    GLuint       shader<span class="token punctuation">;</span><span class="token punctuation">}</span> ShaderInfo<span class="token punctuation">;</span>GLuint <span class="token function">LoadShaders</span><span class="token punctuation">(</span>ShaderInfo<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//----------------------------------------------------------------------------</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">// __cplusplus</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">// __LOAD_SHADERS_H__</span></code></pre><h4 id="LoadShaers-cpp"><a href="#LoadShaers-cpp" class="headerlink" title="LoadShaers.cpp"></a>LoadShaers.cpp</h4><p>​    代码过长，又不打算加以解释，所以放置在最后的代码附录中。</p><h3 id="2-着色器定义"><a href="#2-着色器定义" class="headerlink" title="2. 着色器定义"></a>2. 着色器定义</h3><h4 id="triangle-vert-顶点着色器"><a href="#triangle-vert-顶点着色器" class="headerlink" title="triangle.vert 顶点着色器"></a>triangle.vert 顶点着色器</h4><ul><li>代码</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#version 400 core </span><span class="token comment" spellcheck="true">//版本号不能高于410，修改为400即可</span><span class="token function">layout</span><span class="token punctuation">(</span> location <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">)</span> in vec4 vPosition<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//从main程序中输入，必须与应用中的变量关联</span><span class="token keyword">void</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    gl_Position <span class="token operator">=</span> vPosition<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>执行流程示意图</li></ul><p><img src="./02-01.png" alt="02-01 顶点着色器渲染流程"></p><h4 id="triangle-frag-片段着色器"><a href="#triangle-frag-片段着色器" class="headerlink" title="triangle.frag 片段着色器"></a>triangle.frag 片段着色器</h4><ul><li>代码</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#version 400 core</span>out vec4 fColor<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//输出颜色信息</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    fColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置vPosition位置的颜色</span><span class="token punctuation">}</span></code></pre><ul><li>执行流程示意图</li></ul><p><img src="./02-02.png" alt="02-02 片段着色器渲染流程"></p><h3 id="3-主程序，main-cpp"><a href="#3-主程序，main-cpp" class="headerlink" title="3. 主程序，main.cpp"></a>3. 主程序，main.cpp</h3><h4 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"LoadShaders.hpp"</span> </span><span class="token comment" spellcheck="true">//其它的库头文件包含在“LoadShaders.hpp"中了</span><span class="token macro property">#<span class="token directive keyword">pragma</span> comment (lib, "glew32.lib")</span><span class="token comment" spellcheck="true">//存在无法解析外部符号d时的处理</span><span class="token keyword">enum</span> VAO_IDs <span class="token punctuation">{</span> Triangles<span class="token punctuation">,</span> NumVAOs <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//VAO, Vertex Array Object</span><span class="token keyword">enum</span> Buffer_IDs <span class="token punctuation">{</span> ArrayBuffer<span class="token punctuation">,</span> NumBuffers <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//着色器shader中的缓存</span><span class="token keyword">enum</span> Attrib_IDs <span class="token punctuation">{</span> vPosition <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//指定shader中的属性变量位置</span>GLuint  VAOs<span class="token punctuation">[</span>NumVAOs<span class="token punctuation">]</span><span class="token punctuation">;</span>GLuint  Buffers<span class="token punctuation">[</span>NumBuffers<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> GLuint  NumVertices <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span></code></pre><h4 id="init-初始"><a href="#init-初始" class="headerlink" title="init 初始"></a>init 初始</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span> NumVAOs<span class="token punctuation">,</span> VAOs <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建VAO</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span> VAOs<span class="token punctuation">[</span>Triangles<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//绑定所需的VAO</span>    GLfloat  vertices<span class="token punctuation">[</span>NumVertices<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token number">0.90f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.90f</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token number">0.85f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.90f</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token number">0.90f</span><span class="token punctuation">,</span>  <span class="token number">0.85f</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// Triangle 1</span>        <span class="token punctuation">{</span>  <span class="token number">0.90f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.85f</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token number">0.90f</span><span class="token punctuation">,</span>  <span class="token number">0.90f</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token number">0.85f</span><span class="token punctuation">,</span>  <span class="token number">0.90f</span> <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// Triangle 2</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//生成缓冲（对象数量，存储缓冲的数组），并在Buffers数组中返回n个缓冲对象的名称</span>    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span> NumBuffers<span class="token punctuation">,</span> Buffers <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//指定当前活动缓冲区的对象（Glenum target, Gluint buffer）</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span> GL_ARRAY_BUFFER<span class="token punctuation">,</span> Buffers<span class="token punctuation">[</span>ArrayBuffer<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*用数据分配和初始化缓冲区对象    target: GL_ARRAY_BUFFER（顶点数据），GL_ELEMENT_ARRAY_BUFFER（索引数据）    size: 存储相关数据所需的内存量    daata: 用于初始化的缓冲区对象，可以是指针，也可以是NULL    usage：数据在分配后如何进行读写，       GL_STATIC_DRAW，数据只指定1次，但可以多次作为绘图和图像指定h函数的源数据*/</span>    <span class="token function">glBufferData</span><span class="token punctuation">(</span> GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">,</span> vertices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>    ShaderInfo  shaders<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        <span class="token punctuation">{</span> GL_VERTEX_SHADER<span class="token punctuation">,</span> <span class="token string">"/Volumes/TOSHIBAEXT 1/CODE/Study/OpenGL/03/studyOpenGL0309/studyOpenGL0309/triangle.vert"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> GL_FRAGMENT_SHADER<span class="token punctuation">,</span> <span class="token string">"/Volumes/TOSHIBAEXT 1/CODE/Study/OpenGL/03/studyOpenGL0309/studyOpenGL0309/triangle.frag"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> GL_NONE<span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过LoadShaders写好的内容，进行shader创建</span>    GLuint program <span class="token operator">=</span> <span class="token function">LoadShaders</span><span class="token punctuation">(</span> shaders <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//使用程序对象作为当前渲染的一部分</span>    <span class="token function">glUseProgram</span><span class="token punctuation">(</span> program <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span>  BUFFER_OFFSET(offset) ((void *)(offset))</span>    <span class="token comment" spellcheck="true">/*指定渲染时索引值为index的顶点属性数组的数据格式和位置    Gluint index: 指定要修改的顶点属性的索引值    Glint size: 指定每个顶点属性的组建数量，必须为1、2、3或4，初始值为4    GLenum type: 指定数组中每个组件的数据类型    GLboolean normalized: 指定被访问时，固定点数据值被归一化（GL_TRUE),直接转换为固定值（GL_FALSE）    GLsizei stride: 指定连续顶点之间的偏移量。若为0，则是紧密排列在一起的，初始值为0    const GLvoid* pointer: 指定第一个组件在数组的第一个顶点属性中的偏移量，初始值为0*/</span>    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span> vPosition<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span>                           GL_FALSE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">BUFFER_OFFSET</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//默认情况下，出于性能考虑，所有顶点着色器的属性（Attribute）变量都是关闭的，意味着数据在着色器端是不可见的，哪怕数据已经上传到GPU，由glEnableVertexAttribArray启用指定属性，才可在顶点着色器中访问逐顶点的属性数据。glVertexAttribPointer或VBO只是建立CPU和GPU之间的逻辑连接，从而实现了CPU数据上传至GPU。但是，数据在GPU端是否可见，即，着色器能否读取到数据，由是否启用了对应的属性决定，这就是glEnableVertexAttribArray的功能，允许顶点着色器读取GPU（服务器端）数据。只要在绘图调用前调用即可</span>    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span> vPosition <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// set the color when clear screen</span>    <span class="token function">glClearColor</span> <span class="token punctuation">(</span><span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token number">0.4f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*清除指定的缓冲区    GL_COLOR_BUFFER_BIT: 当前可写的颜色缓冲    GL_DEPTH_BUFFER_BIT: 深度缓冲    GL_ACCUM_BUFFER_BIT: 累计缓冲    GL_STENCIL_BUFFER_BIT: 模版缓冲*/</span>    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAOs<span class="token punctuation">[</span>Triangles<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*绘制图形    GLenum mode: 绘制方式    GLint first: 从数组缓存中的哪一位开始绘制，一般为0    GLsizei count: 数组中顶点的数量*/</span>    <span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NumVertices<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//清空缓冲区，将指令送往缓硬件立即执行，但是它是将命令传送完毕之后立即返回，不会等待指令执行完毕。这些指令会在有限时间内执行完毕。使用glFlush的目的是确保在调用之后，CPU没有OpenGL相关的事情需要做-命令会送到硬件执行。调用glFinish的目的是确保当返回之后，没有相关工作留下需要继续做。</span>    <span class="token comment" spellcheck="true">//glFlush();</span>    <span class="token comment" spellcheck="true">//双缓存开启下使用glutSwapBuffers</span>    <span class="token function">glutSwapBuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"start init windows"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">glutInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化GLUT库，完成必须的初始化和开启事件处理循环</span>    <span class="token function">glutInitDisplayMode</span><span class="token punctuation">(</span>GLUT_DOUBLE<span class="token operator">|</span>GLUT_RGBA<span class="token operator">|</span>GLUT_3_2_CORE_PROFILE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置初始显示模式</span>    <span class="token comment" spellcheck="true">/* GLUT_3_2_CORE_PROFILE代替以下在FreeGLUT中的命令    glutInitContextVersion(4,3);//指定OpenGL版本    glutInitContextProfile(GLUT_CORE_PROFILE);//设置所需的OpenGL环境的类型*/</span>    <span class="token function">glutInitWindowPosition</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始窗口位置</span>    <span class="token function">glutInitWindowSize</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置窗口位置</span>    <span class="token function">glutCreateWindow</span><span class="token punctuation">(</span><span class="token string">"第一个渲染程序"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建一个顶级窗口，“第一个渲染程序"窗口名</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"init vertices"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"start display"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*当窗口内容绘制、窗口大小改变、窗口重绘时调用mydisplay函数重绘    一般与glutReshapeFunc(&amp;reshape), glutIdelFunc(&amp;IdleFunc)同时出现*/</span>    <span class="token function">glutDisplayFunc</span><span class="token punctuation">(</span>display<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutMainLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><ul><li>嘤嘤嘤，终于成功了，感谢网上的大佬们的博客。</li></ul><img src="./03-01.png" alt="03-01 最终效果" style="zoom:50%;"><ul><li>终于步入正轨了，在无法在Mac上进行编译的FreeGlut、误入传统绘图方法和各种错误上耗费了许多时间，总算成功了，哭。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]: <a href="https://github.com/openglredbook" target="_blank" rel="noopener">https://github.com/openglredbook</a>    “openGL RedBook Github”<br><a href="https://www.cnblogs.com/caster99/p/4752354.html" title="OpenGL红宝书：第一个渲染程序Triangles常见问题归总 - caster99" target="_blank" rel="noopener">2</a>: <a href="https://www.cnblogs.com/caster99/p/4752354.html" target="_blank" rel="noopener">https://www.cnblogs.com/caster99/p/4752354.html</a>    “OpenGL红宝书：第一个渲染程序Triangles常见问题归总 - caster99”<br><a href="http://www.360doc.com/content/14/1028/10/19175681_420522404.shtml" title="OpenGL学习脚印：基本图形绘制方式比较（glBegin, glCallList, glVertexPointer, VBO）- 方海龙的书馆" target="_blank" rel="noopener">3</a>: <a href="http://www.360doc.com/content/14/1028/10/19175681_420522404.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/14/1028/10/19175681_420522404.shtml</a>    “OpenGL学习脚印：基本图形绘制方式比较（glBegin, glCallList, glVertexPointer, VBO）- 方海龙的书馆”<br><a href="https://blog.csdn.net/chunyexiyu/article/details/89224004" title="Mac上构建OpenGL红宝书上的triangles程序-春夜喜雨" target="_blank" rel="noopener">4</a>: <a href="https://blog.csdn.net/chunyexiyu/article/details/89224004" target="_blank" rel="noopener">https://blog.csdn.net/chunyexiyu/article/details/89224004</a>    “Mac上构建OpenGL红宝书上的triangles程序-春夜喜雨”</p><h2 id="最后的LoadShaders-cpp"><a href="#最后的LoadShaders-cpp" class="headerlink" title="最后的LoadShaders.cpp"></a>最后的LoadShaders.cpp</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment" spellcheck="true">//#include &lt;GL3/gl3w.h></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"LoadShaders.hpp"</span></span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">// __cplusplus</span><span class="token comment" spellcheck="true">//----------------------------------------------------------------------------</span><span class="token keyword">static</span> <span class="token keyword">const</span> GLchar<span class="token operator">*</span><span class="token function">ReadShader</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> filename <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> WIN32</span>    FILE<span class="token operator">*</span> infile<span class="token punctuation">;</span>    <span class="token function">fopen_s</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>infile<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token string">"rb"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    FILE<span class="token operator">*</span> infile <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span> filename<span class="token punctuation">,</span> <span class="token string">"rb"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">// WIN32</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>infile <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> _DEBUG</span>        std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Unable to open file '"</span> <span class="token operator">&lt;&lt;</span> filename <span class="token operator">&lt;&lt;</span> <span class="token string">"'"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">/* DEBUG */</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">fseek</span><span class="token punctuation">(</span> infile<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SEEK_END <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">ftell</span><span class="token punctuation">(</span> infile <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fseek</span><span class="token punctuation">(</span> infile<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SEEK_SET <span class="token punctuation">)</span><span class="token punctuation">;</span>    GLchar<span class="token operator">*</span> source <span class="token operator">=</span> <span class="token keyword">new</span> GLchar<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">fread</span><span class="token punctuation">(</span> source<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> infile <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span> infile <span class="token punctuation">)</span><span class="token punctuation">;</span>    source<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> GLchar<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//----------------------------------------------------------------------------</span>GLuint<span class="token function">LoadShaders</span><span class="token punctuation">(</span>ShaderInfo<span class="token operator">*</span> shaders<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> shaders <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    GLuint program <span class="token operator">=</span> <span class="token function">glCreateProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ShaderInfo<span class="token operator">*</span> entry <span class="token operator">=</span> shaders<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> entry<span class="token operator">-</span><span class="token operator">></span>type <span class="token operator">!=</span> GL_NONE <span class="token punctuation">)</span> <span class="token punctuation">{</span>        GLuint shader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span> entry<span class="token operator">-</span><span class="token operator">></span>type <span class="token punctuation">)</span><span class="token punctuation">;</span>        entry<span class="token operator">-</span><span class="token operator">></span>shader <span class="token operator">=</span> shader<span class="token punctuation">;</span>        <span class="token keyword">const</span> GLchar<span class="token operator">*</span> source <span class="token operator">=</span> <span class="token function">ReadShader</span><span class="token punctuation">(</span> entry<span class="token operator">-</span><span class="token operator">></span>filename <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> source <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> entry <span class="token operator">=</span> shaders<span class="token punctuation">;</span> entry<span class="token operator">-</span><span class="token operator">></span>type <span class="token operator">!=</span> GL_NONE<span class="token punctuation">;</span> <span class="token operator">++</span>entry <span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">glDeleteShader</span><span class="token punctuation">(</span> entry<span class="token operator">-</span><span class="token operator">></span>shader <span class="token punctuation">)</span><span class="token punctuation">;</span>                entry<span class="token operator">-</span><span class="token operator">></span>shader <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">glShaderSource</span><span class="token punctuation">(</span> shader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>source<span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> source<span class="token punctuation">;</span>        <span class="token function">glCompileShader</span><span class="token punctuation">(</span> shader <span class="token punctuation">)</span><span class="token punctuation">;</span>        GLint compiled<span class="token punctuation">;</span>        <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span> shader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>compiled <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>compiled <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> _DEBUG</span>            GLsizei len<span class="token punctuation">;</span>            <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span> shader<span class="token punctuation">,</span> GL_INFO_LOG_LENGTH<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len <span class="token punctuation">)</span><span class="token punctuation">;</span>            GLchar<span class="token operator">*</span> log <span class="token operator">=</span> <span class="token keyword">new</span> GLchar<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span> shader<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">,</span> log <span class="token punctuation">)</span><span class="token punctuation">;</span>            std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Shader compilation failed: "</span> <span class="token operator">&lt;&lt;</span> log <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> log<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">/* DEBUG */</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">glAttachShader</span><span class="token punctuation">(</span> program<span class="token punctuation">,</span> shader <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>entry<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">glLinkProgram</span><span class="token punctuation">(</span> program <span class="token punctuation">)</span><span class="token punctuation">;</span>    GLint linked<span class="token punctuation">;</span>    <span class="token function">glGetProgramiv</span><span class="token punctuation">(</span> program<span class="token punctuation">,</span> GL_LINK_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>linked <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>linked <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> _DEBUG</span>        GLsizei len<span class="token punctuation">;</span>        <span class="token function">glGetProgramiv</span><span class="token punctuation">(</span> program<span class="token punctuation">,</span> GL_INFO_LOG_LENGTH<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len <span class="token punctuation">)</span><span class="token punctuation">;</span>        GLchar<span class="token operator">*</span> log <span class="token operator">=</span> <span class="token keyword">new</span> GLchar<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">glGetProgramInfoLog</span><span class="token punctuation">(</span> program<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">,</span> log <span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Shader linking failed: "</span> <span class="token operator">&lt;&lt;</span> log <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> log<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">/* DEBUG */</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> entry <span class="token operator">=</span> shaders<span class="token punctuation">;</span> entry<span class="token operator">-</span><span class="token operator">></span>type <span class="token operator">!=</span> GL_NONE<span class="token punctuation">;</span> <span class="token operator">++</span>entry <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">glDeleteShader</span><span class="token punctuation">(</span> entry<span class="token operator">-</span><span class="token operator">></span>shader <span class="token punctuation">)</span><span class="token punctuation">;</span>            entry<span class="token operator">-</span><span class="token operator">></span>shader <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> program<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//----------------------------------------------------------------------------</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">// __cplusplus</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data概念篇DM（二）数据</title>
      <link href="/data-concept-dm-02/"/>
      <url>/data-concept-dm-02/</url>
      
        <content type="html"><![CDATA[<h1 id="Data概念篇DM（二）数据"><a href="#Data概念篇DM（二）数据" class="headerlink" title="Data概念篇DM（二）数据"></a>Data概念篇DM（二）数据</h1><ul><li>参《数据挖掘导论（完整版）》第二章</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><strong>数据集</strong>可以看作<strong>数据对象</strong>的集合。</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p><strong>什么是属性？</strong></p><ul><li><strong>属性</strong>（attribute）是对象的性质或特性，因对象而变，随时间而变。</li><li><strong>测量标度</strong>（measurement scale）是将数值或符号值与对象的属性相关联的规则（函数）。</li></ul></li><li><p><strong>属性类型</strong></p><ul><li>通常将属性的类型称为<strong>测量标度的类型</strong>。</li></ul></li><li><p><strong>属性的不同类型</strong></p><p><img src="./03-01.png" alt="03-01 属性的不同类型"></p></li><li><p><strong>用值的个数描述属性</strong></p><ul><li><strong>离散的</strong>（discrete），二元属性（Binary attribute）</li><li><strong>连续的</strong>（continuous）</li></ul></li><li><p><strong>非对称的属性</strong></p><ul><li>非对称的属性（asymmetric attribute）</li></ul></li></ul><h3 id="数据集的类型"><a href="#数据集的类型" class="headerlink" title="数据集的类型"></a>数据集的类型</h3><ul><li><strong>数据集的一般特性</strong><ul><li>维度（dimensionality）</li><li>稀疏性（sparsity）</li><li>分辨率（resolution）</li></ul></li><li><strong>记录数据</strong><ul><li>事务数据（transaction data）、购物车数据（market basket data）</li><li>数据矩阵</li><li>稀疏数据矩阵：文档-词矩阵（document-term matrix）</li></ul></li><li><strong>基于图形的数据</strong><ul><li>带有对象之间联系的数据：如链接的网页</li><li>具有图形对象的数据</li></ul></li><li><strong>有序的数据</strong><ul><li><strong>时序数据</strong>（sequential）/ <strong>时间数据</strong>（temporal data）</li><li><strong>序列数据</strong>（sequence data）</li><li><strong>时间序列数据</strong>（time series data）</li><li><strong>空间数据</strong></li></ul></li></ul><h2 id="数据质量"><a href="#数据质量" class="headerlink" title="数据质量"></a>数据质量</h2><ul><li>两个问题：<ul><li>数据质量问题的检测和纠正（<strong>数据清理</strong> data cleaning）；</li><li>使用可以容忍低质量数据的算法。</li></ul></li></ul><h3 id="测量和数据收集问题"><a href="#测量和数据收集问题" class="headerlink" title="测量和数据收集问题"></a>测量和数据收集问题</h3><ul><li><strong>测量误差</strong>（measurement error）和<strong>数据收集错误</strong>（data collection error）</li><li><strong>噪声</strong>（测量误差的随机部分）和<strong>伪像</strong>（artifact，更确定性现象结果的数据错误）</li><li><strong>精度</strong>（precision）、<strong>偏倚</strong>（bias）、<strong>准确率</strong>（accuracy）</li><li><strong>离群点</strong>（outlier）、<strong>异常</strong>（anomalous）</li><li><strong>遗漏值</strong><ul><li>处理方法：删除数据对象或属性；估计遗漏值；在分析时忽略遗漏值</li></ul></li><li><strong>不一致的值</strong></li><li><strong>重复</strong>：去重复（deduplication）</li></ul><h3 id="关于应用的问题"><a href="#关于应用的问题" class="headerlink" title="关于应用的问题"></a>关于应用的问题</h3><ul><li><strong>时效性</strong>和<strong>相关性</strong></li><li><strong>抽样偏倚</strong>（sampling bias）</li></ul><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><ul><li>属性（attribute）：特征（feature）、变量（variable）</li></ul><h3 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h3><ul><li><strong>聚集</strong>（aggregation）：将两个或多个对象合并成单个对象。<ul><li>可以看作是删除属性或压缩特定属性不同值个数的过程</li></ul></li><li>动机：<ul><li>数据规约减小数据，减小内存需求和处理时间</li><li>通过高层视图，起到了规范或标度转换的作用</li><li>聚集后行为更加稳定</li></ul></li></ul><h3 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a>抽样</h3><ul><li><strong>抽样</strong>是一种选择数据对象子集进行分析的常用方法，抽样具有代表性。</li><li><strong>抽样方法：</strong><ul><li><strong>简单随机抽样</strong>（sample random sampling）：无放回/有放回</li><li><strong>分层抽样</strong>（stratified sampling）</li></ul></li><li><strong>渐进抽样</strong>（progressive sampling）、<strong>自适应</strong>（adaptive）</li></ul><h3 id="维规约"><a href="#维规约" class="headerlink" title="维规约"></a>维规约</h3><ul><li><strong>维规约</strong>：通过创建新属性，将一些旧属性合并在一起来降低数据集的维度（特征子集选择或特征选择）</li><li><strong>好处</strong><ul><li>使模型更容易理解；</li><li>更容易让数据可视化；</li><li>降低了数据挖掘算法的时间和内存需求。</li></ul></li><li><strong>维灾难</strong>：高维数据，分类准确率降低，聚类质量下降</li><li><strong>维规约的线性代数技术</strong>：主成分分析（Principal Components Analysis, PCA）、奇异值分解（Singular Value Decomposition, SVD）</li></ul><h3 id="特征子集选择"><a href="#特征子集选择" class="headerlink" title="特征子集选择"></a>特征子集选择</h3><ul><li>存在，<strong>冗余特征</strong>、<strong>不相关特征</strong></li><li><strong>理想方法</strong>：将所有可能的特征子集作为感兴趣的数据挖掘算法的输入，然后选取产生最好结果的子集。</li><li><strong>嵌入方法</strong>（embedded approach）：算法本身决定使用哪些属性和忽略哪些属性</li><li><strong>过滤方法</strong>（filter approach）</li><li><strong>包装方法</strong>（wrapper approach）</li></ul><h3 id="特征创建"><a href="#特征创建" class="headerlink" title="特征创建"></a>特征创建</h3><ul><li><strong>特征提取</strong>（feature extraction）：由原始数据创建新的特征集</li><li><strong>映射数据到新的空间</strong><ul><li>傅立叶变换（Fourier transform）、小波变换（wavelet transform）</li></ul></li><li><strong>特征构造</strong></li></ul><h3 id="离散化和二元化"><a href="#离散化和二元化" class="headerlink" title="离散化和二元化"></a>离散化和二元化</h3><ul><li><p><strong>离散化</strong>（discretization）、<strong>二元化</strong>（binarization）</p></li><li><p>连续属性离散化</p><ul><li><strong>非监督离散化</strong><ul><li>等宽（equal width）、等频率（equal frequency）、等深（equal depth）、K均值、目测监测数据</li></ul></li><li><strong>监督离散化</strong><ul><li><strong>熵</strong>（entropy）<ul><li>$e_i=-\sum^k_{j=1}P_{ij}\log_2P_{ij}$</li><li>$e=\sum^n_{i=1}w_ie_i$</li></ul></li></ul></li></ul></li></ul><h3 id="变量转换"><a href="#变量转换" class="headerlink" title="变量转换"></a>变量转换</h3><ul><li><strong>变量转换</strong>（variable transformation）</li><li><strong>简单函数</strong></li><li><strong>规范化</strong>（standardization）或<strong>标准化</strong>（normalization）</li></ul><h2 id="相似性和相异性的度量"><a href="#相似性和相异性的度量" class="headerlink" title="相似性和相异性的度量"></a>相似性和相异性的度量</h2><ul><li>常用<strong>邻近度</strong>（proximity）表示相似性或相异性。</li></ul><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li><strong>定义</strong><ul><li><strong>相似度</strong>（similarity）、<strong>相异度</strong>（dissimilarity）</li></ul></li><li><strong>距离</strong></li></ul><h3 id="简单属性之间的相似度和相异度"><a href="#简单属性之间的相似度和相异度" class="headerlink" title="简单属性之间的相似度和相异度"></a>简单属性之间的相似度和相异度</h3><p><img src="./04-01.png" alt="04-01 简单属性之间的相似度和相异度"></p><h3 id="数据对象之间的相异度"><a href="#数据对象之间的相异度" class="headerlink" title="数据对象之间的相异度"></a>数据对象之间的相异度</h3><ul><li><strong>距离</strong><ul><li><strong>欧几里得距离</strong>（Euclidean distance）：$d(x,y)=\sqrt{\sum^n_{k=1}(x_k-y_k)^2}$</li><li><strong>距离矩阵</strong>（distance matrix）</li><li><strong>闵可夫斯基距离</strong>（Minkowski distance）：$d(x,y)=(\sum^n_{k=1}|x_k-y_k|^r)^{1/r}$<ul><li>$r=1$，汉明距离（Hamming distance）</li><li>$r=2$，欧几里得距离（$L_2$范数）</li><li>$r=\infty$，上确界（$L_{max}$或$L_{\infty}$范数）距离</li></ul></li></ul></li><li><strong>度量</strong>（metric）性质<ul><li>非负性</li><li>对称性</li><li>三角不等式</li></ul></li></ul><h3 id="数据对象之间的相似度"><a href="#数据对象之间的相似度" class="headerlink" title="数据对象之间的相似度"></a>数据对象之间的相似度</h3><ul><li>相似度性质<ul><li>仅当$x=y$时，$s(x,y)=1$。（$0\le s\le1$）</li><li>对于所有x和y，$s(x,y)=s(y,x)$。（对称性）</li></ul></li><li>非对称相似性度量<ul><li>混淆矩阵（confusion matrix）：记录每个字符被分类为自己的次数和被分类为另一个字符的次数</li></ul></li></ul><h3 id="邻近性度量的例子"><a href="#邻近性度量的例子" class="headerlink" title="邻近性度量的例子"></a>邻近性度量的例子</h3><ul><li><strong>二元数据的相似性度量</strong><ul><li><strong>相似系数</strong>（similarity coefficient）</li><li><strong>简单匹配系数</strong>（Simple Matching Coefficient, SMC）<ul><li>$SMC=\frac{值匹配的属性个数}{属性个数}=\frac{f_{11}+f_{00}}{f_{01}+f_{10}+f_{11}+f_{00}}$</li></ul></li><li><strong>Jaccard系数</strong>（Jaccard Cofficient）<ul><li>$J=\frac{匹配的个数}{不涉及0-0匹配的属性个数}=\frac{f_{11}}{f_{01}+f_{10}+f_{11}}$</li></ul></li></ul></li><li><strong>余弦相似度</strong><ul><li><strong>余弦相似度</strong>（cosine similarity）<ul><li>$\cos(x,y)=\frac{x\cdot y}{||x||||y||}$</li><li>$x\cdot y=\sum^n_{k=1}x_ky_k$</li><li>$||x||=\sqrt{\sum^n_{k=1}x^2_k}=\sqrt{x\cdot x}$</li></ul></li></ul></li><li><strong>广义Jaccard系数</strong><ul><li><strong>广义Jaccard系数</strong>又称<strong>Tanimoto系数</strong></li><li>$EJ(x,y)=\frac{x\cdot y}{||x||^2+||y||^2-x\cdot y}$</li></ul></li><li><strong>相关性</strong><ul><li><strong>皮尔森相关</strong>（Pearson’s correlation）系数<ul><li>$corr(x,y)=\frac{covariance(x,y)}{standard_deviation(x)\times standard_deviation(y)}=\frac{s_{xy}}{s_xs_y}$</li><li>$covariance(x,y)=s_{xy}=\frac{1}{n-1}\sum^n_{k-1}(x_k-\overline x)(y_k-\overline y)$</li><li>$standard_deviation(x)=s_x=\sqrt{\frac{1}{n-1}\sum^n_{k=1}(x_k-\overline x)^2}$</li><li>$standard_deviation(y)=s_x=\sqrt{\frac{1}{n-1}\sum^n_{k=1}(y_k-\overline y)^2}$</li></ul></li><li><strong>非线性相关</strong>：如果相关度为0，则两个数据对象的属性之间不存在线性关系，然而，仍然可能存在非线性关系。</li><li><strong>Bregman散度</strong>：损失或失真函数<ul><li>$D(x,y)=\phi(x)-\phi(y)-&lt;\nabla(y),(x-y)&gt;$</li></ul></li></ul></li></ul><h3 id="邻近度计算问题"><a href="#邻近度计算问题" class="headerlink" title="邻近度计算问题"></a>邻近度计算问题</h3><ul><li><strong>距离度量的标准化和相关性</strong><ul><li><strong>Mahalanobid距离：</strong>$mahalanobis(x,y)=(x-y)\sum^{-1}(x-y)^T$</li></ul></li><li><strong>组合异种属性的相似度</strong></li><li><strong>使用权值</strong></li></ul><h3 id="选取正确的邻近性度量"><a href="#选取正确的邻近性度量" class="headerlink" title="选取正确的邻近性度量"></a>选取正确的邻近性度量</h3>]]></content>
      
      
      <categories>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Mining </tag>
            
            <tag> Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data概念篇DM（一）数据挖掘基础概念</title>
      <link href="/data-concept-dm-01/"/>
      <url>/data-concept-dm-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Data概念篇DM（一）数据挖掘基础概念"><a href="#Data概念篇DM（一）数据挖掘基础概念" class="headerlink" title="Data概念篇DM（一）数据挖掘基础概念"></a>Data概念篇DM（一）数据挖掘基础概念</h1><ul><li>参《数据挖掘导论（完整版）》第一章</li></ul><h2 id="什么是数据挖掘？"><a href="#什么是数据挖掘？" class="headerlink" title="什么是数据挖掘？"></a>什么是数据挖掘？</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>数据挖掘是一种<strong>技术</strong>，将<strong>传统的数据分析方法</strong>与<strong>处理大量数据的复杂算法</strong>相结合。</li><li>数据挖掘是在大型数据存储库中，自动地发现有用信息的过程。数据挖掘技术用来探查大型数据库，发现先前未知的有用模式，还可以预测未来观测结果。</li></ul><h3 id="数据挖掘与知识发现"><a href="#数据挖掘与知识发现" class="headerlink" title="数据挖掘与知识发现"></a>数据挖掘与知识发现</h3><ul><li><p>数据挖掘是<strong>数据库中知识发现</strong>（knowledge discovery in database, KDD）不可缺少的一部分，KDD是将未加工的数据转换为有用信息的整个过程，如下图所示，</p><p><img src="./01-01.png" alt="01-01 KDD"></p></li><li><p>各个步骤：</p><ul><li><strong>输入数据：</strong>可以以各种形式存储，可以驻留在集中的数据存储库或分布在多个站点上。</li><li><strong>数据预处理</strong>（preprocessing）：将未加工的输入数据转换成适合分析的形式。<ul><li>包含<strong>融合</strong>来自多个数据源的数据、<strong>清洗</strong>数据以消除<strong>噪声</strong>和<strong>重复</strong>的观测值、<strong>选择</strong>与当前数据挖掘任务相关的记录和特征。</li><li>特征选择、维规约、规范化、选择数据子集</li></ul></li><li><strong>后处理：</strong>将有效的和有用的结果集成到决策支持系统中。<ul><li>可视化；使用统计度量或假设检验，删除虚假的数据挖掘结果。</li></ul></li></ul></li></ul><h2 id="数据问题需要的问题"><a href="#数据问题需要的问题" class="headerlink" title="数据问题需要的问题"></a>数据问题需要的问题</h2><ul><li><strong>可伸缩</strong>（scalable）<ul><li>使用特殊的搜索策略处理指数级搜索问题、实现新的数据结构、非内存算法、使用抽样技术或开发并行和分布算法</li></ul></li><li><strong>高维度</strong></li><li><strong>异种数据和复杂数据</strong></li><li><strong>数据的所有权与分布</strong></li><li><strong>非传统的分析</strong><ul><li>传统的统计方法基于<strong>假设-验证模式</strong></li></ul></li></ul><h2 id="数据挖掘的起源"><a href="#数据挖掘的起源" class="headerlink" title="数据挖掘的起源"></a>数据挖掘的起源</h2><ul><li><strong>统计学</strong>的抽样、估计和假设检验</li><li><strong>人工智能</strong>、<strong>模式识别</strong>和<strong>机器学习</strong>的搜索算法、建模技术和学习理论</li><li>其它领域，包括最优化、进化计算、信息论、信号处理、可视化和信息检索</li><li>其它方面，数据库系统、高性能（并行）计算、分布式技术</li></ul><h2 id="数据挖掘任务"><a href="#数据挖掘任务" class="headerlink" title="数据挖掘任务"></a>数据挖掘任务</h2><ul><li>两大类：<ul><li><strong>预测任务</strong>：根据其它属性的值（<strong>说明变量</strong>或<strong>自变量</strong>），预测特定属性的值（<strong>目标变量</strong>或<strong>因变量</strong>）</li><li><strong>描述任务</strong>：导出概括数据中潜在练习的模式（相关、趋势、聚类、轨迹和异常）</li></ul></li><li><strong>预测建模</strong>（predictive modeling）：以说明变量函数的方式为目标变量建立模型<ul><li><strong>分类</strong>（classification）：预测离散的目标变量</li><li><strong>回归</strong>（regression）：预测连续的目标变量</li></ul></li><li><strong>关联分析</strong>（association analysis）：发现描述数据中强关联特征的模式<ul><li>应用：找出具有相关功能的基因组、识别用户、理解元素之间的联系</li></ul></li><li><strong>聚类分析</strong>（cluster analysis）：发现紧密相关的预测值组群<ul><li>应用：对相关的顾客分组、找出显著影响地球气候的海洋区域、压缩数据</li></ul></li><li><strong>异常检测</strong>（anomaly detection）：识别特征显著不同于其他数据的观测值<ul><li><strong>异常点</strong>（anomaly）或<strong>离群点</strong>（outlier）</li><li>好的异常检测器：高检测率、低误报率</li><li>应用：检测欺诈、网络攻击、疾病的不寻常模式、生物系统扰乱等</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Mining </tag>
            
            <tag> Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data总序篇：介绍与目录</title>
      <link href="/data-preface/"/>
      <url>/data-preface/</url>
      
        <content type="html"><![CDATA[<h1 id="Data总序篇：介绍与目录"><a href="#Data总序篇：介绍与目录" class="headerlink" title="Data总序篇：介绍与目录"></a>Data总序篇：介绍与目录</h1><h2 id="系列介绍"><a href="#系列介绍" class="headerlink" title="系列介绍"></a>系列介绍</h2><h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><ul><li>由于近期计划阅读、学习几本经典书籍，分别与数据挖掘、统计学方法与机器学习相关，所以计划编写一个系列的笔记。</li><li>由于这些内容存在着极多交叉相通的部分，所以希望能将其整合在一个系列之中，避免重复造轮子。</li><li>但另一方面，由于这些内容属于不同的主题，所以架构、展开方式存在着很大的差异，所以此系列的编排也存在着很大的挑战，希望能做好。最终取名为Data，是由于这些内容都与数据相关，所以就简单粗暴地命名了。</li></ul><h3 id="主要书目"><a href="#主要书目" class="headerlink" title="主要书目"></a>主要书目</h3><ul><li>整个系列的笔记，主要对应以下四本书：</li></ul><ol><li>《<a href="https://book.douban.com/subject/5377669/" target="_blank" rel="noopener">数据挖掘导论</a>》</li><li>《<a href="https://book.douban.com/subject/33437381/" target="_blank" rel="noopener">统计学习方法（第2版）</a>》</li><li>《<a href="https://book.douban.com/subject/26708119/" target="_blank" rel="noopener">机器学习</a>》</li><li>《<a href="https://book.douban.com/subject/10750155/" target="_blank" rel="noopener">数学之美</a>》</li></ol><ul><li>这几本书在豆瓣上的评分都在8分以上，而且都作为领域中的经典书籍，希望能尽早啃完了（不知道能多久了，希望不会断片了…）</li></ul><h3 id="编排思路"><a href="#编排思路" class="headerlink" title="编排思路"></a>编排思路</h3><ul><li>本系列计划分为<strong>总序篇</strong>、<strong>概念篇</strong>、<strong>方法篇</strong>和<strong>补充篇</strong>四个不同篇章主题。</li><li><strong>总序篇</strong>：此文，包含系列的介绍和全部目录。</li><li><strong>概念篇</strong>：包含一些概念的内容，如数据挖掘、机器学习、数据等基本概念的介绍，也包含如分类问题、聚类问题、监督学习、强化学习等概念的介绍。</li><li><strong>方法篇</strong>：介绍具体的模型和算法，如kNN模型、决策树模型、神经网络模型等内容。</li><li><strong>补充篇</strong>：一些补充内容，如历史、发展、数学基础等内容。</li></ul><h2 id="系列目录"><a href="#系列目录" class="headerlink" title="系列目录"></a>系列目录</h2><ul><li>持续更新，当前很贫穷。</li></ul><h3 id="总序篇"><a href="#总序篇" class="headerlink" title="总序篇"></a>总序篇</h3><table><thead><tr><th>题目</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://jirehchan.github.io/data-preface/" target="_blank" rel="noopener">Data总序篇：介绍与目录</a></td><td>关于整个Data系列的介绍以及目录信息</td></tr></tbody></table><h3 id="概念篇"><a href="#概念篇" class="headerlink" title="概念篇"></a>概念篇</h3><table><thead><tr><th>题目</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://jirehchan.github.io/data-concept-dm-01/" target="_blank" rel="noopener">Data概念篇DM（一）数据挖掘基础概念</a></td><td>数据挖掘的定义、问题、任务、应用</td></tr><tr><td><a href="https://jirehchan.github.io/data-concept-dm-02/" target="_blank" rel="noopener">Data概念篇DM（二）数据</a></td><td>数据的含义</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="方法篇"><a href="#方法篇" class="headerlink" title="方法篇"></a>方法篇</h3><table><thead><tr><th>题目</th><th>简介</th></tr></thead><tbody><tr><td>暂无</td><td>暂无</td></tr></tbody></table><h3 id="补充篇"><a href="#补充篇" class="headerlink" title="补充篇"></a>补充篇</h3><table><thead><tr><th>题目</th><th>简介</th></tr></thead><tbody><tr><td>暂无</td><td>暂无</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data </tag>
            
            <tag> Preface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记（二）渲染管线、FreeGLUT&amp;GLEW、简单示例</title>
      <link href="/opengl-02/"/>
      <url>/opengl-02/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenGL学习笔记（二）渲染管线、FreeGLUT-amp-GLEW、简单示例"><a href="#OpenGL学习笔记（二）渲染管线、FreeGLUT-amp-GLEW、简单示例" class="headerlink" title="OpenGL学习笔记（二）渲染管线、FreeGLUT&amp;GLEW、简单示例"></a>OpenGL学习笔记（二）渲染管线、FreeGLUT&amp;GLEW、简单示例</h1><h2 id="1-渲染管线"><a href="#1-渲染管线" class="headerlink" title="1. 渲染管线"></a>1. 渲染管线</h2><ul><li>主要整理自<a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" title="LearnOpenGL CN - 你好，三角形" target="_blank" rel="noopener">[1]</a></li></ul><h3 id="图形渲染管线（Graphics-Pipeline）"><a href="#图形渲染管线（Graphics-Pipeline）" class="headerlink" title="图形渲染管线（Graphics Pipeline）"></a>图形渲染管线（Graphics Pipeline）</h3><ul><li><p>OpenGL是一个3D图形库，即其中的所有事物都存储在3D空间中，而屏幕和窗口中则是显示为2D像素，<strong>图形渲染管线</strong>的作用就是实现2D坐标和3D坐标之间的互相转换。有以下两个部分：</p><ul><li>将3D坐标转换为2D坐标；</li><li>将2D坐标转变为实际有色的像素。</li></ul></li><li><p>图形渲染管线的各个阶段的展示图如下：</p><p><img src="./01-01.png" alt="01-01 图形渲染管线"></p></li><li><p><strong>着色器</strong>（Shader）是在渲染管线中，每个阶段上运行处理数据的小程序。OpenGL着色器是用<strong>OpenGL着色器语言</strong>（OpenGL Shading Language, GLSL）写成的。</p></li><li><p>接下来将逐一介绍渲染管线的各个阶段。</p></li></ul><h3 id="顶点数据（Vertex-Data）"><a href="#顶点数据（Vertex-Data）" class="headerlink" title="顶点数据（Vertex Data）"></a>顶点数据（Vertex Data）</h3><ul><li><p>顶点数据作为图形渲染管线的输入，是一系列<strong>顶点</strong>（Vertex）的集合。</p></li><li><p>顶点是一个3D坐标数据的集合，用<strong>顶点属性</strong>（Vertex Attribute）表示。</p></li><li><p>OpenGL中指定的坐标都是3D坐标，但只有在<strong>标准化设备坐标</strong>（Normalized Device Corrdinates NDC，即三个轴坐标都在-1.0到1.0的范围内）范围内的坐标才能呈现在屏幕上。</p><ul><li>标准化设备坐标之后会转化为<strong>屏幕空间坐标</strong>（Screen-space Coordinates），通过<em>glViewport</em>函数提供的数据，进行<strong>视口变换</strong>（Viewport Transform）完成。</li></ul></li><li><p>顶点数据定义后被传入顶点着色器中，会在GPU上创建内存用于存储顶点数据。通过<strong>顶点缓冲对象</strong>（Vertex Buffer Objects VBO）管理此内存，它会在GPU内存中存储大量顶点，然后批量发给显卡。</p></li><li><p><strong>顶点数组对象</strong>（Vertex Array Object, VAO）</p><ul><li>任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。</li></ul><p><img src="./01-02.png" alt="01-02 VAO与VBO"></p></li></ul><h3 id="顶点着色器（Vertex-Shader）"><a href="#顶点着色器（Vertex-Shader）" class="headerlink" title="顶点着色器（Vertex Shader）"></a>顶点着色器（Vertex Shader）</h3><ul><li><strong>顶点着色器</strong>是图形渲染管线的第一个部分，把一个单独的顶点作为输入。主要作用：<ul><li>把3D坐标转换为另一种3D坐标；</li><li>对顶点属性进行一些简单的处理。</li></ul></li></ul><h3 id="图元装配（Primitive-Assembly）"><a href="#图元装配（Primitive-Assembly）" class="headerlink" title="图元装配（Primitive Assembly）"></a>图元装配（Primitive Assembly）</h3><ul><li>将顶点着色器输出的所有顶点作为输入，将所有的点装配成制定图元的形状。</li></ul><h3 id="几何着色器（Geometry-Shader）"><a href="#几何着色器（Geometry-Shader）" class="headerlink" title="几何着色器（Geometry Shader）"></a>几何着色器（Geometry Shader）</h3><ul><li><strong>几何着色器</strong>把图元形式的一系列顶点的集合作为输入，可以通过产生新顶点构造出新的图元来生成其它形状。</li></ul><h3 id="光栅化（Rasterization）"><a href="#光栅化（Rasterization）" class="headerlink" title="光栅化（Rasterization）"></a>光栅化（Rasterization）</h3><ul><li><strong>光栅化</strong>把图元映射成对应的像素，生成片段（Fragment）。在<strong>片段着色器</strong>运行之前，会执行<strong>剪裁</strong>（Clipping）来提升执行效率。</li></ul><h3 id="片段着色器（Fragment-Shader）"><a href="#片段着色器（Fragment-Shader）" class="headerlink" title="片段着色器（Fragment Shader）"></a>片段着色器（Fragment Shader）</h3><ul><li><strong>片段着色器</strong>的主要目的是计算一个像素的最终颜色，也包含3D场景的数据（如光照、阴影、光的颜色等）。</li></ul><h3 id="Alpha测试和混合（Blending）"><a href="#Alpha测试和混合（Blending）" class="headerlink" title="Alpha测试和混合（Blending）"></a>Alpha测试和混合（Blending）</h3><ul><li>此阶段检测片段对应的深度，来判断这个像素对应其它物体的相对位置。也会检查alpha值来对物体进行混合。</li></ul><h2 id="2-FreeGLUT库-amp-GLEW库-配置"><a href="#2-FreeGLUT库-amp-GLEW库-配置" class="headerlink" title="2. FreeGLUT库 &amp; GLEW库 配置"></a>2. FreeGLUT库 &amp; GLEW库 配置</h2><ul><li>以下配置针对Mac上的Xcode配置，如是其他平台其它软件请自行百度，参考<a href="https://www.cnblogs.com/fanghao/p/7559768.html" title="Mac使用Xcode配置openGL -- 潇雨危栏" target="_blank" rel="noopener">[2]</a><a href="https://www.cnblogs.com/leojason/p/9619193.html" title="OpenGL学习之旅01—Xcode+OpenGL环境配置 -- LeoJason" target="_blank" rel="noopener">[3]</a>。（安装主要也是因为课程要求，汗）</li></ul><h3 id="库简介"><a href="#库简介" class="headerlink" title="库简介"></a>库简介</h3><ul><li><strong>FreeGLUT库</strong><ul><li>由于GLUT项目已被废弃（不再维护，无法修改），FreeGLUT是GLUT的一个完全开源替代库。</li></ul></li><li><strong>GLEW库</strong><ul><li>OpenGL扩展库，用于帮助C/C++开发者初始化扩展（OpenGL扩展功能）并书写可移植的应用程序。</li></ul></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p><strong>安装homebrew</strong></p><p>​    由于之前已经安装过了homebrew，是否当时使用的是以下命令已经不太清楚了，如果有问题 ，可以在网上寻找。</p><pre class=" language-shell"><code class="language-shell">$ ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</code></pre></li><li><p><strong>安装FreeGLUT</strong></p><pre class=" language-shell"><code class="language-shell">$ brew install freeglut</code></pre><p>​    安装中可能会提示需要先安装XQuartz，此时同样照着提示来安装，完成后再次brew即可。</p></li><li><p><strong>安装GLEW</strong></p><pre class=" language-shell"><code class="language-shell">$ brew install glew</code></pre><p>​    安装中可能会由于没有读写目录的权限的提示，此时只要按照终端的提示操作之后就可以了。</p></li><li><p><strong>安装后的库</strong></p><p>brew安装的目录在/usr/local/Cellar下，之后在Xcode中的配置会用到。</p></li></ol><h3 id="Xcode中的配置"><a href="#Xcode中的配置" class="headerlink" title="Xcode中的配置"></a>Xcode中的配置</h3><ol><li><p>打开Xcode，新建一个Command Line Tool项目。</p></li><li><p>在Build Settings中的Search Paths加入头文件、库文件搜索路径。</p><p><img src="./02-01.png" alt="02-01 加入搜索路径"></p></li><li><p>在Build Phases中Link Binary With Libraries中加入库</p><p>​    不知为何上步完成后仍是无法搜索到，只能手动添加文件了，另外不要忘了基本库OpenGL.framework哦。</p><p><img src="./02-02.png" alt="02-02 加入库"></p></li></ol><h2 id="3-简单示例"><a href="#3-简单示例" class="headerlink" title="3. 简单示例"></a>3. 简单示例</h2><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><ul><li><p>代码来自计算机图形学课程的讲义，绘制一个简单的三角形。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;GL/glew.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;GL/glut.h></span></span><span class="token keyword">void</span> <span class="token function">doMyInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glClearColor</span><span class="token punctuation">(</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Set the clear color to black</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">mydisplay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glClear</span><span class="token punctuation">(</span> GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Clear the frame buffer</span>    <span class="token function">glColor3f</span><span class="token punctuation">(</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Set current color to green</span>    <span class="token function">glBegin</span><span class="token punctuation">(</span> GL_TRIANGLES<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Draw the triangle</span>        <span class="token function">glVertex2f</span><span class="token punctuation">(</span> <span class="token operator">-</span><span class="token number">0.7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glVertex2f</span><span class="token punctuation">(</span> <span class="token number">0.7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glVertex2f</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Force to display the new drawings immediately</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// initialize</span>    <span class="token function">glutInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitDisplayMode</span><span class="token punctuation">(</span>GLUT_RGB <span class="token operator">|</span> GLUT_SINGLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitWindowSize</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitWindowPosition</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutCreateWindow</span><span class="token punctuation">(</span><span class="token string">"Simple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glewInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">doMyInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//define callback functions</span>    <span class="token function">glutDisplayFunc</span><span class="token punctuation">(</span>mydisplay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutMainLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//main event loop</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="然而。。。"><a href="#然而。。。" class="headerlink" title="然而。。。"></a>然而。。。</h3><ul><li><p>结果是无法成功跑出结果，显示如下：</p><img src="./03-01.png" alt="03-01 失败截图" style="zoom:50%;"></li><li><p>尝试多次后，放弃了，似乎是因为FreeGLUT无法在Mac上编译shader，只能重新改回原生的GLUT.framework了。<strong>（在03中再次证实真的无法使用，还浪费了时间，哭了）</strong></p></li></ul><h3 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h3><ul><li><strong>代码部分</strong><ul><li>将 #include &lt;GL/glut.h&gt; 改为 #include &lt;GLUT/GLUT.h&gt;</li></ul></li><li>Build Phases中改为</li></ul><img src="./03-02.png" alt="03-02 修改后的库增加" style="zoom:75%;"><ul><li><p><strong>运行结果</strong></p><img src="./03-03.png" alt="03-03 运行结果" style="zoom:30%;"><ul><li>关于FreeGLUT的问题，等之后遇到无法解决时再加以考虑了，汗汗，目前只找到<a href="https://blog.csdn.net/fqrq88918329/article/details/50154863" title="MAC OS上使用OpenGL遇到的大坑 -- 热心的李大妈" target="_blank" rel="noopener">[4]</a>。</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]: <a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/</a>    “LearnOpenGL CN - 你好，三角形”<br><a href="https://www.cnblogs.com/fanghao/p/7559768.html" title="Mac使用Xcode配置openGL -- 潇雨危栏" target="_blank" rel="noopener">2</a>: <a href="https://www.cnblogs.com/fanghao/p/7559768.html" target="_blank" rel="noopener">https://www.cnblogs.com/fanghao/p/7559768.html</a>    “Mac使用Xcode配置openGL – 潇雨危栏”<br><a href="https://www.cnblogs.com/leojason/p/9619193.html" title="OpenGL学习之旅01—Xcode+OpenGL环境配置 -- LeoJason" target="_blank" rel="noopener">3</a>: <a href="https://www.cnblogs.com/leojason/p/9619193.html" target="_blank" rel="noopener">https://www.cnblogs.com/leojason/p/9619193.html</a>    “OpenGL学习之旅01—Xcode+OpenGL环境配置 – LeoJason”<br><a href="https://blog.csdn.net/fqrq88918329/article/details/50154863" title="MAC OS上使用OpenGL遇到的大坑 -- 热心的李大妈" target="_blank" rel="noopener">4</a>: <a href="https://blog.csdn.net/fqrq88918329/article/details/50154863" target="_blank" rel="noopener">https://blog.csdn.net/fqrq88918329/article/details/50154863</a>    “MAC OS上使用OpenGL遇到的大坑 – 热心的李大妈”</p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iPad软件个人推荐</title>
      <link href="/else-2019-01-ipadsoftware/"/>
      <url>/else-2019-01-ipadsoftware/</url>
      
        <content type="html"><![CDATA[<h1 id="iPad软件个人推荐"><a href="#iPad软件个人推荐" class="headerlink" title="iPad软件个人推荐"></a>iPad软件个人推荐</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>用iPad来做学习工具已经一个学习多了，鉴于身边有意向购买、使用iPad的人似乎日渐增多，写下此篇小文章来介绍一下我日常使用的几款不错的软件。另外，本人的设备包含iPad（第六代）和Pencil（一代，二代不支持iPad Air）。下面是iPad和pencil的照片（随便乱拍，不要介意，汗汗），另外是不是黑框的比白框的显得更大气、神秘、好看呢，吼吼～</p><p><img src="./01-01.png" alt="01-01 iPad照片"></p></li><li><p>好的，开始正文，本文介绍的软件主要是以下六款（<em>Notability</em>，<em>MindNode</em>，<em>Kindle</em>，<em>PDF Expert</em>，<em>Agenda</em>和iPad自带的<em>日历</em>），<strong>其中Notability, MindNode 和 PDF Expert 都是收费的软件哦</strong>。</p><p><img src="./01-02.png" alt="01-02 软件图标显示"></p></li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Notability"><a href="#1-Notability" class="headerlink" title="1. Notability"></a>1. Notability</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li><em>Notability</em> 主要作为一个<strong>笔记软件</strong>，搭配Pencil能发挥它的价值。不过由于我的课堂笔记一般用<em>MindNode</em>记成思维导图的形式，一些学习笔记则在电脑上用<em>Markdown</em>来记录，所以我的<em>Notability</em>主要用来写留言、打草稿、做会议记录之类的草记。</li></ul><h4 id="喜欢的点"><a href="#喜欢的点" class="headerlink" title="喜欢的点"></a>喜欢的点</h4><ul><li>框选复制：导出后，可以直接粘贴到其它软件变为图片格式，对于一些无法打出来的内容（如公式）还是很方便的选择；</li><li>画笔直线、圆形：长按停留后可以直接变为直线或圆形；</li><li>支持PDF格式：<em>Notability</em>中也可以导入pdf格式图片；</li></ul><h4 id="可能的局限"><a href="#可能的局限" class="headerlink" title="可能的局限"></a>可能的局限</h4><ul><li>无法输入公式，只能手写（不支持MarkDown）；</li></ul><h4 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h4><ul><li><p>下图左图是界面目录的截图，右侧是这学期的计算机图形学课程的图形处理流程的草图。</p><p><img src="./02-01.png" alt="02-01 Notability"></p></li></ul><h3 id="2-MindNode"><a href="#2-MindNode" class="headerlink" title="2. MindNode"></a>2. MindNode</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li><em>MindNode</em>是一款<strong>思维导图工具软件</strong>，帮助绘制思维导图。不过现在App Store中也有了一些新的免费的思维导图软件，像<em>XMind</em>之类的，不过绘制思维导图而言，<em>MindNode</em>是完全够用的，不过如果是新用户，可以先观察一下其它的软件，再做衡量。</li></ul><h4 id="喜欢的点-1"><a href="#喜欢的点-1" class="headerlink" title="喜欢的点"></a>喜欢的点</h4><ul><li>方便、直接的文件夹管理；</li><li>容易、便捷的绘制思维导图操作；</li><li>可以通过iCloud与Mac传输，可以导出其它格式；</li></ul><h4 id="可能的局限-1"><a href="#可能的局限-1" class="headerlink" title="可能的局限"></a>可能的局限</h4><ul><li>无法输入公式，只能以截图格式实现；</li><li>无法在思维导图外写入文本，有提供注释，但没法自己随意写；</li><li>思维导图铺得比较开，不够紧凑，感觉上会有很多闲置空间（效果看下图）；</li></ul><h4 id="软件截图-1"><a href="#软件截图-1" class="headerlink" title="软件截图"></a>软件截图</h4><ul><li><p>下图为<em>MindNode</em>的目录展示：</p><p><img src="./02-02.png" alt="02-02 MindNode 目录展示"></p></li><li><p>下图仍是计算机图形学课程第一章的思维导图展示（其中的加框图片就是从Notability中复制进来的）：</p><p><img src="./02-03.png" alt="02-03 MindNode 绘制图展示"></p></li></ul><h3 id="3-Kindle"><a href="#3-Kindle" class="headerlink" title="3. Kindle"></a>3. Kindle</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><ul><li><strong>电子书阅读器</strong>这个就不用说了，在亚马逊上购买好后，关联账户就可以直接阅读了，方便、快捷、省钱。是否购买主要还是看个人是否对亚马逊的电子书有需求（本人好多书都只看了一小部分，然后就结束了，汗颜）。</li></ul><h4 id="软件截图-2"><a href="#软件截图-2" class="headerlink" title="软件截图"></a>软件截图</h4><ul><li><p>下图，左侧为打开目录，右侧为《高性能MySQL》中的一页。</p><p><img src="./02-04.png" alt="02-04 Kindle"></p></li></ul><h3 id="4-PDF-Expert"><a href="#4-PDF-Expert" class="headerlink" title="4. PDF Expert"></a>4. PDF Expert</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><ul><li><strong>PDF阅读器</strong>，论文、PDF书籍的绝佳阅读软件。</li></ul><h4 id="喜欢的点-2"><a href="#喜欢的点-2" class="headerlink" title="喜欢的点"></a>喜欢的点</h4><ul><li>管理方便，注释、圈画便利，支持pencil直接手写；</li><li>可以双页展示、垂直滚动、水平翻滚；</li></ul><h4 id="可能的局限-2"><a href="#可能的局限-2" class="headerlink" title="可能的局限"></a>可能的局限</h4><ul><li>当PDF不是文件而是图片的时候，标记加下划线就只能一行一行画横线了（其实也还好啦）；</li></ul><h4 id="软件截图-3"><a href="#软件截图-3" class="headerlink" title="软件截图"></a>软件截图</h4><ul><li><p>同样的，左侧是我的Article文件夹下的目录情况，右图是其中一篇论文的打开情况。</p><p><img src="./02-05.png" alt="02-05 PDF Expert"></p></li></ul><h3 id="5-Agenda"><a href="#5-Agenda" class="headerlink" title="5. Agenda"></a>5. Agenda</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><ul><li>制定计划、目标、日志的软件，个人的话，目前日历软件取代了<em>Agenda</em>的一部分功能。</li></ul><h4 id="喜欢的点-3"><a href="#喜欢的点-3" class="headerlink" title="喜欢的点"></a>喜欢的点</h4><ul><li>免费！免费的！</li><li>可以方便的放目标（打勾的图框）；</li><li>能与日历关联，选择一天、一周还是其它的时长；</li></ul><h4 id="可能的局限-3"><a href="#可能的局限-3" class="headerlink" title="可能的局限"></a>可能的局限</h4><ul><li>主体的语言是英语（当然自己可以输入英文）；</li></ul><h4 id="软件截图-4"><a href="#软件截图-4" class="headerlink" title="软件截图"></a>软件截图</h4><ul><li><p>上面是一周的计划，下面是单日的。</p><p><img src="./02-06.png" alt="02-06 Agenda"></p></li></ul><h3 id="6-日历"><a href="#6-日历" class="headerlink" title="6. 日历"></a>6. 日历</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><ul><li>iPad自带的日历软件，最近几周才开始使用，才发现它的魅力——促进时间利用、督促自己（我比较懒，会浪费很多时间）。</li></ul><h4 id="喜欢的点-4"><a href="#喜欢的点-4" class="headerlink" title="喜欢的点"></a>喜欢的点</h4><ul><li>可以与mac、iphone直接关联提醒（由于我妈的iPhone用的是我的Apple ID，所以她也看得到我的，嘤嘤）；</li><li>方便设置时间段的安排，能督促学习，吼吼；</li></ul><h4 id="可能的局限-4"><a href="#可能的局限-4" class="headerlink" title="可能的局限"></a>可能的局限</h4><ul><li>没有更多的功能？</li></ul><h4 id="软件截图-5"><a href="#软件截图-5" class="headerlink" title="软件截图"></a>软件截图</h4><ul><li><p>下图就是展示了啦，安排、安排！（最近几天又开始犯懒不安排了，这不又弄到了凌晨了不是，太难了QAQ）</p><p><img src="./02-07.png" alt="02-07 日历的打开方式"></p></li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li>再说一次，<strong>其中Notability, MindNode 和 PDF Expert 都是收费的软件，收费的软件，收费的软件哦！</strong>另外，这些软件都是直接从App Store中下载的哦。</li><li>另外，软件再好，iPad再好，看了这篇文章你再心动，也未必有用哦！因为没有“用来学习”的觉悟与决心，或许你的iPad最后只能沦为一个看视频、玩游戏的设备了，很多人都这样，不用灰心，反正比手机屏幕大，看视频、玩游戏更快乐不是，嘿嘿～</li><li>最后一件事，国庆快乐～<strong>目标是星辰大海！</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Else </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ipad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记（一）简介&amp;初探</title>
      <link href="/opengl-01/"/>
      <url>/opengl-01/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenGL学习笔记（一）简介-amp-初探"><a href="#OpenGL学习笔记（一）简介-amp-初探" class="headerlink" title="OpenGL学习笔记（一）简介&amp;初探"></a>OpenGL学习笔记（一）简介&amp;初探</h1><h2 id="1-OpenGL"><a href="#1-OpenGL" class="headerlink" title="1. OpenGL"></a>1. OpenGL</h2><h3 id="OpenGL-简介"><a href="#OpenGL-简介" class="headerlink" title="OpenGL 简介"></a>OpenGL 简介</h3><ul><li><strong>OpenGL</strong>（Open Graphics Library，开放式图形库）是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序接口（API），包含了一系列可以操作图形、图像的函数。<a href="https://baike.baidu.com/item/OpenGL/238984?fr=aladdin" title="OpenGL-百度百科" target="_blank" rel="noopener">[1]</a><a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/" title="LearnOpenGL CN-入门" target="_blank" rel="noopener">[2]</a></li><li>OpenGL官网的描述其为”<em>The Industry’s Foundation for High Performance</em>“<a href="https://www.opengl.org" title="OpenGL 官网" target="_blank" rel="noopener">[3]</a>，OpenGL本身并不是一个API，仅仅是一个<strong>由Khronos组织制定并维护的规范</strong>（Specification）。OpenGL规范严格规定了每个函数如何运行，以及其输出输出值，而函数的具体实现，则由OpenGL库的开发者自行决定。<a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/" title="LearnOpenGL CN-入门" target="_blank" rel="noopener">[2]</a></li><li>实际上，通常是<strong>显卡的生产商</strong>开发具体的OpenGL库，如使用Apple系统时，OpenGL库是由Apple自身维护。当OpenGL产生bug时，可以通过<strong>升级显卡驱动</strong>解决。<a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/" title="LearnOpenGL CN-入门" target="_blank" rel="noopener">[2]</a></li></ul><h3 id="OpenGL-相关库"><a href="#OpenGL-相关库" class="headerlink" title="OpenGL 相关库"></a>OpenGL 相关库</h3><ul><li><strong>OpenGL core Library</strong><ul><li>OpenGL核心库</li></ul></li><li><strong>OpenGL Utility Library</strong>（GLU）</li><li><strong>OpenGL Utility Toolkit</strong>（GLUT）<ul><li>提供窗口系统的功能命令</li></ul></li><li><strong>freeglut</strong><ul><li>更新OpenGL的库</li></ul></li><li><strong>OpenGL Extension Wrangler Library</strong>（GLEW）</li></ul><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><ul><li>1980s，软件开发人员为每种图形硬件编写自定义的借口和驱动程序。</li><li>1990初，SGI成为工作站3D图形领域的领导者，其IRIS GL API成为事实上的行业标准。其竞争对手（Sun、惠普、IBM）通过扩展PHIGS标准也将3D硬件投入市场，SCI 将 IRIS GL API转变为一项开放标准，即OpenGL。</li><li>1992年，SCI领导OpenGL架构审查委员会（OpenGL ARB）的创建。</li><li>1995年，微软发布Direct3D成为OpenGL的主要竞争对手。</li><li>1997年12月17日，微软和SGI发起华氏温标项目，统一OpenGL和Direct3D接口。1998年，惠普加入，但项目于1999年停止。</li><li>2006年7月，OpenGL架构评审委员会将OpenGL API标准的控制权交给Khronos Group。 </li></ul><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>此部分主要参考<a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/" title="LearnOpenGL CN-入门" target="_blank" rel="noopener">[2]</a></li></ul><h4 id="核心模式-与-立即渲染模式"><a href="#核心模式-与-立即渲染模式" class="headerlink" title="核心模式 与 立即渲染模式"></a>核心模式 与 立即渲染模式</h4><ul><li><strong>立即渲染模式</strong>（Immediate mode, 固定渲染管线）：早期OpenGL使用，绘制图形容易使用和理解，但是效率较低。</li><li><strong>核心模式</strong>（Core-profile）：从OpenGL3.2后开始使用，移除了旧的特性，迫使用户使用现代的函数。</li></ul><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul><li><strong>扩展</strong>（Extension）：支持扩展，未成为规范之前，显卡公司提出的新特性或优化可以通过扩展的方式在驱动中实现。</li></ul><h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><ul><li>OpenGL自身是一个巨大的<strong>状态机</strong>（State Machine）：一系列的变量描述此时的OpenGL如何运行。OpenGL的状态通常被称为OpenGL上下文。</li><li>使用OpenGL时，使用<strong>状态设置函数</strong>（State-changing Function）与 <strong>状态使用函数</strong>（State-using Function）来进行操作。</li></ul><h2 id="2-初次尝试"><a href="#2-初次尝试" class="headerlink" title="2. 初次尝试"></a>2. 初次尝试</h2><ul><li>以下内容针对Mac上的Xcode（版本 Xcode11），其他平台的搭建还请参考网上的其他资源（MAC XCODE已自带GLUT.framework和OpenGL.framework，所以初次尝试不涉及“复杂”的环境配置）。以下内容参考<a href="https://www.cnblogs.com/chenyangsocool/p/5357691.html" title="Max Xcode 下配置OpenGL - chenyangsocool - 博客园" target="_blank" rel="noopener">[4]</a></li></ul><ol><li><p>打开Xcode，新建一个Command Line Tool项目。</p><p><img src="./02-01.png" alt="01-01 新建Command Line Tool项目"></p></li><li><p>添加GLUT.framework和OpenGL.framework</p><ol><li><p>点击Build Phases, Link Binary with Libraries</p><p><img src="./02-02.png" alt="01-02 添加库位置"></p></li><li><p>寻找、添加GLUT.framework和OpenGL.framework</p><p><img src="./02-03.png" alt="01-03 添加framework"></p></li><li><p>完成后效果</p><p><img src="./02-04.png" alt="01-04 添加后效果"></p></li></ol></li><li><p>进入main.cpp编写Demo代码并运行</p><ol><li><p>Demo代码</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//绘制一个正方形</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;GLUT/GLUT.h></span></span><span class="token keyword">void</span> <span class="token function">myDisplay</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glRectf</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glutInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitDisplayMode</span><span class="token punctuation">(</span>GLUT_RGB <span class="token operator">|</span> GLUT_SINGLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitWindowPosition</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitWindowSize</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutCreateWindow</span><span class="token punctuation">(</span><span class="token string">"第一个 OpenGL 程序"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutDisplayFunc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myDisplay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutMainLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>运行效果</p><img src="./02-05.png" alt="01-05" style="zoom:30%;"></li><li><p>由于在macOS 10.9、10.14 后一些命令被废止，会出现以下提示信息，下一篇会使用GLEW库。</p><p><img src="./02-06.png" alt="01-06 XCODE中的提示"></p></li></ol></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]: <a href="https://baike.baidu.com/item/OpenGL/238984?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/OpenGL/238984?fr=aladdin</a>    “OpenGL-百度百科”<br>[2]: <a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/</a>    “LearnOpenGL CN-入门”<br>[3]: <a href="https://www.opengl.org" target="_blank" rel="noopener">https://www.opengl.org</a>    “OpenGL 官网”<br>[4]: <a href="https://www.cnblogs.com/chenyangsocool/p/5357691.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenyangsocool/p/5357691.html</a>    “Max Xcode 下配置OpenGL - chenyangsocool - 博客园”</p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019论文阅读笔记&lt;03&gt;</title>
      <link href="/article-2019-03/"/>
      <url>/article-2019-03/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-论文阅读笔记-lt-03-gt"><a href="#2019-论文阅读笔记-lt-03-gt" class="headerlink" title="2019 论文阅读笔记 &lt;03&gt;"></a>2019 论文阅读笔记 &lt;03&gt;</h1><h2 id="【基本信息】"><a href="#【基本信息】" class="headerlink" title="【基本信息】"></a>【基本信息】</h2><ul><li><strong>论文题目：</strong><a href="http://papers.nips.cc/paper/7181-attention-is-all-you-need" target="_blank" rel="noopener">Attention is all you need</a></li><li><strong>作者：</strong>Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Adian N. Gomez, Łukasz Kaiser, Illia Polosukhin </li><li><strong>出版：</strong> <a href="http://papers.nips.cc/book/advances-in-neural-information-processing-systems-30-2017" target="_blank" rel="noopener">Advances in Neural Information Processing Systems 30 (NIPS 2017)</a></li><li><strong>日期：</strong>Submitted on 12 Jun 2017 （*<a href="https://arxiv.org/abs/1706.03762v1" target="_blank" rel="noopener">v1</a>*）, last revised 6 Dec 2017 （this version, v5）</li><li><strong>简介：</strong>此论文针对以往NLP中使用RNN结构和endoder-decoder结构无法并行、速度慢的问题，基于<strong>注意力机制</strong>提出了一种称为<strong>Transformer</strong>的网络结构。</li></ul><h2 id="【词汇术语】"><a href="#【词汇术语】" class="headerlink" title="【词汇术语】"></a>【词汇术语】</h2><h3 id="专业词汇-术语"><a href="#专业词汇-术语" class="headerlink" title="专业词汇/术语"></a>专业词汇/术语</h3><ul><li><strong>sequence transduction models</strong></li><li><strong>attention mechanism:</strong> 注意力机制</li></ul><h3 id="语言词汇"><a href="#语言词汇" class="headerlink" title="语言词汇"></a>语言词汇</h3><ul><li><strong>push the boundaries</strong></li><li><strong>integral</strong> 必需的</li></ul><h3 id="模型-模式-算法"><a href="#模型-模式-算法" class="headerlink" title="模型/模式/算法"></a>模型/模式/算法</h3><ul><li><strong>softmax</strong><ul><li>softmax用于多分类过程中，它将多个神经元的输出，映射到（0,1）区间内，可以看成概率来理解，从而来进行多分类</li><li>$S_i=\frac{e^i}{\sum_je^j}$</li></ul></li></ul><h2 id="【论文笔记】"><a href="#【论文笔记】" class="headerlink" title="【论文笔记】"></a>【论文笔记】</h2><h3 id="「简介前言」"><a href="#「简介前言」" class="headerlink" title="「简介前言」"></a>「简介前言」</h3><h4 id="当前缺陷"><a href="#当前缺陷" class="headerlink" title="当前缺陷"></a>当前缺陷</h4><ul><li><strong>RNN</strong><ul><li>前后状态的依赖性导致无法并行，在较长的词序时运行缓慢</li></ul></li><li><strong>当前努力</strong><ul><li>分解（factorization tricks）, 条件计算（conditional computation）</li><li><em>Neural GPU<em>，</em>ByteNet</em> 和 <em>ConvS2S</em></li><li>按序计算的限制仍然存在</li></ul></li></ul><h4 id="注意力机制（Attention-Mechanisms）"><a href="#注意力机制（Attention-Mechanisms）" class="headerlink" title="注意力机制（Attention Mechanisms）"></a>注意力机制（Attention Mechanisms）</h4><ul><li><strong>注意力机制</strong>（Attention Mechanisms）<ul><li>各种序列模型建模和转换模型中的一个组成部分（<em>an integral part of compelling sequence modeling and transduction models in various tasks</em>）</li><li>可以不用考虑在输入输出序列中的距离而允许建模</li><li>在少量情况，和循环网络结合使用</li></ul></li><li><strong>自注意力机制</strong>（Self-attention，intra-attention）<ul><li>把输入序列上不同位置的信息联系起来计算一个句子的表示内容</li></ul></li></ul><h3 id="「Transformer模型」"><a href="#「Transformer模型」" class="headerlink" title="「Transformer模型」"></a>「Transformer模型」</h3><h4 id="Encoder-Decoder"><a href="#Encoder-Decoder" class="headerlink" title="Encoder-Decoder"></a>Encoder-Decoder</h4><ul><li><p><strong>结构图</strong></p><p><img src="./03-01the-transformer-model-architecture.png" alt="03-01the-transformer-model-architecture"></p></li><li><p><strong>Encoder</strong></p><ul><li>由6个基本层堆叠</li><li>每层含有两个子层：<ul><li>注意力机制（<em>multi-head self-attention mechanism</em>）</li><li>全连接前向网络（<em>simple, position-wise fully connected feed-forward network</em>）</li></ul></li><li>在两个子层中都有剩余连接（<em>residual connection</em>）和层标准化（<em>layer normalization</em>）<ul><li>子层的输出：$LayerNorm(x+Sublayer(x))$</li></ul></li></ul></li><li><p><strong>Decoder</strong></p><ul><li>在encoder的输出外再增加了一层注意力机制</li><li>掩饰（<em>masking</em>）<ul><li>确保每个位置的预测只基于前面已知位置的词</li></ul></li></ul></li></ul><h4 id="注意力机制（Attention）"><a href="#注意力机制（Attention）" class="headerlink" title="注意力机制（Attention）"></a>注意力机制（Attention）</h4><ul><li><p><strong>注意力机制</strong></p><ul><li>将一个查找和一组键值对映射到正确的输出（<em>mapping a query and a set of key-value pairs to an output</em>）</li></ul><p><img src="./03-02tow-attention.png" alt="03-02tow-attention"></p></li><li><p><strong>Scaled Dot-Product Attention</strong></p><ul><li>$Attention(Q,K,V)=softmax(\frac{QK^T}{\sqrt{d_k}})V$</li><li>$d_k$：keys的维度；$d_v$：value的维度</li><li>$Q$：查询矩阵；$K$：keys的矩阵；$V$：values的矩阵</li></ul></li><li><p><strong>Multi-Head Attention</strong></p><ul><li>$MultiHead(Q,K,V)=Concat(head_1,…,head_h)W^{\bigcirc}$</li><li>$head_i=Attention(QW_i^Q,KW_i^K,VW_i^V)$</li></ul></li><li><p>文章使用的注意力机制</p><ul><li>Multi-Head Attention，三个方面：</li><li>Encoder-Decoder Attention层<ul><li>查询来自前一个decoder层，允许decoder的每个位置都能关注输入的所有位置</li></ul></li><li>Encoder层中的Self-attention层<ul><li>在self-attention层中所有的key、value和query都来自前一层的encoder，encoder的每个位置都能关注前一层输出的所有位置。</li></ul></li><li>Decoder层中的Self-attention层</li></ul></li></ul><h4 id="Position-wise-Feed-Forward-Networks"><a href="#Position-wise-Feed-Forward-Networks" class="headerlink" title="Position-wise Feed-Forward Networks"></a>Position-wise Feed-Forward Networks</h4><ul><li>每一层都有一个<strong>fukky connected feed-forward network</strong><ul><li>$FNN(x)=\max(0,xW_1+b_1)W_2+b_2$</li><li>两个线性转换，中间一个ReLU</li></ul></li></ul><h4 id="Embeddings-and-Softmax"><a href="#Embeddings-and-Softmax" class="headerlink" title="Embeddings and Softmax"></a>Embeddings and Softmax</h4><h4 id="位置编码（Positional-Encoding）"><a href="#位置编码（Positional-Encoding）" class="headerlink" title="位置编码（Positional Encoding）"></a>位置编码（Positional Encoding）</h4><ul><li>不使用递归结构和卷积结构，引入位置编码来使用输入顺序信息</li><li><strong>位置编码：</strong><ul><li>$PE_{(pos,2i)}=\sin(pos/10000^{2i/d_{model}})$</li><li>$PE_{(pos,2i+1)}=\cos(pos/10000^{2i/d_{model}})$</li><li>$pos$: position; $i$: dimension</li></ul></li><li>使用sin版本，因为它允许序列用到更长</li></ul><h3 id="「为什么使用自注意力机制」"><a href="#「为什么使用自注意力机制」" class="headerlink" title="「为什么使用自注意力机制」"></a>「为什么使用自注意力机制」</h3><ul><li>三个方面比较其与递归结构、卷积结构<ul><li>每层的计算复杂度（<em>total computational complexity per layer</em>）</li><li>能被并行计算的数量（<em>the amount of computation that can be parallelized</em>）</li><li>网络中长范围以来的路径长度（<em>the path length between long-range dependencies in the network</em>）</li></ul></li></ul><h3 id="「实验与结论」"><a href="#「实验与结论」" class="headerlink" title="「实验与结论」"></a>「实验与结论」</h3><ul><li>同前文，不加以赘述，有兴趣可以自行查看论文以及相关代码。</li></ul><h2 id="「小记总结」"><a href="#「小记总结」" class="headerlink" title="「小记总结」"></a>「小记总结」</h2><ul><li>论文中为提高并行能力，引入注意力机制代替递归结构和卷积结构，用位置编码来体现句子顺序信息。换种思路实现位置表示，NICE～是否还有其他方法，或者还有其他的耗时处理可以用更为简洁的方法来代替处理呢？</li></ul>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Article </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019论文阅读笔记&lt;02&gt;</title>
      <link href="/article-2019-02/"/>
      <url>/article-2019-02/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-论文阅读笔记-lt-02-gt"><a href="#2019-论文阅读笔记-lt-02-gt" class="headerlink" title="2019 论文阅读笔记 &lt;02&gt;"></a>2019 论文阅读笔记 &lt;02&gt;</h1><h2 id="【基本信息】"><a href="#【基本信息】" class="headerlink" title="【基本信息】"></a>【基本信息】</h2><ul><li><strong>论文题目：</strong><a href="https://www.aclweb.org/anthology/D14-1181/" target="_blank" rel="noopener">Convolutional Neural Networks for Sentence Classification</a></li><li><strong>作者：</strong>Yoon Kim</li><li><strong>组织：</strong>New York University</li><li><strong>出版：</strong>Association for Computational Linguistics</li><li><strong>关联：</strong>Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)</li><li><strong>日期：</strong>October 2014</li><li><strong>简介：</strong>此论文在CNN上使用词向量处理自然语言的问题，将词向量与深度学习（NLP与卷积神经网络）结合，并构建了一个简单的CNN模型进行实验，指出了词向量是神经网络对于自然语言处理的一个重要部分<em>（unsupervised pre-training of word vectors is an important ingredient in deep learning for NLP）</em>。</li></ul><h2 id="【词汇术语】"><a href="#【词汇术语】" class="headerlink" title="【词汇术语】"></a>【词汇术语】</h2><h3 id="专业词汇-术语"><a href="#专业词汇-术语" class="headerlink" title="专业词汇/术语"></a>专业词汇/术语</h3><ul><li><strong>tanh</strong>: hyperbolic tangent, 双曲正切函数</li><li><strong>pooling:</strong> 池化层，集中特征</li><li><strong>Regularization:</strong> 正则化<ul><li>给损失函数加一个正则化项</li><li><strong>l2-norms</strong></li></ul></li></ul><h3 id="语言词汇"><a href="#语言词汇" class="headerlink" title="语言词汇"></a>语言词汇</h3><ul><li><strong>utilize:</strong> 利用</li><li><strong>disentangle:</strong> 摆脱</li></ul><h3 id="模型-模式-算法"><a href="#模型-模式-算法" class="headerlink" title="模型/模式/算法"></a>模型/模式/算法</h3><ul><li>$\circ$: the element-wise multiplication operator<ul><li>数组对应元素相乘</li></ul></li><li><strong>Bernoulli random variables</strong>：伯努利随机变量<ul><li>01分布：$P(X=1)=p,\ P(x=1)=1-p$</li></ul></li><li><strong>norm:</strong> 范数<ul><li>$l_2-norms(||w||_2)$: 第二范数，欧几里得范数<ul><li>$||w||_2=\sqrt{x_1^2+x_2^2+…+x_n^2}$</li></ul></li></ul></li></ul><h2 id="【论文笔记】"><a href="#【论文笔记】" class="headerlink" title="【论文笔记】"></a>【论文笔记】</h2><h3 id="「简介内容」"><a href="#「简介内容」" class="headerlink" title="「简介内容」"></a>「简介内容」</h3><ul><li><strong>深度学习</strong>（Deep Learning）：当时主要应用于计算机视觉、语音识别，在自然语言处理方面，则用于特征分类上。</li><li><strong>词向量</strong>（Word Vectors）</li><li><strong>卷积神经网络</strong>（Convolutional neural networks, CNN）<ul><li>利用卷积过滤器层</li><li>最早用于计算机视觉</li><li>在语义分析上展现出能力</li></ul></li></ul><h3 id="「模型」"><a href="#「模型」" class="headerlink" title="「模型」"></a>「模型」</h3><h4 id="模型结构图"><a href="#模型结构图" class="headerlink" title="模型结构图    "></a>模型结构图    <img src="./02-01cnn-model-architecture.png" alt="CNN Model Architecture"></h4><h4 id="变量信息"><a href="#变量信息" class="headerlink" title="变量信息"></a>变量信息</h4><ul><li>$x_i$: $k$维词向量句子中的第$i$个词语</li><li>$x_{1:n}$: 长度为n的句子</li><li>$w$: 长度为$h$的窗口</li><li>特征: $c_i=f(w\cdot x_{i:i+h-1}+b)$<ul><li>$f$: 非线性函数</li><li>$b$: 偏移</li></ul></li><li>$\hat{c}=\max{c}$</li></ul><h4 id="各层信息"><a href="#各层信息" class="headerlink" title="各层信息"></a>各层信息</h4><ul><li><strong>池化层</strong>：max-pooling方法</li><li><strong>全连接层</strong>：softmax</li></ul><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><ul><li>正则化用于防止过拟合，常见是在损失函数中加入正则项（L1、L2正则化），本文采用的是DropOut方法。</li><li><strong>Dropout</strong><ul><li>训练中随机删掉隐藏层的一半节点进行学习，之后再对另一半节点进行一轮学习，最终将权重除以2。</li><li>减少了神经元间的依赖性，降低了过拟合，提高了准确率。</li></ul></li></ul><h3 id="「实验结论」"><a href="#「实验结论」" class="headerlink" title="「实验结论」"></a>「实验结论」</h3><ul><li>实验方法、结果不再重复，有兴趣可以自行阅读论文。</li><li>最重要的一点是，该论文指出词向量是神经网络对于自然语言处理的一个重要部分（<em>Our results add to the well-established evidence that unsupervised pre-training of word vectors is an important ingredient in deep learning for NLP.</em>）。</li></ul><h2 id="【小记总结】"><a href="#【小记总结】" class="headerlink" title="【小记总结】"></a>【小记总结】</h2><ul><li>此论文作为CNN与NLP结合的开山之作，虽然模型简单，但却极具价值和意义。创造性、拓展性的思维和能力，急需。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Article </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019论文阅读笔记&lt;01&gt;</title>
      <link href="/article-2019-01/"/>
      <url>/article-2019-01/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-论文阅读笔记-lt-01-gt"><a href="#2019-论文阅读笔记-lt-01-gt" class="headerlink" title="2019 论文阅读笔记 &lt;01&gt;"></a>2019 论文阅读笔记 &lt;01&gt;</h1><h2 id="【基本信息】"><a href="#【基本信息】" class="headerlink" title="【基本信息】"></a>【基本信息】</h2><ul><li><strong>论文题目：</strong> <em><a href="https://ieeexplore.ieee.org/document/7372153" target="_blank" rel="noopener">Entropy-Based Term Weighting Schemes for Text Categorization in VSM</a></em></li><li><strong>作者：</strong>Tao Wang ; Yi Cai ; Ho-fung Leung ; Zhiwei Cai ; Huaqing Min</li><li><strong>出版：</strong> <a href="https://ieeexplore.ieee.org/xpl/conhome/7372093/proceeding" target="_blank" rel="noopener">2015 IEEE 27th International Conference on Tools with Artificial Intelligence (ICTAI)</a></li><li><strong>日期：</strong>9-11 Nov. 2015 / 07 Jan 2016</li><li><strong>标签：</strong>TC、VSM</li><li><strong>简介：</strong>此论文分析了用于文本分类任务的一些权重法（如无监督学习中的$tf,tf\cdot idf,BM25$ 与监督学习中的$rf,iqf\cdot qf\cdot icf,tf\cdot gr$等），指出这些已有模式在文本分类中存在的问题，并提出了两种新的基于熵的权重法（$tf\cdot dc$ 和 $tf\cdot bdc$），提升了术语的辨别力与文本分类任务的完成。</li></ul><h2 id="【词汇术语】"><a href="#【词汇术语】" class="headerlink" title="【词汇术语】"></a>【词汇术语】</h2><h3 id="专业词汇-术语"><a href="#专业词汇-术语" class="headerlink" title="专业词汇/术语"></a>专业词汇/术语</h3><ul><li><strong>TC</strong> （Text Categorization）：文本分类</li><li><strong>VSM</strong> （Vector Space Model）：向量空间模型</li><li><strong>IR</strong> （Information Retrieval）：信息检索</li><li><strong>unsupervised</strong> &amp; <strong>supervised</strong>：无监督、监督</li><li><strong>Contingency Table</strong> 情形分析表<ul><li><strong>positive category （PC）</strong> ：正类</li><li><strong>negative category （NC）</strong>：负类</li></ul></li></ul><h3 id="语言词汇"><a href="#语言词汇" class="headerlink" title="语言词汇"></a>语言词汇</h3><ul><li><strong>state-of-the-art</strong>：当前最好的</li></ul><h3 id="模型-模式-算法"><a href="#模型-模式-算法" class="headerlink" title="模型/模式/算法"></a>模型/模式/算法</h3><ul><li><strong>KNN</strong> （k-Nearest Neighbor）：邻近算法</li><li><strong>SVM</strong> （Support Vector Machine）：支持向量机</li><li>$tf$：<strong>Term Frequency</strong> 词频<ul><li>$词频(TF)=某个词在文章中的出现次数$</li><li>$词频(TF)=\frac{某个词在文章中的出现次数}{文章的总词数}$</li><li>$词频(TF)=\frac{某个词在文章中的出现次数}{该文出现次数最多的词的出现次数}$</li><li>Variants: $\log(tf),\log(tf+1),log(tf)+1,…$</li></ul></li><li>$idf$: <strong>Inverse document frequency</strong> 逆文本频率指数<ul><li>$逆文档频率(IDF)=\log(\frac{语料库的文档总数}{包含该词的文档数+1})$</li><li>$df$: <strong>document frequency</strong></li><li>包含词条的文档越小，$idf$越大</li></ul></li><li>$dc$: <strong>distributional concentration</strong><ul><li>$dc(t)=1-\frac{H(t)}{\log(|C|)}=1+\frac{\sum^{|C|}_{i=1}\frac{f(t,c_i)}{f(t)}\log{\frac{f(t,c_i)}{f(t)}}}{\log{|C|}}$</li></ul></li><li>$rf$: <strong>relevance frequency</strong>, $rf=\frac{a}{c}$</li><li>$cf$: <strong>category frequency</strong>, 出现的类别越少，值越大</li><li>$bdc$: <strong>balanced distributional concentration</strong><ul><li>$bdc(t)=1-\frac{BH(t)}{\log(|C|)}=1+\frac{\sum^{|C|}_{i=1}\frac{p(t|c_i)}{\sum^{|C|}_{i=1}p(t|c_i)}\log{\frac{p(t|c_i)}{sum^{|C|}_{i=1}p(t|c_i)}}}{\log{|C|}}$</li></ul></li></ul><h2 id="【论文笔记】"><a href="#【论文笔记】" class="headerlink" title="【论文笔记】"></a>【论文笔记】</h2><h3 id="「已有方法-—-无监督学习方法」"><a href="#「已有方法-—-无监督学习方法」" class="headerlink" title="「已有方法 —- 无监督学习方法」"></a>「已有方法 —- 无监督学习方法」</h3><h4 id="无监督学习（unsupervised）"><a href="#无监督学习（unsupervised）" class="headerlink" title="无监督学习（unsupervised）"></a>无监督学习（unsupervised）</h4><ul><li><strong>含义：</strong>无先验知识（无标签）的学习</li><li><strong>常见模式：</strong>$tf,tf\cdot idf,BM25 $</li></ul><h4 id="缺点问题"><a href="#缺点问题" class="headerlink" title="缺点问题"></a>缺点问题</h4><ul><li><strong>【由于】</strong>关注于词出现的次数，而忽略了训练<em>文档（documents）<em>的</em>类别标签（category labels）</em></li><li><strong>【导致】</strong><ul><li><em>词语（term）</em>能区别文档的差异，但不能区别类别的差异</li><li>在文本分类任务中，不足以衡量词语对文档类别的<em>辨别能力（discriminating power）</em></li></ul></li></ul><h3 id="「已有方法-—-监督学习方法」"><a href="#「已有方法-—-监督学习方法」" class="headerlink" title="「已有方法 —- 监督学习方法」"></a>「已有方法 —- 监督学习方法」</h3><h4 id="监督学习（supervised）"><a href="#监督学习（supervised）" class="headerlink" title="监督学习（supervised）"></a>监督学习（supervised）</h4><ul><li><strong>含义：</strong>利用已知类别的样本进行学习</li><li><strong>常见模式：</strong>$rf,iqf\cdot qf\cdot icf,tf\cdot gr$</li></ul><h4 id="缺点问题-1"><a href="#缺点问题-1" class="headerlink" title="缺点问题"></a>缺点问题</h4><ul><li><strong>缘由：</strong>大部分监督学习用到了情形分析表中的正类（PC）和负类（NC）</li><li><strong>【由于】</strong>在<em>多类别的情况（multi-class case）</em>中，正类只有一个类，而负类是多个类的集合</li><li><strong>【导致】</strong>负类中产生了<em>信息损失（information loss）</em></li></ul><h4 id="已有优化仍然存在的问题"><a href="#已有优化仍然存在的问题" class="headerlink" title="已有优化仍然存在的问题"></a>已有优化仍然存在的问题</h4><ul><li><em>正类和负类的分离问题 （PC/NC-split based schemes）</em>仍然存在，使得无法有效区别类别。</li><li><em>一种基于统计置信区间的模式（a scheme based on statistical confidence intervals）</em><ul><li>过于复杂难以实现</li></ul></li></ul><h3 id="「基于熵的权重法」"><a href="#「基于熵的权重法」" class="headerlink" title="「基于熵的权重法」"></a>「基于熵的权重法」</h3><h4 id="基于熵的权重法（entropy-based-term-weighting-schemes）"><a href="#基于熵的权重法（entropy-based-term-weighting-schemes）" class="headerlink" title="基于熵的权重法（entropy- based term weighting schemes）"></a>基于熵的权重法（entropy- based term weighting schemes）</h4><ul><li><strong>观点</strong><ul><li>利用负类中的具体类别帮助提升辨别力</li><li><em>更高浓度（higher concentration）</em>的词语具有更强的辨别能力</li><li>在类别层面有更高浓度分布的词语的熵更小</li></ul></li><li>熵值越小，辨别能力越强</li></ul><h4 id="模式1-Distribution-Concentration"><a href="#模式1-Distribution-Concentration" class="headerlink" title="模式1: Distribution Concentration"></a>模式1: Distribution Concentration</h4><ul><li><strong>模式</strong>：$dc$, distribution concentration</li><li><strong>计算公式：</strong> $dc(t)=1-\frac{H(t)}{\log(|C|)}=1+\frac{\sum^{|C|}_{i=1}\frac{f(t,c_i)}{f(t)}\log{\frac{f(t,c_i)}{f(t)}}}{\log{|C|}}$<ul><li>$|C|$: 类别数量</li><li>$f(t,c_i)$: 表示词语 $t$ 在类别 $c_i$ 中出现的频率，这里使用 $df(t,c_i)$</li><li>$f(t)$: 词语 $t$ 在所有类别出现的频数和</li><li>$H(t)$: 词语 $t$ 在语料库中类别的熵，$H(t)\in [0,\log|C|]$</li></ul></li><li><strong>特征优势</strong><ul><li>词语的权重基于在类别中词语的全局分布，而不是依赖于已有的类别正类。</li><li>因此，不需要已有的正类标签就可以进行分类。</li></ul></li><li><strong>缺陷</strong><ul><li>缺少类别的优先级信息（不同种类文档的长度不同，会导致熵的计算产生偏差）<ul><li>$bdc$模式解决此问题</li></ul></li></ul></li></ul><h4 id="模式2-Balanced-Distributional-Concentration"><a href="#模式2-Balanced-Distributional-Concentration" class="headerlink" title="模式2: Balanced Distributional Concentration"></a>模式2: Balanced Distributional Concentration</h4><ul><li><strong>模式</strong>：$bdc$, balanced distributional concentration</li><li><strong>计算公式：</strong> $bdc(t)=1-\frac{BH(t)}{\log(|C|)}=1+\frac{\sum^{|C|}_{i=1}\frac{p(t|c_i)}{\sum^{|C|}_{i=1}p(t|c_i)}\log{\frac{p(t|c_i)}{sum^{|C|}_{i=1}p(t|c_i)}}}{\log{|C|}}$</li><li><strong>特征优势</strong><ul><li>解决了 $dc$ 模式存在的问题</li></ul></li></ul><h3 id="「实验结果」"><a href="#「实验结果」" class="headerlink" title="「实验结果」"></a>「实验结果」</h3><ul><li>此处对于实验的数据、内容、结论不做详细描述，有兴趣可以自行查看论文。</li></ul><h2 id="【小记总结】"><a href="#【小记总结】" class="headerlink" title="【小记总结】"></a>【小记总结】</h2><ul><li>2019论文博客整理的第一篇，希望能坚持，不足之处还请谅解。许多的英文词汇转为中文总有些怪异的感觉，就保留在中文词后面了。</li><li>此论文指出了过往文本分类任务中一些模式（scheme, 这个词翻译成模式也觉得读起来不太顺口，汗）的缺陷，无法很好地利用标签信息、区别类别差异，因而引入了熵的概念。一种角度来说，也是更充分地利用“压榨”已有信息（无监督学习模式忽略了类别标签，PC/NC的监督学习模式则忽略了NC中的类别差异），挖掘、压榨、充分利用全部信息，促进更好的分类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Article </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019论文阅读列表</title>
      <link href="/article-2019-00/"/>
      <url>/article-2019-00/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读列表-2019"><a href="#论文阅读列表-2019" class="headerlink" title="论文阅读列表-2019"></a>论文阅读列表-2019</h1><h2 id="在读-已读列表"><a href="#在读-已读列表" class="headerlink" title="在读/已读列表"></a>在读/已读列表</h2><ol><li><a href="https://ieeexplore.ieee.org/document/7372153" target="_blank" rel="noopener">Entropy-Based Term Weighting Schemes for Text Categorization in VSM</a></li><li><a href="https://www.aclweb.org/anthology/D14-1181/" target="_blank" rel="noopener">Convolutional Neural Networks for Sentence Classification</a></li><li><a href="http://papers.nips.cc/paper/7181-attention-is-all-you-need" target="_blank" rel="noopener">Attention is All you Need</a></li><li><a href="http://kns.cnki.net/kcms/detail/61.1167.g3.20190910.1730.010.html" target="_blank" rel="noopener">黄炜,黄建桥,李岳峰.基于BiLSTM-CRF的涉恐信息实体识别模型研究</a></li><li>Neural Architectures for Named Entity Recognition</li><li>文本自动生成研究进展与趋势</li></ol><h2 id="候选列表"><a href="#候选列表" class="headerlink" title="候选列表"></a>候选列表</h2><ol><li>Man Lan, Chew Lim Tan, Jian Su, and Yue Lu. Supervised and traditional term weighting methods for automatic text categorization. <em>Pattern Analysis and Machine Intelligence, IEEE Transactions on</em>, 31(4):721–735, 2009.</li><li>Xinghua Lu, Bin Zheng, Atulya Velivelli, and ChengXiang Zhai. Enhancing text categorization with semantic-enriched representation and training data augmentation. <em>Journal of the American Medical Informatics Association</em>, 13(5):526–535, 2006.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Article </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
