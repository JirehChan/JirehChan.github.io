<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2020论文阅读笔记&lt;01&gt;</title>
      <link href="/article-2020-01/"/>
      <url>/article-2020-01/</url>
      
        <content type="html"><![CDATA[<h1 id="2020论文阅读笔记-lt-01-gt"><a href="#2020论文阅读笔记-lt-01-gt" class="headerlink" title="2020论文阅读笔记 &lt;01&gt;"></a>2020论文阅读笔记 &lt;01&gt;</h1><h2 id="【基本信息】"><a href="#【基本信息】" class="headerlink" title="【基本信息】"></a>【基本信息】</h2><ul><li><strong>论文题目：</strong><a href="https://www.researchgate.net/publication/327336071_Towards_a_Better_Metric_for_Evaluating_Question_Generation_Systems" target="_blank" rel="noopener">Towards a Better Metric for Evaluating Question Generation Systems</a></li><li><strong>作者：</strong>Preksha Nema, Mitesh M. Khapra</li><li><strong>日期：</strong>August 2018</li><li><strong>标签：</strong>AQG、NLG</li><li><strong>简介：</strong>本文分析了传统NLG评价指标（BLEU、METEOR、NIST、ROUGE）在AQG问题上的效果，通过在噪声问题上与人工评分的比较，指出这些传统指标无法准确、有效地反映生成问题的好坏。本文的作者用可回答性（answerability）来反映一个生成的问题的优劣，并提出了利用不同词性（关联内容词、命名实体、问题类型、功能词）加权与传统指标相结合的新指标，使得新指标更加接近人工结果。</li></ul><h2 id="【论文概要】"><a href="#【论文概要】" class="headerlink" title="【论文概要】"></a>【论文概要】</h2><h3 id="1-研究问题"><a href="#1-研究问题" class="headerlink" title="1. 研究问题"></a>1. 研究问题</h3><p>a. 传统的自然语言生成（NLG）指标在自动问题生成（AQG）方面是否仍然有效？</p><p>b. 如何来衡量或分析这些指标的有效性或好坏？</p><p>c. 如何创造一个更符合AQG问题需要的新的指标？</p><h3 id="2-传统的指标"><a href="#2-传统的指标" class="headerlink" title="2. 传统的指标"></a>2. 传统的指标</h3><h4 id="a-BLEU"><a href="#a-BLEU" class="headerlink" title="a. BLEU"></a>a. BLEU</h4><ul><li>一种基于精度（precision）的评估指标。</li><li>考虑n-gram的形式：$p_n=\frac{\sum_{c\in candidates}\sum_{n-gram\in c}Count_{clip}(n-gram)}{\sum_{c’\in candidates}\sum_{n-gram’\in c’}Count_{clip}(n-gram’)}$</li><li>举例：<ul><li><strong>candidate:</strong> the cat sat on the mat</li><li><strong>reference:</strong> the cat is on the mat</li><li>$p_1=\frac{5}{6}$, $p_2=\frac{3}{5}$, $p_3=\frac{1}{4}$, $p_4=\frac{0}{3}$</li></ul></li></ul><h4 id="b-METEOR"><a href="#b-METEOR" class="headerlink" title="b. METEOR"></a>b. METEOR</h4><ul><li><p>考虑了精度和召回率（recall），也考虑词性、同义词等问题，也能给以功能词和内容词的权重。</p></li><li><p>是基于单精度的加权调和平均数和单子召回率的调和平均。</p></li><li><p>$$<br>惩罚系数\ Pen=\gamma(\frac{ch}{m})^\theta \<br>F_{mean}=\frac{P_mR_m}{\alpha P_m+(1-\alpha)R_m} \<br>P_m=\frac{|m|}{\sum_kh_k(c_i)} \<br>R_m=\frac{|m|}{\sum_kh_k(s_{ij})} \<br>METEOR=(1-Pen)F_{mean}<br>$$</p></li></ul><h4 id="c-NIST"><a href="#c-NIST" class="headerlink" title="c. NIST"></a>c. NIST</h4><ul><li>是标准BLEU的一个变体。</li><li>给在语料库中低频的词增高权重。</li></ul><h4 id="d-ROUGE"><a href="#d-ROUGE" class="headerlink" title="d. ROUGE"></a>d. ROUGE</h4><ul><li>自动摘要方面的指标，通过统计翻译的摘要与人工生成的标准摘要的重叠基本单元（n元语法、词序列和词对）的数目，来评价摘要的质量。</li></ul><h3 id="3-评价指标好坏的方法"><a href="#3-评价指标好坏的方法" class="headerlink" title="3. 评价指标好坏的方法"></a>3. 评价指标好坏的方法</h3><ul><li>从已有的三个主流问题生成数据库中选出数据：<ul><li>SQuAD：阅读理解数据库（约500文章，100k的问题）</li><li>WikiMovies：电影知识图谱（约43k实体，9种关系，100k的问题）</li><li>VQA：图片问题数据库（265,016图片，平均每张图5.4个问题）</li></ul></li><li>对问题随机进行四类噪声处理：<ul><li>删除功能词（如be, do, can, shall, will, have, let, make等词）</li><li>删除命名实体</li><li>删除内容词（如killed/married）</li><li>更改提问类型（who, what, which, how, why, when, where, 7-Wh）</li></ul></li><li>人工对这些噪声处理后的问题进行评价，分为五类<ul><li>重要信息缺失，不可能回答</li><li>大部分重要信息缺失，无法回答</li><li>一些重要信息缺失，答案不确定</li><li>大部分重要信息保留，可以推导回答</li><li>全部重要信息保留，完全可以回答</li></ul></li><li>通过指标的数据结果和人工结果的比较，来评价指标的合理性、有效性。</li></ul><h3 id="4-新的指标"><a href="#4-新的指标" class="headerlink" title="4. 新的指标"></a>4. 新的指标</h3><ul><li>将词汇分为四类：<ul><li>关联内容词（relevant content words）</li><li>命名实体（named entities）</li><li>问题类型（question types）</li><li>功能词（function words）</li></ul></li><li>计算四类词的加权精度和召回率<ul><li>$P_{avg}=\sum_iw_i\frac{c(S_i)}{|l_i|}$</li><li>$R_{avg}=\sum_iw_i\frac{S_i}{|r_i|}$</li></ul></li><li>调和平均计算可回答性（answerability）<ul><li>$Answerability=2\frac{P_{avg}R_{avg}}{P_{avg}+R_{avg}}$</li></ul></li><li>与现有指标进行加权<ul><li>$Q-BLEU4=\delta Answerability+(1-\delta)BLEU4$</li></ul></li></ul><h3 id="5-结果结论"><a href="#5-结果结论" class="headerlink" title="5. 结果结论"></a>5. 结果结论</h3><ul><li>新的指标更为接近人工评分。</li><li>对于不同的数据集，权重效果不同。</li><li>仍有很大的空间。</li></ul><h2 id="【收获小结】"><a href="#【收获小结】" class="headerlink" title="【收获小结】"></a>【收获小结】</h2><ol><li>本文虽然针对问题生成问题，但主要是分析评价指标，不涉及生成方法，所以读起来还是蛮轻松、开心的，嘿嘿。</li><li>问题生成问题和传统的翻译之类的文本生成问题有很大的不同，传统指标的不适用是显然的，但本文团队通过人工评分的对比来评价传统指标，并能从数据的分析中发现问题，提出一种可行的新的指标思路，这是很可取的一种方法。</li><li>此文似乎没能解决一个问题：现在的可回答性是基于人工就问题本身的分析，而到底能否从原文（知识图谱或图片）中得出答案，还是这个问题虽然合理但无法从原材料中找出答案（或者说问题与原材料的相关性）似乎目前模型仍是未能解决的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Article </tag>
            
            <tag> QG </tag>
            
            <tag> NLG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020论文阅读列表</title>
      <link href="/article-2020-00/"/>
      <url>/article-2020-00/</url>
      
        <content type="html"><![CDATA[<h1 id="2020论文阅读列表"><a href="#2020论文阅读列表" class="headerlink" title="2020论文阅读列表"></a>2020论文阅读列表</h1><p>​    2019年后半由于其他事物的忙碌，所以没有怎么看论文，所以重新开始了，从2019年12月8日进入新的部分了。</p><ol><li>Towards a Better Metric for Evaluating Question Generation Systems</li></ol>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Article </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data方法篇（一）决策树</title>
      <link href="/data-model-01/"/>
      <url>/data-model-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Data方法篇（一）决策树"><a href="#Data方法篇（一）决策树" class="headerlink" title="Data方法篇（一）决策树"></a>Data方法篇（一）决策树</h1><ul><li>对应《数据挖掘导论（完整版）》第4章、《机器学习》第4章、《统计学习方法》第5章。</li></ul><h2 id="1-决策树模型"><a href="#1-决策树模型" class="headerlink" title="1. 决策树模型"></a>1. 决策树模型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><strong>决策树</strong>（Decision Tree）是一种基本的分类与回归方法。<ul><li>可以认为是if-then规则的集合、定义在特征空间与类空间与类空间上的条件概率分布。</li></ul></li><li><strong>主要优点：</strong>模型具有可读性，分类速度快。</li><li>学习时，利用训练数据，根据<strong>损失函数最小化</strong>的原则建立决策树模型。</li></ul><h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p><img src="./01-01.png" alt="01-01 决策树示意图"></p><ul><li><strong>「元素」</strong><ul><li><strong>叶结点（left node）或终结点（terminal node）：</strong>决策结果</li><li><strong>内部结点（internal node）或非终止结点（non-terminal node）：</strong>属性测试条件</li></ul></li></ul><h3 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h3><ul><li><p><strong>本质</strong>：是<strong>从训练数据集中归纳出一组分类规则</strong>。</p></li><li><p>决策树学习使用<strong>损失函数</strong>，通常是正则化的极大似然函数，决策树学习的策略是<strong>以损失函数为目标函数的最小化</strong>。</p></li><li><p><strong>三个关键步骤：</strong> <strong>特征选择</strong>（划分选择）、<strong>决策树的生成</strong>和<strong>决策树的修剪</strong>。</p><ul><li>决策树的生成对应于模型的<strong>局部</strong>选择，决策树的剪枝对应于模型的<strong>全局</strong>选择。</li><li>特征选择是在决策树的生成过程之中使用，而修剪是可以在生成前后都可以进行的。</li></ul></li><li><p><strong>常用的算法：</strong>ID3、C4.5与CART</p></li></ul><h2 id="2-特征选择"><a href="#2-特征选择" class="headerlink" title="2. 特征选择"></a>2. 特征选择</h2><ul><li><strong>特征选择</strong>（划分选择）是决策树学习的关键，即如何选择最优划分属性。特征选择在于选取对训练数据具有分类能力的特征，即提高结点的<strong>纯度</strong>（purtiy）。</li><li>以下是用于特征选择常用的几种指标：<strong>信息增益</strong>、<strong>信息增益比</strong>、<strong>基尼指数</strong></li></ul><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><ul><li><strong>信息熵</strong>（information entropy）：度量样本集合纯度最常用的一种指标。<ul><li>样本集合$D$中第k类样本所占的比例为$p_k(k=1,2,..,|y|)$，则D的信息熵定义为：<ul><li>$Ent(D)=-\sum^{|y|}_{k=1}p_k\log_2p_k$</li></ul></li><li>$Ent(D)$的值越小，则$D$的纯度越高</li></ul></li><li><strong>信息增益</strong>（information gain）<ul><li>属性a对样本集D进行划分所获的”信息增益“<ul><li>$Gain(D,a)=Ent(D)-\sum^V_{v=1}\frac{|D^v|}{|D|}Ent(D^v)$</li></ul></li><li>一般而言，信息增益越大，则意味着使用属性a来进行划分所获得的“纯度提升”越大。</li><li><strong>存在的问题：</strong>偏向于选择取值较多的特征的问题。</li></ul></li></ul><h3 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h3><ul><li><strong>信息增益比</strong>（增益率，information gain ratio）<ul><li>$Gain_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}$</li><li><strong>固有值</strong>（intrinsic value）：$IV(a)=-\sum^V_{v=1}\frac{|D|^v}{|D|}\log_2(\frac{|D^v|}{|D|})$</li></ul></li><li><strong>缺陷：</strong>增益率准则对可取数目较少的属性有所偏好<ul><li>C4.5中使用启发式算法，先从候选划分属性中选出信息增益高于平均水平的属性，再从中选择增益率最高的最高的</li></ul></li></ul><h3 id="基尼系数"><a href="#基尼系数" class="headerlink" title="基尼系数"></a>基尼系数</h3><ul><li><strong>基尼系数</strong>（Gini index）：被CART决策树使用<ul><li>$Gini(D)=\sum^{|y|}<em>{k=1}\sum</em>{k’\neq k}p_kp_{k’}=1-\sum^{|y|}_{k=1}p_k^2$</li><li>$Gini(D)$反应了从数据集D中随机抽取两个样本，其类别标记不一致的概率。</li><li>$Gini(D)$越小，则数据集D的纯度越高</li></ul></li><li>属性a的基尼指数定义为：<ul><li>$Gini_index(D,a)=\sum^V_{v=1}\frac{|D^v|}{|D|}Gini(D^v)$</li></ul></li><li>选择划分后基尼指数最小的属性作为最优划分属性，即$a_*=\arg \min_{a\in A}Gini_index(D,a)$</li></ul><h2 id="3-决策树的生成"><a href="#3-决策树的生成" class="headerlink" title="3. 决策树的生成"></a>3. 决策树的生成</h2><ul><li>由于搜索空间是指数规模的，找出最佳决策树在计算上是不可行的。所以人们开发了一些有效的算法来构造<strong>次最优决策树</strong>。这些算法通常都采用<strong>贪心策略</strong>，采取一系列的<strong>局部最优策略</strong>来构造决策树。</li></ul><h3 id="Hunt-算法"><a href="#Hunt-算法" class="headerlink" title="Hunt 算法"></a>Hunt 算法</h3><ul><li><strong>Hunt算法</strong>通过将训练记录相继划分成较纯的子集，以递归方式建立决策树，是许多决策树算法的基础，包括ID3、C4.5和CART。</li><li><strong>算法：</strong>设$D_t$是与结点t关联的训练记录集，而$y={y_1,y_2,…,y_c}$是类标签<ul><li>如果$D_t$中所有记录都属于同一个类$y_t$，则$t$是叶节点，用$y_t$表示</li><li>如果$D_t$中包含属于多个类的记录，则选择一个<strong>属性测试条件</strong>，将记录划分成较小的子集。对于测试条件的每个输出，创建一个子女结点，并根据测试结果将$D_t$中的记录分布到子女结点中。然后，对于每个子女结点，递归地调用该算法。</li></ul></li><li><strong>补充附加条件：</strong>处理特殊情况<ul><li>当创建的子女结点为空，即不存在与这些结点相关联的记录时，则该结点为叶结点，类标号为父结点上训练记录的多数类。</li><li>当与$D_t$相关联的所有记录都具有相同的属性值，无法划分，但类又不同时，标号记为与结点相关联的训练记录中的多数类。</li></ul></li></ul><h3 id="ID3-算法"><a href="#ID3-算法" class="headerlink" title="ID3 算法"></a>ID3 算法</h3><ul><li><p><strong>ID3算法</strong>的核心是在决策树各个节点上应用<strong>信息增益</strong>准则选择特征，递归地构建决策树。</p><ul><li>相当于用极大似然法进行概率模型的选择。</li></ul></li><li><p><strong>算法</strong>：</p><ul><li><p><strong>输入：</strong>训练数据集$D$，特征集$A$阈值$\epsilon $</p></li><li><p><strong>输出：</strong>决策树$T$</p><ol><li><p>若$D$中所有实例属于同一类$C_k$，则$T$为单结点树，并将类$C_k$作为该结点的类标记，返回$T$；</p></li><li><p>若$A=\phi$，则$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$；</p></li><li><p>否则，计算$A$中各特征对$D$的<strong>信息增益</strong>，选择<strong>信息增益最大的特征</strong>$A_g$</p><p>$Gain(D,a)=Ent(D)-\sum^V_{v=1}\frac{|D^v|}{|D|}Ent(D^v)$；</p></li><li><p>如果$A_g$的信息增益小于阈值$\epsilon$，则置$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$；</p></li><li><p>否则，对$A_g$的每一可能值$a_i$，依$A_g=a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子结点，由结点及其子结点构成树$T$，返回$T$；</p></li><li><p>对第$i$个结点，以$D_i$作为训练集，以$A-{A_g}$为特征集，递归地调用1~5步，得到子树$T_i$，返回$T_i$。</p></li></ol></li></ul></li></ul><h3 id="C4-5-算法"><a href="#C4-5-算法" class="headerlink" title="C4.5 算法"></a>C4.5 算法</h3><ul><li><strong>C4.5 算法</strong>在生成过程中用<strong>信息增益比</strong>来选择特征，其它步骤相同。</li><li><strong>信息增益比：</strong>$Gain_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}$<ul><li><strong>固有值</strong>（intrinsic value）：$IV(a)=-\sum^V_{v=1}\frac{|D|^v}{|D|}\log_2(\frac{|D^v|}{|D|})$</li></ul></li></ul><h3 id="CART-算法"><a href="#CART-算法" class="headerlink" title="CART 算法"></a>CART 算法</h3><ul><li><strong>分类与回归树</strong>（classification and regression tree, CART）模型，是<strong>广泛的决策树学习方法</strong>。同样由<strong>特征选择</strong>、<strong>树的生成</strong>和<strong>剪枝</strong>组成，既可以用于分类也可以用于回归。</li><li><strong>组成</strong>：<ul><li><strong>生成</strong>：基于训练数据集生成决策树，生成的决策树要尽量大；</li><li><strong>剪枝</strong>：用<strong>验证数据集</strong>对已生成的树进行剪枝并选择最优子树，用<strong>损失函数最小</strong>作为剪枝的标准。</li></ul></li><li><strong>生成</strong><ul><li><strong>回归树：</strong>平方误差最小化准则<ul><li><strong>平方误差：</strong>$\sum_{x_i\in R_{m}}(y_i-f(x_i))^2$</li><li>寻找最优<strong>切分变量</strong>（splitting variable）、<strong>切分点</strong>（splitting point），即求解：<ul><li>$\min_{j,s}[\min_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2+\min_{c_2}\sum_{x_i\in R_2(j,s)}(y_i-c_2)^2]$</li><li>$R_1(j,s)={x|x^{(j)}\le s}$；$R_2(j,s)={x|x^{(j)}&gt; s}$</li></ul></li></ul></li><li><strong>分类树：</strong>基尼指数最小化准则<ul><li><strong>基尼指数最小化</strong><ul><li>$Gini_index(D,a)=\sum^V_{v=1}\frac{|D^v|}{|D|}Gini(D^v)$</li></ul></li></ul></li></ul></li><li><strong>剪枝</strong><ul><li><strong>两步</strong><ul><li><strong>剪枝，形成一个子树序列</strong>（关于损失函数参照下一节剪枝内容，来便于理解）<ul><li>计算<strong>损失函数</strong>：$C_\alpha(T)=C(T)+\alpha |T|$</li><li>将$\alpha$从小增大，形成一系列的区间$[\alpha_i,\alpha_{i+1})$，得到对应区间的最优子树$T_i$</li><li>对$T_0$的任意内部结点$t$<ul><li>以$t$为单结点树的损失函数：$C_\alpha(t)=C(t)+\alpha$</li><li>以$t$为根结点的子树$T_t$的损失函数：$C_\alpha(T_t)=C(T_t)+\alpha|T_t|$</li><li>$\alpha=\frac{C(t)-C(T_t)}{|T_t|-1}$，即$C_\alpha(T_t)=C_\alpha(t)$时，$T_t$与$t$具有相同的损失函数，而$t$的结点少，因此$t$比$T_t$更可取，对$T_t$进行剪枝</li><li>因此，<ul><li>$g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}$，表示剪枝后<strong>整体损失函数减少的程度</strong></li><li>将$\alpha_k=\alpha,T_k=T$，不断剪枝下去，直到根结点。</li></ul></li></ul></li></ul></li><li><strong>在得到的子树序列$T_0,T_1,…,T_n$中通过交叉验证选取最优子树</strong><ul><li>利用独立的验证数据集，测试子树序列中各棵子树的平方误差或基尼指数，最小的被认为是最优的决策树。</li></ul></li></ul></li><li><strong>步骤</strong><ol><li>设$k=0,T=T_0$。</li><li>设$\alpha=+\infty$。</li><li>自下而上地对各内部结点$t$计算$C(T_t)$，$|T_t|$以及$g(t)$和$\alpha$<ul><li>$T_t$为以$t$为根结点的子树，$C(T_t)$为对训练数据的预测误差，$|T_t|$是$T_t$的叶结点个数</li><li>$g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}$，$\alpha=\min(\alpha,g(t))$</li></ul></li><li>对$g(t)=\alpha$的内部结点$t$进行剪枝，并对叶结点$t$以多数表决法决定其类，得到树$T$。</li><li>设$k=k+1,\alpha_k=\alpha,T_k=T$</li><li>如果$T_k$不是由根结点及两个叶结点构成的树，则回到步骤（2）；否则令$T_k=T_n$</li><li>采用交叉验证法在子树序列$T_0,T_1,…,T_n$中选取最优子树$T_\alpha$</li></ol></li></ul></li></ul><h2 id="4-剪枝处理"><a href="#4-剪枝处理" class="headerlink" title="4. 剪枝处理"></a>4. 剪枝处理</h2><ul><li>在上一节的CART算法中已经提及了它的剪枝处理，在本节将对剪枝处理本身进行一些描述。这里主要做一些描述性的介绍，不再进行具体细化的描述，不清楚可以自行寻找一些例子。</li><li><strong>剪枝</strong>（pruning）是决策树学习算法应对<strong>过拟合</strong>的主要手段，可以通过主动去掉一些分支来降低过拟合的风险，基本策略有“<strong>预剪枝</strong>“（prepruning）和“<strong>后剪枝</strong>“（postpruning）两种。</li><li><strong>预剪枝</strong>是指在<strong>决策树生成过程中</strong>，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树<strong>泛化性能</strong>的提升则停止划分，并将当前结点标记为叶结点；<strong>后剪枝</strong>则是先从训练集<strong>生成一棵完整的决策树</strong>，然后<strong>自底向上</strong>地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能的提升，则将该子树替换为叶结点。</li><li><strong>剪枝方法</strong>：极小化决策树整体的损失函数（loss function）或代价函数（cost function）来实现。<ul><li><strong>损失函数：</strong>$C_\alpha(T)=C(T)+\alpha |T|$<ul><li>$C(T)$：对训练数据的预测误差，即模型与训练数据的拟合程度（如基尼指数）</li><li>$|T|$：子树的叶结点个数，即模型复杂度</li><li>$\alpha\ge0$：参数，参数$\alpha$权衡训练数据的拟合程度与模型的复杂程度<ul><li>较大：较简单的模型；较小：较复杂的模型</li><li>$\alpha=0$：只考虑模型与训练数据的拟合程度，不考虑模型的复杂程度</li></ul></li></ul></li><li>剪枝，就是<strong>当$\alpha$确定时，选择损失函数最小的模型</strong>，即损失函数最小的子树。</li></ul></li><li>决策树生成学习<strong>局部</strong>的模型，而决策树剪枝学习<strong>整体</strong>的模型。</li></ul><h2 id="5-其它相关内容"><a href="#5-其它相关内容" class="headerlink" title="5. 其它相关内容"></a>5. 其它相关内容</h2><ul><li>还有一些内容与决策树相关，但对决策树的基础而言不显得十分重要，所以不再介绍，只是提及词汇，有兴趣可以参考三本书中的内容。包括，<strong>连续值与缺失值的处理</strong>（《机器学习》4.4、《数据挖掘（导论）完整版》）、<strong>多变量决策树</strong>（《机器学习》4.5、《数据挖掘（导论））。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data </tag>
            
            <tag> Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试（三）黑白盒测试练习</title>
      <link href="/software-test-03/"/>
      <url>/software-test-03/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试（三）黑白盒测试练习"><a href="#软件测试（三）黑白盒测试练习" class="headerlink" title="软件测试（三）黑白盒测试练习"></a>软件测试（三）黑白盒测试练习</h1><ul><li>内容来自老师的课堂练习，偷偷留下。</li></ul><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><p>​        用等价类划分法和边界值法设计一个“日期检查功能”的测试用例，输入为6位数字字符，前四位表示年份，后两位表示月份，限定从1990年1月到2049年12月。</p><h3 id="【答案】"><a href="#【答案】" class="headerlink" title="【答案】"></a>【答案】</h3><ul><li><p><strong>等价类</strong></p><p><img src="./01-01.png" alt="01-01 等价类划分"></p></li><li><p><strong>测试用例</strong></p><table><thead><tr><th>用例编号</th><th>输入值</th><th>覆盖的等价类编号</th><th>合理输出值</th></tr></thead><tbody><tr><td>1</td><td>201910</td><td>（1）</td><td>正确</td></tr><tr><td>2</td><td>2019</td><td>（2）</td><td>提示位数错误</td></tr><tr><td>3</td><td>2019A1</td><td>（3）</td><td>提示存在非法字符</td></tr><tr><td>4</td><td>192911</td><td>（4）</td><td>提示年份过小</td></tr><tr><td>5</td><td>208011</td><td>（5）</td><td>提示年份过大</td></tr><tr><td>6</td><td>201900</td><td>（6）</td><td>提示月份过小</td></tr><tr><td>7</td><td>201914</td><td>（7）</td><td>提示月份过大</td></tr></tbody></table></li><li><p><strong>边界值</strong></p><ul><li>（1）数字6位</li><li>（2）年份：1990</li><li>（3）年份：2049</li><li>（4）月份：01</li><li>（5）月份：02</li></ul></li><li><p><strong>边界值测试用例</strong></p><p><img src="./01-02.png" alt="01-02 边界值测试用例"></p></li></ul><h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><h3 id="【题目】-1"><a href="#【题目】-1" class="headerlink" title="【题目】"></a>【题目】</h3><p>​    对以下伪代码绘制程序框图、程序流图，进行判定-条件、条件组合、路径覆盖、基本路径覆盖测试，设计测试用例：</p><pre class=" language-pascal"><code class="language-pascal">DIM a<span class="token punctuation">,</span>b As IntegerDIM c As Integer<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> b<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">then</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">then</span>        c <span class="token operator">=</span> a<span class="token operator">+</span>b    <span class="token keyword">else</span> c<span class="token operator">=</span>c<span class="token number">+1</span>    <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token keyword">else</span> c<span class="token operator">=</span>c<span class="token number">+2</span><span class="token keyword">end</span> <span class="token keyword">if</span></code></pre><h3 id="【答案】-1"><a href="#【答案】-1" class="headerlink" title="【答案】"></a>【答案】</h3><ul><li><p><strong>程序框图</strong></p><p><img src="./02-01.png" alt="02-01 程序框图"></p></li><li><p><strong>程序流图</strong></p><p><img src="./02-02.png" alt="02-02 程序流图"></p></li><li><p><strong>判定-条件</strong></p><ul><li><p>执行路径可以不用写，写的话帮助分析路径走法，保证判定、条件被覆盖到</p><p><img src="./02-03.png" alt="02-03 判定-条件用例设计"></p></li></ul></li><li><p><strong>条件组合</strong></p><ul><li><p>条件组合：</p><ul><li>1: $T_1T_2$</li><li>2: $T_1-T_2$</li><li>3: $-T_1T_2$</li><li>4: $-T_1-T_2$</li><li>5: $T_3$</li><li>6: $-T_3$</li></ul></li><li><p>用例设计：</p><table><thead><tr><th>测试用例</th><th>a,b,c</th><th>执行路径</th><th>覆盖条件</th><th>预期结果</th></tr></thead><tbody><tr><td>1</td><td>1,1,1</td><td>bdfg</td><td>1，5</td><td>2</td></tr><tr><td>2</td><td>1,1,-1</td><td>bceg</td><td>1，6</td><td>0</td></tr><tr><td>3</td><td>1,-1,1</td><td>ah</td><td>2</td><td>3</td></tr><tr><td>4</td><td>-1,1,1</td><td>ah</td><td>3</td><td>3</td></tr><tr><td>5</td><td>-1,-1,1</td><td>ah</td><td>4</td><td>3</td></tr></tbody></table></li></ul></li><li><p><strong>路径覆盖</strong></p><ul><li><p>路径分析：</p><ul><li>$ah+b(ce+df)g=ah+bceg+bdfg$ （共三条）</li></ul></li><li><p>测试用例：</p><table><thead><tr><th>测试用例</th><th>a,b,c</th><th>执行路径</th><th>预期结果</th></tr></thead><tbody><tr><td>1</td><td>1,-1,1</td><td>ah</td><td>3</td></tr><tr><td>2</td><td>1,1,-1</td><td>bceg</td><td>0</td></tr><tr><td>3</td><td>1,1,1</td><td>bdfg</td><td>2</td></tr></tbody></table></li></ul></li><li><p><strong>基本路径覆盖</strong></p><ul><li><p>数量：$V(G)=流程图中区域数=3$</p></li><li><p>测试用例：</p><table><thead><tr><th>测试用例</th><th>a,b,c</th><th>执行路径</th><th>预期结果</th></tr></thead><tbody><tr><td>1</td><td>1,-1,1</td><td>ah</td><td>3</td></tr><tr><td>2</td><td>1,1,-1</td><td>bceg</td><td>0</td></tr><tr><td>3</td><td>1,1,1</td><td>bdfg</td><td>2</td></tr></tbody></table></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试（二）白盒测试</title>
      <link href="/software-test-02/"/>
      <url>/software-test-02/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试（二）白盒测试"><a href="#软件测试（二）白盒测试" class="headerlink" title="软件测试（二）白盒测试"></a>软件测试（二）白盒测试</h1><h2 id="白盒测试（White-Box-Testing）"><a href="#白盒测试（White-Box-Testing）" class="headerlink" title="白盒测试（White-Box Testing）"></a>白盒测试（White-Box Testing）</h2><ul><li><strong>基本原理</strong>：基于过程设计的控制结构导出测试用例。</li><li><strong>白盒测试分类</strong><ul><li>Control Flow-Testing<ul><li>逻辑分支覆盖法<ul><li>语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖</li></ul></li><li>路径法<ul><li>路径覆盖、基本（独立）路径测试法</li></ul></li></ul></li><li>DataFlow-Testing</li></ul></li></ul><h2 id="控制流测试"><a href="#控制流测试" class="headerlink" title="控制流测试"></a>控制流测试</h2><h3 id="逻辑分支覆盖法"><a href="#逻辑分支覆盖法" class="headerlink" title="逻辑分支覆盖法"></a>逻辑分支覆盖法</h3><h4 id="1-语句覆盖（statement）"><a href="#1-语句覆盖（statement）" class="headerlink" title="1. 语句覆盖（statement）"></a>1. 语句覆盖（statement）</h4><ul><li><p><strong>概念</strong></p><ul><li>语句覆盖就是设计若干个测试用例，运行被测程序，使得<strong>每一可执行语句至少执行一次</strong>。</li><li>这种覆盖又称为<strong>点覆盖</strong>，它使得程序中每个可执行语句都得到执行，但它是<strong>最弱的逻辑覆盖</strong>，效果有限，必须与其它方法交互使用。  </li></ul></li><li><p><strong>示例</strong></p><p><img src="./02-01.png" alt="02-01 语句覆盖"></p></li></ul><h4 id="2-判定覆盖（Decision-Coverage-Branch-Coverage）"><a href="#2-判定覆盖（Decision-Coverage-Branch-Coverage）" class="headerlink" title="2. 判定覆盖（Decision Coverage, Branch Coverage）"></a>2. 判定覆盖（Decision Coverage, Branch Coverage）</h4><ul><li><strong>概念</strong><ul><li>判定覆盖就是设计若干个测试用例，运行被测程序，使得程序中<strong>每个判断的取真分支和取假分支至少经历一次</strong>。判定覆盖又称为<strong>分支覆盖</strong>。 </li></ul></li></ul><h4 id="3-条件覆盖（Condition-Coverage）"><a href="#3-条件覆盖（Condition-Coverage）" class="headerlink" title="3. 条件覆盖（Condition Coverage）"></a>3. 条件覆盖（Condition Coverage）</h4><ul><li><strong>概念</strong><ul><li>条件覆盖就是设计若干个测试用例，运行被测程序，使得程序中<strong>每个判断的每个条件的可能取值至少执行一次</strong>。 </li></ul></li><li><strong>关系</strong><ul><li>条件覆盖深入到判定中的每个条件，但可能不满足判定覆盖</li></ul></li></ul><h4 id="4-判定-条件覆盖"><a href="#4-判定-条件覆盖" class="headerlink" title="4. 判定/条件覆盖"></a>4. 判定/条件覆盖</h4><ul><li><strong>概念</strong><ul><li>判定-条件覆盖要求设计足够的测试用例，使得<strong>判定中每个条件的所有可能 （真/假）至少出现一次</strong>，并且<strong>每个判定本身的判定结果（真/假）也至少出现一次</strong>。</li></ul></li><li><strong>复合判定</strong>：改为单个条件判定</li></ul><h4 id="5-条件组合覆盖"><a href="#5-条件组合覆盖" class="headerlink" title="5. 条件组合覆盖"></a>5. 条件组合覆盖</h4><ul><li><p><strong>概念</strong></p><ul><li>条件组合覆盖就是设计足够的测试用例，运行被测程序，使得<strong>每个判断的所有可能的条件取值组合至少执行一次</strong>。 </li></ul></li><li><p><strong>关系</strong></p><ul><li>满足“条件组合覆盖”的测试用 例是一定满足“判定覆盖”、“条件覆盖”和“判定-条件覆盖”的。 </li></ul></li><li><p><strong>示例</strong></p><p><img src="./02-02.png" alt="02-02 条件组合覆盖"></p></li></ul><h3 id="路径法"><a href="#路径法" class="headerlink" title="路径法"></a>路径法</h3><h4 id="1-路径覆盖（Path-Coverage）"><a href="#1-路径覆盖（Path-Coverage）" class="headerlink" title="1. 路径覆盖（Path Coverage）"></a>1. 路径覆盖（Path Coverage）</h4><ul><li><strong>概念</strong><ul><li>路径测试就是设计足够的测试用例，<strong>覆盖程序中所有可能的路径</strong>。这是<strong>最强的覆盖准则</strong>。但在路径数目很大时，真正做到完全覆盖是很困难的，必须把覆盖路径数目压缩到一定限度。 </li><li>保证程序中每条可能的路径都至少执行一次，因此更具代表性，暴露错误的能力也比较强。 </li><li>但为了做到路径覆盖，只需考虑每个判定式的取值组合，并没有检验表达式中条件的各种可能组合。如果将路径覆盖和条件组合覆盖结合起来，可以设计出检错能力更强的测试数据。 </li></ul></li></ul><h4 id="2-基本（独立）路径测试法"><a href="#2-基本（独立）路径测试法" class="headerlink" title="2. 基本（独立）路径测试法"></a>2. 基本（独立）路径测试法</h4><ul><li><strong>概念</strong><ul><li>独立路径：从入口到出口的路径，至少经历一个从未走过的边。这样形成的路径叫独立路径。</li></ul></li><li><strong>步骤</strong><ul><li>根据程序的逻辑结构画出<strong>程序框图</strong></li><li>根据程序框图导出<strong>流图</strong></li><li>计算流图<strong>G</strong>的<strong>环路复杂度$V(G)$</strong><ul><li><strong>流图的区域数量</strong>应该对应于环复杂度 </li><li>给定流图G的环复杂度定义为：$V(G)=E-N+2$<ul><li>E为流图中的边数量，N为流图中的节点数量 </li></ul></li><li>给定流图G的环复杂度也可以定义为：$V(G)=P+1$<ul><li>P为流图中的判断节点数量</li></ul></li></ul></li><li>确定只包含独立路径的基本路径集</li><li>设计测试用例</li></ul></li></ul><h2 id="数据流测试"><a href="#数据流测试" class="headerlink" title="数据流测试"></a>数据流测试</h2><ul><li><p><strong>含义</strong>：数据流测试使用控制流图来进行测试。</p><ul><li>能填补路径和分支测试的缝隙</li></ul></li><li><p><strong>数据对象类别：</strong></p><ul><li><strong>（d）</strong>：Defined, Created, Initialized</li><li><strong>（k）</strong>：Killed, Undefined, Released</li><li><strong>（u）</strong>：Used<ul><li><strong>（c）</strong>：Used in a calculation</li><li><strong>（p）</strong>：Used in a predicate</li></ul></li></ul></li><li><p><strong>路径段</strong>（du Path Segments）</p><ul><li><p>Def-use Association: $(x , d, u)$</p><ul><li>x: 变量</li><li>d: 含有x定义的节点</li><li>u: 含有x使用的判断或语句</li><li>路径段中不存在其它x的定义</li></ul></li><li><p><strong>例子</strong></p><p><img src="./03-01.png" alt="03-01 Du Path 示例"></p></li></ul></li><li><p><strong>数据流测试策略：ADUP</strong>（All du Paths）</p><ul><li>找出测试所有的du paths路径</li></ul></li></ul><h2 id="终极示例"><a href="#终极示例" class="headerlink" title="终极示例"></a>终极示例</h2><ul><li>其实就是课程作业啦…</li></ul><h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><pre class=" language-python"><code class="language-python">scanf<span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">and</span> x<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>    pow <span class="token operator">=</span> <span class="token operator">-</span>y<span class="token punctuation">;</span><span class="token keyword">else</span>    pow <span class="token operator">=</span> y<span class="token punctuation">;</span>z <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>pow <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    z <span class="token operator">=</span> z <span class="token operator">*</span> x<span class="token punctuation">;</span>    pow <span class="token operator">=</span> pow <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">and</span> z<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>    z <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> z<span class="token punctuation">;</span>printf <span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>用判定条件覆盖法、基本路径法完成测试用例设计（要求画程序流程图和控制流图）</p><h3 id="【答案】"><a href="#【答案】" class="headerlink" title="【答案】"></a>【答案】</h3><ol><li><p>程序流程图</p><p><img src="./04-01.png" alt="04-01 程序流程图"></p></li><li><p>控制流图</p><p><img src="./04-02.png" alt="04-02 控制流图"> </p></li><li><p>判定条件覆盖法</p><p><img src="./04-03.png" alt="04-03 判定条件覆盖"></p></li><li><p>基本路径法</p><p>本因有四条基本路径，但由于判定1与判定3存在矛盾，所以无法找出四条基本路径的实际用例。</p><table><thead><tr><th>测试序号</th><th>测试路径</th><th>输入(x, y)</th><th>理想输出(z)</th></tr></thead><tbody><tr><td>1</td><td>abdefhjk</td><td>(1, 0)</td><td>1.0</td></tr><tr><td>2</td><td>abdefgfhjk</td><td>(-1, -1)</td><td>-1.0</td></tr><tr><td>3</td><td>abcefgfhijk</td><td>(1, -1)</td><td>1.0</td></tr><tr><td>4</td><td></td><td></td><td></td></tr></tbody></table></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试（一）黑盒测试</title>
      <link href="/software-test-01/"/>
      <url>/software-test-01/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试（一）黑盒测试"><a href="#软件测试（一）黑盒测试" class="headerlink" title="软件测试（一）黑盒测试"></a>软件测试（一）黑盒测试</h1><h2 id="动态黑盒测试（Black-Box-Test）"><a href="#动态黑盒测试（Black-Box-Test）" class="headerlink" title="动态黑盒测试（Black-Box Test）"></a>动态黑盒测试（Black-Box Test）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>不深入代码细节测试软件的方法称为<strong>动态黑盒测试</strong>。</li><li><strong>动态</strong>（dynamic）：程序在运行；<strong>黑盒</strong>（black-box）：不知道如何运行。</li><li>动态黑盒测试常被称为<strong>行为测试</strong>，因为测试的是软件在使用过程中的实际行动。</li></ul><h2 id="测试用例设计技术"><a href="#测试用例设计技术" class="headerlink" title="测试用例设计技术"></a>测试用例设计技术</h2><h3 id="1-等价类划分法（Equivalence-Partitioning）"><a href="#1-等价类划分法（Equivalence-Partitioning）" class="headerlink" title="1. 等价类划分法（Equivalence Partitioning）"></a>1. 等价类划分法（Equivalence Partitioning）</h3><ul><li><p><strong>概念</strong>：把程序的输入域划分成若干部分，然后从每个部分中选取少数代表性数据当作测试用例。</p></li><li><p><strong>有效等价类</strong> &amp; <strong>无效等价类</strong></p><ul><li>有效等价类：指对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现 了规格说明中所规定的功能和非功能。 </li><li>无效等价类：与有效等价类的定义恰巧相反。 </li></ul></li><li><p>测试：<strong>完备性</strong>、<strong>无冗余性</strong></p></li><li><p><strong>确定等价类的原则：</strong></p><ul><li>在输入条件规定了取值范围或值的个数的情况下，则可以确立一个有效等价类和两个无效等价类。 </li><li>在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可以确立一个有效等价类和一个无效等价类。 </li><li>在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类。 </li><li>在规定了输入数据的一组值 ，并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类。</li><li>在规定了输入数据必须遵守的规则的情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）。 </li><li>如果确知，已划分的等价类中各个元素在程序中的处理方式不同，则应将此等价类进一步划分成更小的等价类。 </li></ul></li><li><p><strong>示例</strong></p><ul><li><p>等价类划分：</p><table><thead><tr><th>被测项</th><th>边长</th><th>等价类编号</th></tr></thead><tbody><tr><td>有效等价类</td><td>正数</td><td>1</td></tr><tr><td>无效等价类</td><td>小于0</td><td>2</td></tr></tbody></table></li><li><p>测试用例设计：</p><table><thead><tr><th>测试用例编号</th><th>输入值</th><th>覆盖的等价类编号</th><th>合理输出</th></tr></thead><tbody><tr><td>T1</td><td>2</td><td>(1)</td><td>正确</td></tr><tr><td>T2</td><td>0</td><td>(2)</td><td>错误</td></tr></tbody></table></li></ul></li></ul><h3 id="2-边界值分析法（VBA-Boundary-Value-Analysis）"><a href="#2-边界值分析法（VBA-Boundary-Value-Analysis）" class="headerlink" title="2. 边界值分析法（VBA, Boundary Value Analysis）"></a>2. 边界值分析法（VBA, Boundary Value Analysis）</h3><ul><li><strong>概念：</strong>对等价划分类的补充，不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。</li><li><strong>设计方法：</strong><ul><li>确定边界情况（输入或输出等价类的边界）</li><li>选取正好等于、刚刚大于或刚刚小于边界值作为测试数据 </li><li>一般情况，一个边界可以给出3个边界测试用例，<strong>自身+左右值</strong></li></ul></li></ul><h3 id="3-错误推测方法"><a href="#3-错误推测方法" class="headerlink" title="3. 错误推测方法"></a>3. 错误推测方法</h3><ul><li><strong>概念：</strong><ul><li>通过经验和直觉推测出程序的错误所在；</li><li>主观、灵感、反向思维，难以复制等等；</li><li>不是一个系统的方法，用作辅助手段。</li></ul></li></ul><h3 id="4-判定表驱动测试方法（Decision-Table）"><a href="#4-判定表驱动测试方法（Decision-Table）" class="headerlink" title="4. 判定表驱动测试方法（Decision Table）"></a>4. 判定表驱动测试方法（Decision Table）</h3><ul><li><p><strong>概念：</strong>是分析和表达多逻辑条件下执行不同操作的工具，也叫判定表。</p></li><li><p><strong>组成：</strong>条件桩（Condition Stub）、动作桩（Action Stub）、条件项、动作项、规则</p><table><thead><tr><th>条件桩</th><th>条件项</th></tr></thead><tbody><tr><td>动作桩</td><td>动作项</td></tr></tbody></table></li><li><p><strong>示例：</strong></p><ul><li><p>判定表：</p><p><img src="./01-01.png" alt="01-01 判定表"></p></li><li><p>测试用例：</p><p><img src="./01-02.png" alt="01-02 判定表测试用例"></p></li></ul></li></ul><h3 id="5-因果图法"><a href="#5-因果图法" class="headerlink" title="5. 因果图法"></a>5. 因果图法</h3><ul><li><p><strong>概念：</strong></p><ul><li>借助图的方式，设计测试用例，被测程序有多种输入条件，输出结果依赖于输入条件的组合; </li><li>着重分析输入条件的各种组合，每个条件就是一个“因”，这些“因”的组合必然有一个输出的结果，这就是“果”; </li><li>与其他的方法相比，更侧重于输入条件的组合 。</li></ul></li><li><p><strong>约束符号</strong></p><ul><li>E：互斥，不能同时出现</li><li>I：包含，至少一个出现</li><li>O：唯一，有且只有一个出现</li><li>R：要求，若a=1那么要求b必须是1，反之如果a=0，那么b无所谓</li><li>M：屏蔽，当a=1时，b=0，当a=0，b的值有可能是1，也有可能是0</li></ul></li><li><p><strong>示例：</strong></p><p><img src="./01-03.png" alt="01-03 因果图"></p></li><li><p><strong>步骤：</strong></p><ul><li>分析软件规格说明描述中, 哪些是原因（即输入条件或输入条件的等价类），哪些是结果（即输出条件），并给每个原因和结果赋予一个标识符。 </li><li>分析软件规格说明描述中的语义，找出原因与结果之间、原因与原因之间对应的关系。根据这些关系，画出因果图。 </li><li>把因果图转换为判定表。</li><li>把判定表的每一列拿出来作为依据,设计测试用例。 </li></ul></li></ul><h3 id="6-场景法"><a href="#6-场景法" class="headerlink" title="6. 场景法"></a>6. 场景法</h3><ul><li><p><strong>概念：</strong></p><ul><li>用例场景：用来描述流经用例的路径，从用例开始到结束遍历这条路径上所有基本流和备选流。</li><li><strong>基本流</strong>和<strong>备选流</strong></li><li><strong>场景</strong></li></ul></li><li><p>测试用例设计<strong>步骤</strong>与<strong>示例</strong></p><ul><li><p><strong>设计场景</strong>：通过用例的主事件流和备选事件流的组合给出不同的场景</p><table><thead><tr><th>场景</th><th>基本流&amp;备选流</th></tr></thead><tbody><tr><td>场景1</td><td>基本流</td></tr><tr><td>场景2</td><td>基本流 备选流1</td></tr><tr><td>场景3</td><td>基本流 备选流1 备选流2</td></tr><tr><td>场景4</td><td>基本流 备选流3</td></tr></tbody></table></li><li><p><strong>设计测试用例标准</strong>：覆盖场景</p></li></ul><table><thead><tr><th>测试用例编号</th><th>覆盖的场景</th><th>PIN</th><th>账号</th><th>输入（选择）的金额</th><th>账面金额</th><th>ATM中的金额</th><th>预测结果</th></tr></thead><tbody><tr><td>1</td><td>场景1-成功提款</td><td>V</td><td>V</td><td>V</td><td>V</td><td>V</td><td>成功提款</td></tr><tr><td>2</td><td>场景2-ATM内无现金</td><td>V</td><td>V</td><td>V</td><td>V</td><td>I</td><td>提款选项不可用，用例结束</td></tr><tr><td>…</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>根据测试用例标准给出<strong>具体的测试数据</strong><table><thead><tr><th>测试用例编号</th><th>覆盖的场景</th><th>PIN</th><th>账号</th><th>输入（选择）的金额</th><th>账面金额</th><th>ATM中的金额</th><th>预测结果</th></tr></thead><tbody><tr><td>1</td><td>场景1-成功提款</td><td>1987</td><td>809-498</td><td>100</td><td>500</td><td>2000</td><td>成功提款</td></tr><tr><td>2</td><td>场景2-ATM内无现金</td><td>1987</td><td>809-398</td><td>100</td><td>500</td><td>0</td><td>提款选项不可用，用例结束</td></tr><tr><td>…</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></li></ul></li><li><p><strong>应用场景</strong></p><ul><li>一般用于<strong>功能测试</strong>，基本上所有的功能流程测试都会用到；</li><li>业务复杂时，针对关键业务场景进行业务的流程测试。</li></ul></li></ul><h2 id="黑盒测试策略总结"><a href="#黑盒测试策略总结" class="headerlink" title="黑盒测试策略总结"></a>黑盒测试策略总结</h2><ul><li>针对功能具体页面中具体的输入域进行细化测试，采用等价类、边界值；</li><li>用静态检查法检查按钮、链接、内容、图片等；</li><li>针对每个功能的流程，采用场景法，进行该功能（用例）的全方位流程测试；</li><li>如果是多个条件的组合可以采用判定表或因果图法；</li><li>在任何情况下都必须使用边界值分析方法；</li><li>用错误推测法再追加一些测试用例。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记（三）第一个渲染程序</title>
      <link href="/opengl-03/"/>
      <url>/opengl-03/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenGL学习笔记（三）第一个渲染程序"><a href="#OpenGL学习笔记（三）第一个渲染程序" class="headerlink" title="OpenGL学习笔记（三）第一个渲染程序"></a>OpenGL学习笔记（三）第一个渲染程序</h1><p>​    上一篇中简单介绍了渲染管线和FLEW、FreeGLUT库的安装，但示例程序仍是使用已经废止的glBegin和glEnd来实现的，这次将进行第一个真正的渲染程序的编写（毕竟将对管线的认知转到实际的代码中的体现，仍是需要示例来帮助的）。第一次计算机图形学课的实验，由于没弄清楚要求，以为侧重三D建模和图形旋转就参考了一个复杂的示例，结果就被检查的师兄提问到“失去理想”了（问各种参数和流程交互，嘤嘤嘤），此文也是为了弥补缺憾。</p><p>​    此文的代码来自传说中的红宝书<a href="https://github.com/openglredbook" title="openGL RedBook Github" target="_blank" rel="noopener">[1]</a>并参考老师课件，感谢<a href="https://www.cnblogs.com/caster99/p/4752354.html" title="OpenGL红宝书：第一个渲染程序Triangles常见问题归总 - caster99" target="_blank" rel="noopener">[2]</a><a href="http://www.360doc.com/content/14/1028/10/19175681_420522404.shtml" title="OpenGL学习脚印：基本图形绘制方式比较（glBegin, glCallList, glVertexPointer, VBO）- 方海龙的书馆" target="_blank" rel="noopener">[3]</a><a href="https://blog.csdn.net/chunyexiyu/article/details/89224004" title="Mac上构建OpenGL红宝书上的triangles程序-春夜喜雨" target="_blank" rel="noopener">[4]</a>，帮助我解决了很多的碰到的问题。</p><h2 id="OpenGL传统与现代的绘制方式"><a href="#OpenGL传统与现代的绘制方式" class="headerlink" title="OpenGL传统与现代的绘制方式"></a>OpenGL传统与现代的绘制方式</h2><p>​    在<a href>OpenGL学习笔记（一）</a>中，曾简单提到了<strong>核心模式</strong>（Core-Profile）与<strong>立即渲染模式</strong>（Immediate mode）这两个词，在开始编写渲染程序之前，有必要再次提到这两个词，并说明介绍一下OpenGL传统与现代的绘制方式，来帮助大家更清楚地了解使用渲染管线编程（自己在图形学课的第一次实验前，在两种方式上吃了很大的亏，弄了好多使用glBegin和glEnd的示例来看，结果发现不符合要求，蓝瘦）。</p><h3 id="传统方式绘制"><a href="#传统方式绘制" class="headerlink" title="传统方式绘制"></a>传统方式绘制</h3><h4 id="1-立即渲染模式（Immediate-Mode）"><a href="#1-立即渲染模式（Immediate-Mode）" class="headerlink" title="1. 立即渲染模式（Immediate Mode）"></a>1. 立即渲染模式（Immediate Mode）</h4><p>​    使用glBegin…glEnd的方式制定绘制方式，<a href>学习笔记（二）</a>最后的示例就是通过这种方式绘制的，在OpenGL新版本中已被废弃。简单示例如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">glBegin</span><span class="token punctuation">(</span>GL_LINE_LOOP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将以下点逐一连线</span>    <span class="token function">glVertex3d</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">,</span>a<span class="token punctuation">.</span>y<span class="token punctuation">,</span>a<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glVertex3d</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>x<span class="token punctuation">,</span>b<span class="token punctuation">.</span>y<span class="token punctuation">,</span>b<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glVertex3d</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>x<span class="token punctuation">,</span>c<span class="token punctuation">.</span>y<span class="token punctuation">,</span>c<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glVertex3d</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>x<span class="token punctuation">,</span>d<span class="token punctuation">.</span>y<span class="token punctuation">,</span>d<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="2-显示列表（Display-List）"><a href="#2-显示列表（Display-List）" class="headerlink" title="2. 显示列表（Display List）"></a>2. 显示列表（Display List）</h4><p>​    将一组OpenGL函数存储在一起，在以后执行，调用时，存储的函数会按顺序执行。示例如下：</p><pre class=" language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//创建显示列表</span> displayListId <span class="token operator">=</span> <span class="token function">glGenLists</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">glNewList</span><span class="token punctuation">(</span>displayListId<span class="token punctuation">,</span> GL_COMPILE<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">glBegin</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">glVertex3f</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">glVertex3f</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">glVertex3f</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">glEndLIst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="现代方式绘制"><a href="#现代方式绘制" class="headerlink" title="现代方式绘制"></a>现代方式绘制</h3><h4 id="1-顶点数组绘图"><a href="#1-顶点数组绘图" class="headerlink" title="1. 顶点数组绘图"></a>1. 顶点数组绘图</h4><blockquote><p>​    使用顶点数组方式，需要利用glEnableClientState开启一些特性。</p><p>​    使用顶点数组时，用户定义好存储顶点的数据，在调用glDrawArrays、glDrawElements之类的函数时，用过glVertexPointer设定的指针，传送数据到GPU。当调用完glDrawArrays后，GPU中已经有了绘图所需数据，用户可以释放数据空间。<a href="https://www.cnblogs.com/caster99/p/4752354.html" title="OpenGL红宝书：第一个渲染程序Triangles常见问题归总 - caster99" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/caster99/p/4752354.html" title="OpenGL红宝书：第一个渲染程序Triangles常见问题归总 - caster99" target="_blank" rel="noopener">2</a></a></p></blockquote><p>​    示例：</p><pre class=" language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">//利用顶点数组，绘制三角形  </span>    <span class="token keyword">const</span> <span class="token keyword">int</span> num_indices <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建保存顶点的结构体数组</span>    vec3f <span class="token operator">*</span>vertices <span class="token operator">=</span> <span class="token keyword">new</span> vec3f<span class="token punctuation">[</span>num_indices<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 顶点1 </span>    vertices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">;</span>     vertices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">;</span>     vertices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 顶点2 </span>    vertices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0.5f</span><span class="token punctuation">;</span>      vertices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>       vertices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//顶点3  </span>    vertices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>    vertices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0.5f</span><span class="token punctuation">;</span>     vertices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 启用vertex arrays </span>    <span class="token function">glEnableClientState</span><span class="token punctuation">(</span>GL_VERTEX_ARRAY<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//定义顶点数组 </span>    <span class="token function">glVertexPointer</span><span class="token punctuation">(</span>          <span class="token number">3</span><span class="token punctuation">,</span>         <span class="token comment" spellcheck="true">// 每个顶点的维度 </span>        GL_FLOAT<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 顶点数据类型 </span>      <span class="token number">0</span><span class="token punctuation">,</span>         <span class="token comment" spellcheck="true">// 连续顶点之间的间隙，这里为0  </span>      vertices   <span class="token comment" spellcheck="true">//指向第一个顶点的第一个坐标的指针</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> num_indices<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">glDisableClientState</span><span class="token punctuation">(</span>GL_VERTEX_ARRAY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//释放内存空间</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> vertices<span class="token punctuation">;</span> </code></pre><h4 id="2-现代VBO-VAO绘图"><a href="#2-现代VBO-VAO绘图" class="headerlink" title="2. 现代VBO VAO绘图"></a>2. 现代VBO VAO绘图</h4><p>​    VAO（Vertex Array Object），包含一个或多个VBO对象，被设计来存储一个完整被渲染对象所需的信息；VBO（Vertex Buffer Object），在高速视频卡中的内存缓冲，保存顶点数据以及归一化向量、纹理和索引等数据。</p><h4 id="3-结合Shader绘图"><a href="#3-结合Shader绘图" class="headerlink" title="3. 结合Shader绘图"></a>3. 结合Shader绘图</h4><p>​    参考<a href>学习笔记（一）</a>不做详细解释。</p><h2 id="第一个渲染程序"><a href="#第一个渲染程序" class="headerlink" title="第一个渲染程序"></a>第一个渲染程序</h2><p>​    仍是一个绘制三角形的程序吼。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li>使用GLFW和FreeGLUT库<strong>（还是不行的，由于FreeGLUT在MAC上无法编译着色器代码，所以在此仍然使用Xcode自带的OpenGL.framework和GLUT.framework）</strong>，创建项目和配置库不再做解释，有需要请参考前两篇学习笔记。</li></ul><h3 id="1-LoadShaders"><a href="#1-LoadShaders" class="headerlink" title="1. LoadShaders"></a>1. LoadShaders</h3><p>​    包含一些宏定义，主要用于debug处理，红宝书提供的。</p><h4 id="LoadShaders-hpp"><a href="#LoadShaders-hpp" class="headerlink" title="LoadShaders.hpp"></a>LoadShaders.hpp</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> __LOAD_SHADERS_H__</span><span class="token macro property">#<span class="token directive keyword">define</span> __LOAD_SHADERS_H__</span><span class="token comment" spellcheck="true">//#include &lt;GL/gl.h></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;OpenGL/gl.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;OpenGL/gl3.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;GLUT/glut.h></span></span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">endif</span>  </span><span class="token comment" spellcheck="true">// __cplusplus</span> <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    GLenum       type<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>  filename<span class="token punctuation">;</span>    GLuint       shader<span class="token punctuation">;</span><span class="token punctuation">}</span> ShaderInfo<span class="token punctuation">;</span>GLuint <span class="token function">LoadShaders</span><span class="token punctuation">(</span>ShaderInfo<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//----------------------------------------------------------------------------</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">// __cplusplus</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">// __LOAD_SHADERS_H__</span></code></pre><h4 id="LoadShaers-cpp"><a href="#LoadShaers-cpp" class="headerlink" title="LoadShaers.cpp"></a>LoadShaers.cpp</h4><p>​    代码过长，又不打算加以解释，所以放置在最后的代码附录中。</p><h3 id="2-着色器定义"><a href="#2-着色器定义" class="headerlink" title="2. 着色器定义"></a>2. 着色器定义</h3><h4 id="triangle-vert-顶点着色器"><a href="#triangle-vert-顶点着色器" class="headerlink" title="triangle.vert 顶点着色器"></a>triangle.vert 顶点着色器</h4><ul><li>代码</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#version 400 core </span><span class="token comment" spellcheck="true">//版本号不能高于410，修改为400即可</span><span class="token function">layout</span><span class="token punctuation">(</span> location <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">)</span> in vec4 vPosition<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//从main程序中输入，必须与应用中的变量关联</span><span class="token keyword">void</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    gl_Position <span class="token operator">=</span> vPosition<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>执行流程示意图</li></ul><p><img src="./02-01.png" alt="02-01 顶点着色器渲染流程"></p><h4 id="triangle-frag-片段着色器"><a href="#triangle-frag-片段着色器" class="headerlink" title="triangle.frag 片段着色器"></a>triangle.frag 片段着色器</h4><ul><li>代码</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#version 400 core</span>out vec4 fColor<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//输出颜色信息</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    fColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置vPosition位置的颜色</span><span class="token punctuation">}</span></code></pre><ul><li>执行流程示意图</li></ul><p><img src="./02-02.png" alt="02-02 片段着色器渲染流程"></p><h3 id="3-主程序，main-cpp"><a href="#3-主程序，main-cpp" class="headerlink" title="3. 主程序，main.cpp"></a>3. 主程序，main.cpp</h3><h4 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"LoadShaders.hpp"</span> </span><span class="token comment" spellcheck="true">//其它的库头文件包含在“LoadShaders.hpp"中了</span><span class="token macro property">#<span class="token directive keyword">pragma</span> comment (lib, "glew32.lib")</span><span class="token comment" spellcheck="true">//存在无法解析外部符号d时的处理</span><span class="token keyword">enum</span> VAO_IDs <span class="token punctuation">{</span> Triangles<span class="token punctuation">,</span> NumVAOs <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//VAO, Vertex Array Object</span><span class="token keyword">enum</span> Buffer_IDs <span class="token punctuation">{</span> ArrayBuffer<span class="token punctuation">,</span> NumBuffers <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//着色器shader中的缓存</span><span class="token keyword">enum</span> Attrib_IDs <span class="token punctuation">{</span> vPosition <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//指定shader中的属性变量位置</span>GLuint  VAOs<span class="token punctuation">[</span>NumVAOs<span class="token punctuation">]</span><span class="token punctuation">;</span>GLuint  Buffers<span class="token punctuation">[</span>NumBuffers<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> GLuint  NumVertices <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span></code></pre><h4 id="init-初始"><a href="#init-初始" class="headerlink" title="init 初始"></a>init 初始</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span> NumVAOs<span class="token punctuation">,</span> VAOs <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建VAO</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span> VAOs<span class="token punctuation">[</span>Triangles<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//绑定所需的VAO</span>    GLfloat  vertices<span class="token punctuation">[</span>NumVertices<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token number">0.90f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.90f</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token number">0.85f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.90f</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token number">0.90f</span><span class="token punctuation">,</span>  <span class="token number">0.85f</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// Triangle 1</span>        <span class="token punctuation">{</span>  <span class="token number">0.90f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.85f</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token number">0.90f</span><span class="token punctuation">,</span>  <span class="token number">0.90f</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token number">0.85f</span><span class="token punctuation">,</span>  <span class="token number">0.90f</span> <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// Triangle 2</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//生成缓冲（对象数量，存储缓冲的数组），并在Buffers数组中返回n个缓冲对象的名称</span>    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span> NumBuffers<span class="token punctuation">,</span> Buffers <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//指定当前活动缓冲区的对象（Glenum target, Gluint buffer）</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span> GL_ARRAY_BUFFER<span class="token punctuation">,</span> Buffers<span class="token punctuation">[</span>ArrayBuffer<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*用数据分配和初始化缓冲区对象    target: GL_ARRAY_BUFFER（顶点数据），GL_ELEMENT_ARRAY_BUFFER（索引数据）    size: 存储相关数据所需的内存量    daata: 用于初始化的缓冲区对象，可以是指针，也可以是NULL    usage：数据在分配后如何进行读写，       GL_STATIC_DRAW，数据只指定1次，但可以多次作为绘图和图像指定h函数的源数据*/</span>    <span class="token function">glBufferData</span><span class="token punctuation">(</span> GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">,</span> vertices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>    ShaderInfo  shaders<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>    <span class="token punctuation">{</span>        <span class="token punctuation">{</span> GL_VERTEX_SHADER<span class="token punctuation">,</span> <span class="token string">"/Volumes/TOSHIBAEXT 1/CODE/Study/OpenGL/03/studyOpenGL0309/studyOpenGL0309/triangle.vert"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> GL_FRAGMENT_SHADER<span class="token punctuation">,</span> <span class="token string">"/Volumes/TOSHIBAEXT 1/CODE/Study/OpenGL/03/studyOpenGL0309/studyOpenGL0309/triangle.frag"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> GL_NONE<span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过LoadShaders写好的内容，进行shader创建</span>    GLuint program <span class="token operator">=</span> <span class="token function">LoadShaders</span><span class="token punctuation">(</span> shaders <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//使用程序对象作为当前渲染的一部分</span>    <span class="token function">glUseProgram</span><span class="token punctuation">(</span> program <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span>  BUFFER_OFFSET(offset) ((void *)(offset))</span>    <span class="token comment" spellcheck="true">/*指定渲染时索引值为index的顶点属性数组的数据格式和位置    Gluint index: 指定要修改的顶点属性的索引值    Glint size: 指定每个顶点属性的组建数量，必须为1、2、3或4，初始值为4    GLenum type: 指定数组中每个组件的数据类型    GLboolean normalized: 指定被访问时，固定点数据值被归一化（GL_TRUE),直接转换为固定值（GL_FALSE）    GLsizei stride: 指定连续顶点之间的偏移量。若为0，则是紧密排列在一起的，初始值为0    const GLvoid* pointer: 指定第一个组件在数组的第一个顶点属性中的偏移量，初始值为0*/</span>    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span> vPosition<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span>                           GL_FALSE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">BUFFER_OFFSET</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//默认情况下，出于性能考虑，所有顶点着色器的属性（Attribute）变量都是关闭的，意味着数据在着色器端是不可见的，哪怕数据已经上传到GPU，由glEnableVertexAttribArray启用指定属性，才可在顶点着色器中访问逐顶点的属性数据。glVertexAttribPointer或VBO只是建立CPU和GPU之间的逻辑连接，从而实现了CPU数据上传至GPU。但是，数据在GPU端是否可见，即，着色器能否读取到数据，由是否启用了对应的属性决定，这就是glEnableVertexAttribArray的功能，允许顶点着色器读取GPU（服务器端）数据。只要在绘图调用前调用即可</span>    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span> vPosition <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// set the color when clear screen</span>    <span class="token function">glClearColor</span> <span class="token punctuation">(</span><span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token number">0.4f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*清除指定的缓冲区    GL_COLOR_BUFFER_BIT: 当前可写的颜色缓冲    GL_DEPTH_BUFFER_BIT: 深度缓冲    GL_ACCUM_BUFFER_BIT: 累计缓冲    GL_STENCIL_BUFFER_BIT: 模版缓冲*/</span>    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAOs<span class="token punctuation">[</span>Triangles<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*绘制图形    GLenum mode: 绘制方式    GLint first: 从数组缓存中的哪一位开始绘制，一般为0    GLsizei count: 数组中顶点的数量*/</span>    <span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NumVertices<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//清空缓冲区，将指令送往缓硬件立即执行，但是它是将命令传送完毕之后立即返回，不会等待指令执行完毕。这些指令会在有限时间内执行完毕。使用glFlush的目的是确保在调用之后，CPU没有OpenGL相关的事情需要做-命令会送到硬件执行。调用glFinish的目的是确保当返回之后，没有相关工作留下需要继续做。</span>    <span class="token comment" spellcheck="true">//glFlush();</span>    <span class="token comment" spellcheck="true">//双缓存开启下使用glutSwapBuffers</span>    <span class="token function">glutSwapBuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"start init windows"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">glutInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化GLUT库，完成必须的初始化和开启事件处理循环</span>    <span class="token function">glutInitDisplayMode</span><span class="token punctuation">(</span>GLUT_DOUBLE<span class="token operator">|</span>GLUT_RGBA<span class="token operator">|</span>GLUT_3_2_CORE_PROFILE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置初始显示模式</span>    <span class="token comment" spellcheck="true">/* GLUT_3_2_CORE_PROFILE代替以下在FreeGLUT中的命令    glutInitContextVersion(4,3);//指定OpenGL版本    glutInitContextProfile(GLUT_CORE_PROFILE);//设置所需的OpenGL环境的类型*/</span>    <span class="token function">glutInitWindowPosition</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始窗口位置</span>    <span class="token function">glutInitWindowSize</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置窗口位置</span>    <span class="token function">glutCreateWindow</span><span class="token punctuation">(</span><span class="token string">"第一个渲染程序"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建一个顶级窗口，“第一个渲染程序"窗口名</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"init vertices"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"start display"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*当窗口内容绘制、窗口大小改变、窗口重绘时调用mydisplay函数重绘    一般与glutReshapeFunc(&amp;reshape), glutIdelFunc(&amp;IdleFunc)同时出现*/</span>    <span class="token function">glutDisplayFunc</span><span class="token punctuation">(</span>display<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutMainLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><ul><li>嘤嘤嘤，终于成功了，感谢网上的大佬们的博客。</li></ul><img src="./03-01.png" alt="03-01 最终效果" style="zoom:50%;"><ul><li>终于步入正轨了，在无法在Mac上进行编译的FreeGlut、误入传统绘图方法和各种错误上耗费了许多时间，总算成功了，哭。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]: <a href="https://github.com/openglredbook" target="_blank" rel="noopener">https://github.com/openglredbook</a>    “openGL RedBook Github”<br><a href="https://www.cnblogs.com/caster99/p/4752354.html" title="OpenGL红宝书：第一个渲染程序Triangles常见问题归总 - caster99" target="_blank" rel="noopener">2</a>: <a href="https://www.cnblogs.com/caster99/p/4752354.html" target="_blank" rel="noopener">https://www.cnblogs.com/caster99/p/4752354.html</a>    “OpenGL红宝书：第一个渲染程序Triangles常见问题归总 - caster99”<br><a href="http://www.360doc.com/content/14/1028/10/19175681_420522404.shtml" title="OpenGL学习脚印：基本图形绘制方式比较（glBegin, glCallList, glVertexPointer, VBO）- 方海龙的书馆" target="_blank" rel="noopener">3</a>: <a href="http://www.360doc.com/content/14/1028/10/19175681_420522404.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/14/1028/10/19175681_420522404.shtml</a>    “OpenGL学习脚印：基本图形绘制方式比较（glBegin, glCallList, glVertexPointer, VBO）- 方海龙的书馆”<br><a href="https://blog.csdn.net/chunyexiyu/article/details/89224004" title="Mac上构建OpenGL红宝书上的triangles程序-春夜喜雨" target="_blank" rel="noopener">4</a>: <a href="https://blog.csdn.net/chunyexiyu/article/details/89224004" target="_blank" rel="noopener">https://blog.csdn.net/chunyexiyu/article/details/89224004</a>    “Mac上构建OpenGL红宝书上的triangles程序-春夜喜雨”</p><h2 id="最后的LoadShaders-cpp"><a href="#最后的LoadShaders-cpp" class="headerlink" title="最后的LoadShaders.cpp"></a>最后的LoadShaders.cpp</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment" spellcheck="true">//#include &lt;GL3/gl3w.h></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"LoadShaders.hpp"</span></span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">// __cplusplus</span><span class="token comment" spellcheck="true">//----------------------------------------------------------------------------</span><span class="token keyword">static</span> <span class="token keyword">const</span> GLchar<span class="token operator">*</span><span class="token function">ReadShader</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> filename <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> WIN32</span>    FILE<span class="token operator">*</span> infile<span class="token punctuation">;</span>    <span class="token function">fopen_s</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>infile<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token string">"rb"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    FILE<span class="token operator">*</span> infile <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span> filename<span class="token punctuation">,</span> <span class="token string">"rb"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">// WIN32</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>infile <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> _DEBUG</span>        std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Unable to open file '"</span> <span class="token operator">&lt;&lt;</span> filename <span class="token operator">&lt;&lt;</span> <span class="token string">"'"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">/* DEBUG */</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">fseek</span><span class="token punctuation">(</span> infile<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SEEK_END <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">ftell</span><span class="token punctuation">(</span> infile <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fseek</span><span class="token punctuation">(</span> infile<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SEEK_SET <span class="token punctuation">)</span><span class="token punctuation">;</span>    GLchar<span class="token operator">*</span> source <span class="token operator">=</span> <span class="token keyword">new</span> GLchar<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">fread</span><span class="token punctuation">(</span> source<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> infile <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span> infile <span class="token punctuation">)</span><span class="token punctuation">;</span>    source<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> GLchar<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//----------------------------------------------------------------------------</span>GLuint<span class="token function">LoadShaders</span><span class="token punctuation">(</span>ShaderInfo<span class="token operator">*</span> shaders<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> shaders <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    GLuint program <span class="token operator">=</span> <span class="token function">glCreateProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ShaderInfo<span class="token operator">*</span> entry <span class="token operator">=</span> shaders<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> entry<span class="token operator">-</span><span class="token operator">></span>type <span class="token operator">!=</span> GL_NONE <span class="token punctuation">)</span> <span class="token punctuation">{</span>        GLuint shader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span> entry<span class="token operator">-</span><span class="token operator">></span>type <span class="token punctuation">)</span><span class="token punctuation">;</span>        entry<span class="token operator">-</span><span class="token operator">></span>shader <span class="token operator">=</span> shader<span class="token punctuation">;</span>        <span class="token keyword">const</span> GLchar<span class="token operator">*</span> source <span class="token operator">=</span> <span class="token function">ReadShader</span><span class="token punctuation">(</span> entry<span class="token operator">-</span><span class="token operator">></span>filename <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> source <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> entry <span class="token operator">=</span> shaders<span class="token punctuation">;</span> entry<span class="token operator">-</span><span class="token operator">></span>type <span class="token operator">!=</span> GL_NONE<span class="token punctuation">;</span> <span class="token operator">++</span>entry <span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">glDeleteShader</span><span class="token punctuation">(</span> entry<span class="token operator">-</span><span class="token operator">></span>shader <span class="token punctuation">)</span><span class="token punctuation">;</span>                entry<span class="token operator">-</span><span class="token operator">></span>shader <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">glShaderSource</span><span class="token punctuation">(</span> shader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>source<span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> source<span class="token punctuation">;</span>        <span class="token function">glCompileShader</span><span class="token punctuation">(</span> shader <span class="token punctuation">)</span><span class="token punctuation">;</span>        GLint compiled<span class="token punctuation">;</span>        <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span> shader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>compiled <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>compiled <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> _DEBUG</span>            GLsizei len<span class="token punctuation">;</span>            <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span> shader<span class="token punctuation">,</span> GL_INFO_LOG_LENGTH<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len <span class="token punctuation">)</span><span class="token punctuation">;</span>            GLchar<span class="token operator">*</span> log <span class="token operator">=</span> <span class="token keyword">new</span> GLchar<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span> shader<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">,</span> log <span class="token punctuation">)</span><span class="token punctuation">;</span>            std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Shader compilation failed: "</span> <span class="token operator">&lt;&lt;</span> log <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> log<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">/* DEBUG */</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">glAttachShader</span><span class="token punctuation">(</span> program<span class="token punctuation">,</span> shader <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>entry<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">glLinkProgram</span><span class="token punctuation">(</span> program <span class="token punctuation">)</span><span class="token punctuation">;</span>    GLint linked<span class="token punctuation">;</span>    <span class="token function">glGetProgramiv</span><span class="token punctuation">(</span> program<span class="token punctuation">,</span> GL_LINK_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>linked <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>linked <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> _DEBUG</span>        GLsizei len<span class="token punctuation">;</span>        <span class="token function">glGetProgramiv</span><span class="token punctuation">(</span> program<span class="token punctuation">,</span> GL_INFO_LOG_LENGTH<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len <span class="token punctuation">)</span><span class="token punctuation">;</span>        GLchar<span class="token operator">*</span> log <span class="token operator">=</span> <span class="token keyword">new</span> GLchar<span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">glGetProgramInfoLog</span><span class="token punctuation">(</span> program<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">,</span> log <span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Shader linking failed: "</span> <span class="token operator">&lt;&lt;</span> log <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> log<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">/* DEBUG */</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> entry <span class="token operator">=</span> shaders<span class="token punctuation">;</span> entry<span class="token operator">-</span><span class="token operator">></span>type <span class="token operator">!=</span> GL_NONE<span class="token punctuation">;</span> <span class="token operator">++</span>entry <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">glDeleteShader</span><span class="token punctuation">(</span> entry<span class="token operator">-</span><span class="token operator">></span>shader <span class="token punctuation">)</span><span class="token punctuation">;</span>            entry<span class="token operator">-</span><span class="token operator">></span>shader <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> program<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//----------------------------------------------------------------------------</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">// __cplusplus</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data概念篇DM（二）数据</title>
      <link href="/data-concept-dm-02/"/>
      <url>/data-concept-dm-02/</url>
      
        <content type="html"><![CDATA[<h1 id="Data概念篇DM（二）数据"><a href="#Data概念篇DM（二）数据" class="headerlink" title="Data概念篇DM（二）数据"></a>Data概念篇DM（二）数据</h1><ul><li>参《数据挖掘导论（完整版）》第二章</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><strong>数据集</strong>可以看作<strong>数据对象</strong>的集合。</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p><strong>什么是属性？</strong></p><ul><li><strong>属性</strong>（attribute）是对象的性质或特性，因对象而变，随时间而变。</li><li><strong>测量标度</strong>（measurement scale）是将数值或符号值与对象的属性相关联的规则（函数）。</li></ul></li><li><p><strong>属性类型</strong></p><ul><li>通常将属性的类型称为<strong>测量标度的类型</strong>。</li></ul></li><li><p><strong>属性的不同类型</strong></p><p><img src="./03-01.png" alt="03-01 属性的不同类型"></p></li><li><p><strong>用值的个数描述属性</strong></p><ul><li><strong>离散的</strong>（discrete），二元属性（Binary attribute）</li><li><strong>连续的</strong>（continuous）</li></ul></li><li><p><strong>非对称的属性</strong></p><ul><li>非对称的属性（asymmetric attribute）</li></ul></li></ul><h3 id="数据集的类型"><a href="#数据集的类型" class="headerlink" title="数据集的类型"></a>数据集的类型</h3><ul><li><strong>数据集的一般特性</strong><ul><li>维度（dimensionality）</li><li>稀疏性（sparsity）</li><li>分辨率（resolution）</li></ul></li><li><strong>记录数据</strong><ul><li>事务数据（transaction data）、购物车数据（market basket data）</li><li>数据矩阵</li><li>稀疏数据矩阵：文档-词矩阵（document-term matrix）</li></ul></li><li><strong>基于图形的数据</strong><ul><li>带有对象之间联系的数据：如链接的网页</li><li>具有图形对象的数据</li></ul></li><li><strong>有序的数据</strong><ul><li><strong>时序数据</strong>（sequential）/ <strong>时间数据</strong>（temporal data）</li><li><strong>序列数据</strong>（sequence data）</li><li><strong>时间序列数据</strong>（time series data）</li><li><strong>空间数据</strong></li></ul></li></ul><h2 id="数据质量"><a href="#数据质量" class="headerlink" title="数据质量"></a>数据质量</h2><ul><li>两个问题：<ul><li>数据质量问题的检测和纠正（<strong>数据清理</strong> data cleaning）；</li><li>使用可以容忍低质量数据的算法。</li></ul></li></ul><h3 id="测量和数据收集问题"><a href="#测量和数据收集问题" class="headerlink" title="测量和数据收集问题"></a>测量和数据收集问题</h3><ul><li><strong>测量误差</strong>（measurement error）和<strong>数据收集错误</strong>（data collection error）</li><li><strong>噪声</strong>（测量误差的随机部分）和<strong>伪像</strong>（artifact，更确定性现象结果的数据错误）</li><li><strong>精度</strong>（precision）、<strong>偏倚</strong>（bias）、<strong>准确率</strong>（accuracy）</li><li><strong>离群点</strong>（outlier）、<strong>异常</strong>（anomalous）</li><li><strong>遗漏值</strong><ul><li>处理方法：删除数据对象或属性；估计遗漏值；在分析时忽略遗漏值</li></ul></li><li><strong>不一致的值</strong></li><li><strong>重复</strong>：去重复（deduplication）</li></ul><h3 id="关于应用的问题"><a href="#关于应用的问题" class="headerlink" title="关于应用的问题"></a>关于应用的问题</h3><ul><li><strong>时效性</strong>和<strong>相关性</strong></li><li><strong>抽样偏倚</strong>（sampling bias）</li></ul><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><ul><li>属性（attribute）：特征（feature）、变量（variable）</li></ul><h3 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h3><ul><li><strong>聚集</strong>（aggregation）：将两个或多个对象合并成单个对象。<ul><li>可以看作是删除属性或压缩特定属性不同值个数的过程</li></ul></li><li>动机：<ul><li>数据规约减小数据，减小内存需求和处理时间</li><li>通过高层视图，起到了规范或标度转换的作用</li><li>聚集后行为更加稳定</li></ul></li></ul><h3 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a>抽样</h3><ul><li><strong>抽样</strong>是一种选择数据对象子集进行分析的常用方法，抽样具有代表性。</li><li><strong>抽样方法：</strong><ul><li><strong>简单随机抽样</strong>（sample random sampling）：无放回/有放回</li><li><strong>分层抽样</strong>（stratified sampling）</li></ul></li><li><strong>渐进抽样</strong>（progressive sampling）、<strong>自适应</strong>（adaptive）</li></ul><h3 id="维规约"><a href="#维规约" class="headerlink" title="维规约"></a>维规约</h3><ul><li><strong>维规约</strong>：通过创建新属性，将一些旧属性合并在一起来降低数据集的维度（特征子集选择或特征选择）</li><li><strong>好处</strong><ul><li>使模型更容易理解；</li><li>更容易让数据可视化；</li><li>降低了数据挖掘算法的时间和内存需求。</li></ul></li><li><strong>维灾难</strong>：高维数据，分类准确率降低，聚类质量下降</li><li><strong>维规约的线性代数技术</strong>：主成分分析（Principal Components Analysis, PCA）、奇异值分解（Singular Value Decomposition, SVD）</li></ul><h3 id="特征子集选择"><a href="#特征子集选择" class="headerlink" title="特征子集选择"></a>特征子集选择</h3><ul><li>存在，<strong>冗余特征</strong>、<strong>不相关特征</strong></li><li><strong>理想方法</strong>：将所有可能的特征子集作为感兴趣的数据挖掘算法的输入，然后选取产生最好结果的子集。</li><li><strong>嵌入方法</strong>（embedded approach）：算法本身决定使用哪些属性和忽略哪些属性</li><li><strong>过滤方法</strong>（filter approach）</li><li><strong>包装方法</strong>（wrapper approach）</li></ul><h3 id="特征创建"><a href="#特征创建" class="headerlink" title="特征创建"></a>特征创建</h3><ul><li><strong>特征提取</strong>（feature extraction）：由原始数据创建新的特征集</li><li><strong>映射数据到新的空间</strong><ul><li>傅立叶变换（Fourier transform）、小波变换（wavelet transform）</li></ul></li><li><strong>特征构造</strong></li></ul><h3 id="离散化和二元化"><a href="#离散化和二元化" class="headerlink" title="离散化和二元化"></a>离散化和二元化</h3><ul><li><p><strong>离散化</strong>（discretization）、<strong>二元化</strong>（binarization）</p></li><li><p>连续属性离散化</p><ul><li><strong>非监督离散化</strong><ul><li>等宽（equal width）、等频率（equal frequency）、等深（equal depth）、K均值、目测监测数据</li></ul></li><li><strong>监督离散化</strong><ul><li><strong>熵</strong>（entropy）<ul><li>$e_i=-\sum^k_{j=1}P_{ij}\log_2P_{ij}$</li><li>$e=\sum^n_{i=1}w_ie_i$</li></ul></li></ul></li></ul></li></ul><h3 id="变量转换"><a href="#变量转换" class="headerlink" title="变量转换"></a>变量转换</h3><ul><li><strong>变量转换</strong>（variable transformation）</li><li><strong>简单函数</strong></li><li><strong>规范化</strong>（standardization）或<strong>标准化</strong>（normalization）</li></ul><h2 id="相似性和相异性的度量"><a href="#相似性和相异性的度量" class="headerlink" title="相似性和相异性的度量"></a>相似性和相异性的度量</h2><ul><li>常用<strong>邻近度</strong>（proximity）表示相似性或相异性。</li></ul><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li><strong>定义</strong><ul><li><strong>相似度</strong>（similarity）、<strong>相异度</strong>（dissimilarity）</li></ul></li><li><strong>距离</strong></li></ul><h3 id="简单属性之间的相似度和相异度"><a href="#简单属性之间的相似度和相异度" class="headerlink" title="简单属性之间的相似度和相异度"></a>简单属性之间的相似度和相异度</h3><p><img src="./04-01.png" alt="04-01 简单属性之间的相似度和相异度"></p><h3 id="数据对象之间的相异度"><a href="#数据对象之间的相异度" class="headerlink" title="数据对象之间的相异度"></a>数据对象之间的相异度</h3><ul><li><strong>距离</strong><ul><li><strong>欧几里得距离</strong>（Euclidean distance）：$d(x,y)=\sqrt{\sum^n_{k=1}(x_k-y_k)^2}$</li><li><strong>距离矩阵</strong>（distance matrix）</li><li><strong>闵可夫斯基距离</strong>（Minkowski distance）：$d(x,y)=(\sum^n_{k=1}|x_k-y_k|^r)^{1/r}$<ul><li>$r=1$，汉明距离（Hamming distance）</li><li>$r=2$，欧几里得距离（$L_2$范数）</li><li>$r=\infty$，上确界（$L_{max}$或$L_{\infty}$范数）距离</li></ul></li></ul></li><li><strong>度量</strong>（metric）性质<ul><li>非负性</li><li>对称性</li><li>三角不等式</li></ul></li></ul><h3 id="数据对象之间的相似度"><a href="#数据对象之间的相似度" class="headerlink" title="数据对象之间的相似度"></a>数据对象之间的相似度</h3><ul><li>相似度性质<ul><li>仅当$x=y$时，$s(x,y)=1$。（$0\le s\le1$）</li><li>对于所有x和y，$s(x,y)=s(y,x)$。（对称性）</li></ul></li><li>非对称相似性度量<ul><li>混淆矩阵（confusion matrix）：记录每个字符被分类为自己的次数和被分类为另一个字符的次数</li></ul></li></ul><h3 id="邻近性度量的例子"><a href="#邻近性度量的例子" class="headerlink" title="邻近性度量的例子"></a>邻近性度量的例子</h3><ul><li><strong>二元数据的相似性度量</strong><ul><li><strong>相似系数</strong>（similarity coefficient）</li><li><strong>简单匹配系数</strong>（Simple Matching Coefficient, SMC）<ul><li>$SMC=\frac{值匹配的属性个数}{属性个数}=\frac{f_{11}+f_{00}}{f_{01}+f_{10}+f_{11}+f_{00}}$</li></ul></li><li><strong>Jaccard系数</strong>（Jaccard Cofficient）<ul><li>$J=\frac{匹配的个数}{不涉及0-0匹配的属性个数}=\frac{f_{11}}{f_{01}+f_{10}+f_{11}}$</li></ul></li></ul></li><li><strong>余弦相似度</strong><ul><li><strong>余弦相似度</strong>（cosine similarity）<ul><li>$\cos(x,y)=\frac{x\cdot y}{||x||||y||}$</li><li>$x\cdot y=\sum^n_{k=1}x_ky_k$</li><li>$||x||=\sqrt{\sum^n_{k=1}x^2_k}=\sqrt{x\cdot x}$</li></ul></li></ul></li><li><strong>广义Jaccard系数</strong><ul><li><strong>广义Jaccard系数</strong>又称<strong>Tanimoto系数</strong></li><li>$EJ(x,y)=\frac{x\cdot y}{||x||^2+||y||^2-x\cdot y}$</li></ul></li><li><strong>相关性</strong><ul><li><strong>皮尔森相关</strong>（Pearson’s correlation）系数<ul><li>$corr(x,y)=\frac{covariance(x,y)}{standard_deviation(x)\times standard_deviation(y)}=\frac{s_{xy}}{s_xs_y}$</li><li>$covariance(x,y)=s_{xy}=\frac{1}{n-1}\sum^n_{k-1}(x_k-\overline x)(y_k-\overline y)$</li><li>$standard_deviation(x)=s_x=\sqrt{\frac{1}{n-1}\sum^n_{k=1}(x_k-\overline x)^2}$</li><li>$standard_deviation(y)=s_x=\sqrt{\frac{1}{n-1}\sum^n_{k=1}(y_k-\overline y)^2}$</li></ul></li><li><strong>非线性相关</strong>：如果相关度为0，则两个数据对象的属性之间不存在线性关系，然而，仍然可能存在非线性关系。</li><li><strong>Bregman散度</strong>：损失或失真函数<ul><li>$D(x,y)=\phi(x)-\phi(y)-&lt;\nabla(y),(x-y)&gt;$</li></ul></li></ul></li></ul><h3 id="邻近度计算问题"><a href="#邻近度计算问题" class="headerlink" title="邻近度计算问题"></a>邻近度计算问题</h3><ul><li><strong>距离度量的标准化和相关性</strong><ul><li><strong>Mahalanobid距离：</strong>$mahalanobis(x,y)=(x-y)\sum^{-1}(x-y)^T$</li></ul></li><li><strong>组合异种属性的相似度</strong></li><li><strong>使用权值</strong></li></ul><h3 id="选取正确的邻近性度量"><a href="#选取正确的邻近性度量" class="headerlink" title="选取正确的邻近性度量"></a>选取正确的邻近性度量</h3>]]></content>
      
      
      <categories>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Mining </tag>
            
            <tag> Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data概念篇DM（一）数据挖掘基础概念</title>
      <link href="/data-concept-dm-01/"/>
      <url>/data-concept-dm-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Data概念篇DM（一）数据挖掘基础概念"><a href="#Data概念篇DM（一）数据挖掘基础概念" class="headerlink" title="Data概念篇DM（一）数据挖掘基础概念"></a>Data概念篇DM（一）数据挖掘基础概念</h1><ul><li>参《数据挖掘导论（完整版）》第一章</li></ul><h2 id="什么是数据挖掘？"><a href="#什么是数据挖掘？" class="headerlink" title="什么是数据挖掘？"></a>什么是数据挖掘？</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>数据挖掘是一种<strong>技术</strong>，将<strong>传统的数据分析方法</strong>与<strong>处理大量数据的复杂算法</strong>相结合。</li><li>数据挖掘是在大型数据存储库中，自动地发现有用信息的过程。数据挖掘技术用来探查大型数据库，发现先前未知的有用模式，还可以预测未来观测结果。</li></ul><h3 id="数据挖掘与知识发现"><a href="#数据挖掘与知识发现" class="headerlink" title="数据挖掘与知识发现"></a>数据挖掘与知识发现</h3><ul><li><p>数据挖掘是<strong>数据库中知识发现</strong>（knowledge discovery in database, KDD）不可缺少的一部分，KDD是将未加工的数据转换为有用信息的整个过程，如下图所示，</p><p><img src="./01-01.png" alt="01-01 KDD"></p></li><li><p>各个步骤：</p><ul><li><strong>输入数据：</strong>可以以各种形式存储，可以驻留在集中的数据存储库或分布在多个站点上。</li><li><strong>数据预处理</strong>（preprocessing）：将未加工的输入数据转换成适合分析的形式。<ul><li>包含<strong>融合</strong>来自多个数据源的数据、<strong>清洗</strong>数据以消除<strong>噪声</strong>和<strong>重复</strong>的观测值、<strong>选择</strong>与当前数据挖掘任务相关的记录和特征。</li><li>特征选择、维规约、规范化、选择数据子集</li></ul></li><li><strong>后处理：</strong>将有效的和有用的结果集成到决策支持系统中。<ul><li>可视化；使用统计度量或假设检验，删除虚假的数据挖掘结果。</li></ul></li></ul></li></ul><h2 id="数据问题需要的问题"><a href="#数据问题需要的问题" class="headerlink" title="数据问题需要的问题"></a>数据问题需要的问题</h2><ul><li><strong>可伸缩</strong>（scalable）<ul><li>使用特殊的搜索策略处理指数级搜索问题、实现新的数据结构、非内存算法、使用抽样技术或开发并行和分布算法</li></ul></li><li><strong>高维度</strong></li><li><strong>异种数据和复杂数据</strong></li><li><strong>数据的所有权与分布</strong></li><li><strong>非传统的分析</strong><ul><li>传统的统计方法基于<strong>假设-验证模式</strong></li></ul></li></ul><h2 id="数据挖掘的起源"><a href="#数据挖掘的起源" class="headerlink" title="数据挖掘的起源"></a>数据挖掘的起源</h2><ul><li><strong>统计学</strong>的抽样、估计和假设检验</li><li><strong>人工智能</strong>、<strong>模式识别</strong>和<strong>机器学习</strong>的搜索算法、建模技术和学习理论</li><li>其它领域，包括最优化、进化计算、信息论、信号处理、可视化和信息检索</li><li>其它方面，数据库系统、高性能（并行）计算、分布式技术</li></ul><h2 id="数据挖掘任务"><a href="#数据挖掘任务" class="headerlink" title="数据挖掘任务"></a>数据挖掘任务</h2><ul><li>两大类：<ul><li><strong>预测任务</strong>：根据其它属性的值（<strong>说明变量</strong>或<strong>自变量</strong>），预测特定属性的值（<strong>目标变量</strong>或<strong>因变量</strong>）</li><li><strong>描述任务</strong>：导出概括数据中潜在练习的模式（相关、趋势、聚类、轨迹和异常）</li></ul></li><li><strong>预测建模</strong>（predictive modeling）：以说明变量函数的方式为目标变量建立模型<ul><li><strong>分类</strong>（classification）：预测离散的目标变量</li><li><strong>回归</strong>（regression）：预测连续的目标变量</li></ul></li><li><strong>关联分析</strong>（association analysis）：发现描述数据中强关联特征的模式<ul><li>应用：找出具有相关功能的基因组、识别用户、理解元素之间的联系</li></ul></li><li><strong>聚类分析</strong>（cluster analysis）：发现紧密相关的预测值组群<ul><li>应用：对相关的顾客分组、找出显著影响地球气候的海洋区域、压缩数据</li></ul></li><li><strong>异常检测</strong>（anomaly detection）：识别特征显著不同于其他数据的观测值<ul><li><strong>异常点</strong>（anomaly）或<strong>离群点</strong>（outlier）</li><li>好的异常检测器：高检测率、低误报率</li><li>应用：检测欺诈、网络攻击、疾病的不寻常模式、生物系统扰乱等</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Mining </tag>
            
            <tag> Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data总序篇：介绍与目录</title>
      <link href="/data-preface/"/>
      <url>/data-preface/</url>
      
        <content type="html"><![CDATA[<h1 id="Data总序篇：介绍与目录"><a href="#Data总序篇：介绍与目录" class="headerlink" title="Data总序篇：介绍与目录"></a>Data总序篇：介绍与目录</h1><h2 id="系列介绍"><a href="#系列介绍" class="headerlink" title="系列介绍"></a>系列介绍</h2><h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><ul><li>由于近期计划阅读、学习几本经典书籍，分别与数据挖掘、统计学方法与机器学习相关，所以计划编写一个系列的笔记。</li><li>由于这些内容存在着极多交叉相通的部分，所以希望能将其整合在一个系列之中，避免重复造轮子。</li><li>但另一方面，由于这些内容属于不同的主题，所以架构、展开方式存在着很大的差异，所以此系列的编排也存在着很大的挑战，希望能做好。最终取名为Data，是由于这些内容都与数据相关，所以就简单粗暴地命名了。</li></ul><h3 id="主要书目"><a href="#主要书目" class="headerlink" title="主要书目"></a>主要书目</h3><ul><li>整个系列的笔记，主要对应以下四本书：</li></ul><ol><li>《<a href="https://book.douban.com/subject/5377669/" target="_blank" rel="noopener">数据挖掘导论</a>》</li><li>《<a href="https://book.douban.com/subject/33437381/" target="_blank" rel="noopener">统计学习方法（第2版）</a>》</li><li>《<a href="https://book.douban.com/subject/26708119/" target="_blank" rel="noopener">机器学习</a>》</li><li>《<a href="https://book.douban.com/subject/10750155/" target="_blank" rel="noopener">数学之美</a>》</li></ol><ul><li>这几本书在豆瓣上的评分都在8分以上，而且都作为领域中的经典书籍，希望能尽早啃完了（不知道能多久了，希望不会断片了…）</li></ul><h3 id="编排思路"><a href="#编排思路" class="headerlink" title="编排思路"></a>编排思路</h3><ul><li>本系列计划分为<strong>总序篇</strong>、<strong>概念篇</strong>、<strong>方法篇</strong>和<strong>补充篇</strong>四个不同篇章主题。</li><li><strong>总序篇</strong>：此文，包含系列的介绍和全部目录。</li><li><strong>概念篇</strong>：包含一些概念的内容，如数据挖掘、机器学习、数据等基本概念的介绍，也包含如分类问题、聚类问题、监督学习、强化学习等概念的介绍。</li><li><strong>方法篇</strong>：介绍具体的模型和算法，如kNN模型、决策树模型、神经网络模型等内容。</li><li><strong>补充篇</strong>：一些补充内容，如历史、发展、数学基础等内容。</li></ul><h2 id="系列目录"><a href="#系列目录" class="headerlink" title="系列目录"></a>系列目录</h2><ul><li>持续更新，当前很贫穷。</li></ul><h3 id="总序篇"><a href="#总序篇" class="headerlink" title="总序篇"></a>总序篇</h3><table><thead><tr><th>题目</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://jirehchan.github.io/data-preface/" target="_blank" rel="noopener">Data总序篇：介绍与目录</a></td><td>关于整个Data系列的介绍以及目录信息</td></tr></tbody></table><h3 id="概念篇"><a href="#概念篇" class="headerlink" title="概念篇"></a>概念篇</h3><table><thead><tr><th>题目</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://jirehchan.github.io/data-concept-dm-01/" target="_blank" rel="noopener">Data概念篇DM（一）数据挖掘基础概念</a></td><td>数据挖掘的定义、问题、任务、应用</td></tr><tr><td><a href="https://jirehchan.github.io/data-concept-dm-02/" target="_blank" rel="noopener">Data概念篇DM（二）数据</a></td><td>数据的含义</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="方法篇"><a href="#方法篇" class="headerlink" title="方法篇"></a>方法篇</h3><table><thead><tr><th>题目</th><th>简介</th></tr></thead><tbody><tr><td>暂无</td><td>暂无</td></tr></tbody></table><h3 id="补充篇"><a href="#补充篇" class="headerlink" title="补充篇"></a>补充篇</h3><table><thead><tr><th>题目</th><th>简介</th></tr></thead><tbody><tr><td>暂无</td><td>暂无</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data </tag>
            
            <tag> Preface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记（二）渲染管线、FreeGLUT&amp;GLEW、简单示例</title>
      <link href="/opengl-02/"/>
      <url>/opengl-02/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenGL学习笔记（二）渲染管线、FreeGLUT-amp-GLEW、简单示例"><a href="#OpenGL学习笔记（二）渲染管线、FreeGLUT-amp-GLEW、简单示例" class="headerlink" title="OpenGL学习笔记（二）渲染管线、FreeGLUT&amp;GLEW、简单示例"></a>OpenGL学习笔记（二）渲染管线、FreeGLUT&amp;GLEW、简单示例</h1><h2 id="1-渲染管线"><a href="#1-渲染管线" class="headerlink" title="1. 渲染管线"></a>1. 渲染管线</h2><ul><li>主要整理自<a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" title="LearnOpenGL CN - 你好，三角形" target="_blank" rel="noopener">[1]</a></li></ul><h3 id="图形渲染管线（Graphics-Pipeline）"><a href="#图形渲染管线（Graphics-Pipeline）" class="headerlink" title="图形渲染管线（Graphics Pipeline）"></a>图形渲染管线（Graphics Pipeline）</h3><ul><li><p>OpenGL是一个3D图形库，即其中的所有事物都存储在3D空间中，而屏幕和窗口中则是显示为2D像素，<strong>图形渲染管线</strong>的作用就是实现2D坐标和3D坐标之间的互相转换。有以下两个部分：</p><ul><li>将3D坐标转换为2D坐标；</li><li>将2D坐标转变为实际有色的像素。</li></ul></li><li><p>图形渲染管线的各个阶段的展示图如下：</p><p><img src="./01-01.png" alt="01-01 图形渲染管线"></p></li><li><p><strong>着色器</strong>（Shader）是在渲染管线中，每个阶段上运行处理数据的小程序。OpenGL着色器是用<strong>OpenGL着色器语言</strong>（OpenGL Shading Language, GLSL）写成的。</p></li><li><p>接下来将逐一介绍渲染管线的各个阶段。</p></li></ul><h3 id="顶点数据（Vertex-Data）"><a href="#顶点数据（Vertex-Data）" class="headerlink" title="顶点数据（Vertex Data）"></a>顶点数据（Vertex Data）</h3><ul><li><p>顶点数据作为图形渲染管线的输入，是一系列<strong>顶点</strong>（Vertex）的集合。</p></li><li><p>顶点是一个3D坐标数据的集合，用<strong>顶点属性</strong>（Vertex Attribute）表示。</p></li><li><p>OpenGL中指定的坐标都是3D坐标，但只有在<strong>标准化设备坐标</strong>（Normalized Device Corrdinates NDC，即三个轴坐标都在-1.0到1.0的范围内）范围内的坐标才能呈现在屏幕上。</p><ul><li>标准化设备坐标之后会转化为<strong>屏幕空间坐标</strong>（Screen-space Coordinates），通过<em>glViewport</em>函数提供的数据，进行<strong>视口变换</strong>（Viewport Transform）完成。</li></ul></li><li><p>顶点数据定义后被传入顶点着色器中，会在GPU上创建内存用于存储顶点数据。通过<strong>顶点缓冲对象</strong>（Vertex Buffer Objects VBO）管理此内存，它会在GPU内存中存储大量顶点，然后批量发给显卡。</p></li><li><p><strong>顶点数组对象</strong>（Vertex Array Object, VAO）</p><ul><li>任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。</li></ul><p><img src="./01-02.png" alt="01-02 VAO与VBO"></p></li></ul><h3 id="顶点着色器（Vertex-Shader）"><a href="#顶点着色器（Vertex-Shader）" class="headerlink" title="顶点着色器（Vertex Shader）"></a>顶点着色器（Vertex Shader）</h3><ul><li><strong>顶点着色器</strong>是图形渲染管线的第一个部分，把一个单独的顶点作为输入。主要作用：<ul><li>把3D坐标转换为另一种3D坐标；</li><li>对顶点属性进行一些简单的处理。</li></ul></li></ul><h3 id="图元装配（Primitive-Assembly）"><a href="#图元装配（Primitive-Assembly）" class="headerlink" title="图元装配（Primitive Assembly）"></a>图元装配（Primitive Assembly）</h3><ul><li>将顶点着色器输出的所有顶点作为输入，将所有的点装配成制定图元的形状。</li></ul><h3 id="几何着色器（Geometry-Shader）"><a href="#几何着色器（Geometry-Shader）" class="headerlink" title="几何着色器（Geometry Shader）"></a>几何着色器（Geometry Shader）</h3><ul><li><strong>几何着色器</strong>把图元形式的一系列顶点的集合作为输入，可以通过产生新顶点构造出新的图元来生成其它形状。</li></ul><h3 id="光栅化（Rasterization）"><a href="#光栅化（Rasterization）" class="headerlink" title="光栅化（Rasterization）"></a>光栅化（Rasterization）</h3><ul><li><strong>光栅化</strong>把图元映射成对应的像素，生成片段（Fragment）。在<strong>片段着色器</strong>运行之前，会执行<strong>剪裁</strong>（Clipping）来提升执行效率。</li></ul><h3 id="片段着色器（Fragment-Shader）"><a href="#片段着色器（Fragment-Shader）" class="headerlink" title="片段着色器（Fragment Shader）"></a>片段着色器（Fragment Shader）</h3><ul><li><strong>片段着色器</strong>的主要目的是计算一个像素的最终颜色，也包含3D场景的数据（如光照、阴影、光的颜色等）。</li></ul><h3 id="Alpha测试和混合（Blending）"><a href="#Alpha测试和混合（Blending）" class="headerlink" title="Alpha测试和混合（Blending）"></a>Alpha测试和混合（Blending）</h3><ul><li>此阶段检测片段对应的深度，来判断这个像素对应其它物体的相对位置。也会检查alpha值来对物体进行混合。</li></ul><h2 id="2-FreeGLUT库-amp-GLEW库-配置"><a href="#2-FreeGLUT库-amp-GLEW库-配置" class="headerlink" title="2. FreeGLUT库 &amp; GLEW库 配置"></a>2. FreeGLUT库 &amp; GLEW库 配置</h2><ul><li>以下配置针对Mac上的Xcode配置，如是其他平台其它软件请自行百度，参考<a href="https://www.cnblogs.com/fanghao/p/7559768.html" title="Mac使用Xcode配置openGL -- 潇雨危栏" target="_blank" rel="noopener">[2]</a><a href="https://www.cnblogs.com/leojason/p/9619193.html" title="OpenGL学习之旅01—Xcode+OpenGL环境配置 -- LeoJason" target="_blank" rel="noopener">[3]</a>。（安装主要也是因为课程要求，汗）</li></ul><h3 id="库简介"><a href="#库简介" class="headerlink" title="库简介"></a>库简介</h3><ul><li><strong>FreeGLUT库</strong><ul><li>由于GLUT项目已被废弃（不再维护，无法修改），FreeGLUT是GLUT的一个完全开源替代库。</li></ul></li><li><strong>GLEW库</strong><ul><li>OpenGL扩展库，用于帮助C/C++开发者初始化扩展（OpenGL扩展功能）并书写可移植的应用程序。</li></ul></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p><strong>安装homebrew</strong></p><p>​    由于之前已经安装过了homebrew，是否当时使用的是以下命令已经不太清楚了，如果有问题 ，可以在网上寻找。</p><pre class=" language-shell"><code class="language-shell">$ ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</code></pre></li><li><p><strong>安装FreeGLUT</strong></p><pre class=" language-shell"><code class="language-shell">$ brew install freeglut</code></pre><p>​    安装中可能会提示需要先安装XQuartz，此时同样照着提示来安装，完成后再次brew即可。</p></li><li><p><strong>安装GLEW</strong></p><pre class=" language-shell"><code class="language-shell">$ brew install glew</code></pre><p>​    安装中可能会由于没有读写目录的权限的提示，此时只要按照终端的提示操作之后就可以了。</p></li><li><p><strong>安装后的库</strong></p><p>brew安装的目录在/usr/local/Cellar下，之后在Xcode中的配置会用到。</p></li></ol><h3 id="Xcode中的配置"><a href="#Xcode中的配置" class="headerlink" title="Xcode中的配置"></a>Xcode中的配置</h3><ol><li><p>打开Xcode，新建一个Command Line Tool项目。</p></li><li><p>在Build Settings中的Search Paths加入头文件、库文件搜索路径。</p><p><img src="./02-01.png" alt="02-01 加入搜索路径"></p></li><li><p>在Build Phases中Link Binary With Libraries中加入库</p><p>​    不知为何上步完成后仍是无法搜索到，只能手动添加文件了，另外不要忘了基本库OpenGL.framework哦。</p><p><img src="./02-02.png" alt="02-02 加入库"></p></li></ol><h2 id="3-简单示例"><a href="#3-简单示例" class="headerlink" title="3. 简单示例"></a>3. 简单示例</h2><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><ul><li><p>代码来自计算机图形学课程的讲义，绘制一个简单的三角形。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;GL/glew.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;GL/glut.h></span></span><span class="token keyword">void</span> <span class="token function">doMyInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glClearColor</span><span class="token punctuation">(</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Set the clear color to black</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">mydisplay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glClear</span><span class="token punctuation">(</span> GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Clear the frame buffer</span>    <span class="token function">glColor3f</span><span class="token punctuation">(</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Set current color to green</span>    <span class="token function">glBegin</span><span class="token punctuation">(</span> GL_TRIANGLES<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Draw the triangle</span>        <span class="token function">glVertex2f</span><span class="token punctuation">(</span> <span class="token operator">-</span><span class="token number">0.7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glVertex2f</span><span class="token punctuation">(</span> <span class="token number">0.7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">glVertex2f</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Force to display the new drawings immediately</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// initialize</span>    <span class="token function">glutInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitDisplayMode</span><span class="token punctuation">(</span>GLUT_RGB <span class="token operator">|</span> GLUT_SINGLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitWindowSize</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitWindowPosition</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutCreateWindow</span><span class="token punctuation">(</span><span class="token string">"Simple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glewInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">doMyInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//define callback functions</span>    <span class="token function">glutDisplayFunc</span><span class="token punctuation">(</span>mydisplay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutMainLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//main event loop</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="然而。。。"><a href="#然而。。。" class="headerlink" title="然而。。。"></a>然而。。。</h3><ul><li><p>结果是无法成功跑出结果，显示如下：</p><img src="./03-01.png" alt="03-01 失败截图" style="zoom:50%;"></li><li><p>尝试多次后，放弃了，似乎是因为FreeGLUT无法在Mac上编译shader，只能重新改回原生的GLUT.framework了。<strong>（在03中再次证实真的无法使用，还浪费了时间，哭了）</strong></p></li></ul><h3 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h3><ul><li><strong>代码部分</strong><ul><li>将 #include &lt;GL/glut.h&gt; 改为 #include &lt;GLUT/GLUT.h&gt;</li></ul></li><li>Build Phases中改为</li></ul><img src="./03-02.png" alt="03-02 修改后的库增加" style="zoom:75%;"><ul><li><p><strong>运行结果</strong></p><img src="./03-03.png" alt="03-03 运行结果" style="zoom:30%;"><ul><li>关于FreeGLUT的问题，等之后遇到无法解决时再加以考虑了，汗汗，目前只找到<a href="https://blog.csdn.net/fqrq88918329/article/details/50154863" title="MAC OS上使用OpenGL遇到的大坑 -- 热心的李大妈" target="_blank" rel="noopener">[4]</a>。</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]: <a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/</a>    “LearnOpenGL CN - 你好，三角形”<br><a href="https://www.cnblogs.com/fanghao/p/7559768.html" title="Mac使用Xcode配置openGL -- 潇雨危栏" target="_blank" rel="noopener">2</a>: <a href="https://www.cnblogs.com/fanghao/p/7559768.html" target="_blank" rel="noopener">https://www.cnblogs.com/fanghao/p/7559768.html</a>    “Mac使用Xcode配置openGL – 潇雨危栏”<br><a href="https://www.cnblogs.com/leojason/p/9619193.html" title="OpenGL学习之旅01—Xcode+OpenGL环境配置 -- LeoJason" target="_blank" rel="noopener">3</a>: <a href="https://www.cnblogs.com/leojason/p/9619193.html" target="_blank" rel="noopener">https://www.cnblogs.com/leojason/p/9619193.html</a>    “OpenGL学习之旅01—Xcode+OpenGL环境配置 – LeoJason”<br><a href="https://blog.csdn.net/fqrq88918329/article/details/50154863" title="MAC OS上使用OpenGL遇到的大坑 -- 热心的李大妈" target="_blank" rel="noopener">4</a>: <a href="https://blog.csdn.net/fqrq88918329/article/details/50154863" target="_blank" rel="noopener">https://blog.csdn.net/fqrq88918329/article/details/50154863</a>    “MAC OS上使用OpenGL遇到的大坑 – 热心的李大妈”</p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iPad软件个人推荐</title>
      <link href="/else-2019-01-ipadsoftware/"/>
      <url>/else-2019-01-ipadsoftware/</url>
      
        <content type="html"><![CDATA[<h1 id="iPad软件个人推荐"><a href="#iPad软件个人推荐" class="headerlink" title="iPad软件个人推荐"></a>iPad软件个人推荐</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>用iPad来做学习工具已经一个学习多了，鉴于身边有意向购买、使用iPad的人似乎日渐增多，写下此篇小文章来介绍一下我日常使用的几款不错的软件。另外，本人的设备包含iPad（第六代）和Pencil（一代，二代不支持iPad Air）。下面是iPad和pencil的照片（随便乱拍，不要介意，汗汗），另外是不是黑框的比白框的显得更大气、神秘、好看呢，吼吼～</p><p><img src="./01-01.png" alt="01-01 iPad照片"></p></li><li><p>好的，开始正文，本文介绍的软件主要是以下六款（<em>Notability</em>，<em>MindNode</em>，<em>Kindle</em>，<em>PDF Expert</em>，<em>Agenda</em>和iPad自带的<em>日历</em>），<strong>其中Notability, MindNode 和 PDF Expert 都是收费的软件哦</strong>。</p><p><img src="./01-02.png" alt="01-02 软件图标显示"></p></li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Notability"><a href="#1-Notability" class="headerlink" title="1. Notability"></a>1. Notability</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li><em>Notability</em> 主要作为一个<strong>笔记软件</strong>，搭配Pencil能发挥它的价值。不过由于我的课堂笔记一般用<em>MindNode</em>记成思维导图的形式，一些学习笔记则在电脑上用<em>Markdown</em>来记录，所以我的<em>Notability</em>主要用来写留言、打草稿、做会议记录之类的草记。</li></ul><h4 id="喜欢的点"><a href="#喜欢的点" class="headerlink" title="喜欢的点"></a>喜欢的点</h4><ul><li>框选复制：导出后，可以直接粘贴到其它软件变为图片格式，对于一些无法打出来的内容（如公式）还是很方便的选择；</li><li>画笔直线、圆形：长按停留后可以直接变为直线或圆形；</li><li>支持PDF格式：<em>Notability</em>中也可以导入pdf格式图片；</li></ul><h4 id="可能的局限"><a href="#可能的局限" class="headerlink" title="可能的局限"></a>可能的局限</h4><ul><li>无法输入公式，只能手写（不支持MarkDown）；</li></ul><h4 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h4><ul><li><p>下图左图是界面目录的截图，右侧是这学期的计算机图形学课程的图形处理流程的草图。</p><p><img src="./02-01.png" alt="02-01 Notability"></p></li></ul><h3 id="2-MindNode"><a href="#2-MindNode" class="headerlink" title="2. MindNode"></a>2. MindNode</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li><em>MindNode</em>是一款<strong>思维导图工具软件</strong>，帮助绘制思维导图。不过现在App Store中也有了一些新的免费的思维导图软件，像<em>XMind</em>之类的，不过绘制思维导图而言，<em>MindNode</em>是完全够用的，不过如果是新用户，可以先观察一下其它的软件，再做衡量。</li></ul><h4 id="喜欢的点-1"><a href="#喜欢的点-1" class="headerlink" title="喜欢的点"></a>喜欢的点</h4><ul><li>方便、直接的文件夹管理；</li><li>容易、便捷的绘制思维导图操作；</li><li>可以通过iCloud与Mac传输，可以导出其它格式；</li></ul><h4 id="可能的局限-1"><a href="#可能的局限-1" class="headerlink" title="可能的局限"></a>可能的局限</h4><ul><li>无法输入公式，只能以截图格式实现；</li><li>无法在思维导图外写入文本，有提供注释，但没法自己随意写；</li><li>思维导图铺得比较开，不够紧凑，感觉上会有很多闲置空间（效果看下图）；</li></ul><h4 id="软件截图-1"><a href="#软件截图-1" class="headerlink" title="软件截图"></a>软件截图</h4><ul><li><p>下图为<em>MindNode</em>的目录展示：</p><p><img src="./02-02.png" alt="02-02 MindNode 目录展示"></p></li><li><p>下图仍是计算机图形学课程第一章的思维导图展示（其中的加框图片就是从Notability中复制进来的）：</p><p><img src="./02-03.png" alt="02-03 MindNode 绘制图展示"></p></li></ul><h3 id="3-Kindle"><a href="#3-Kindle" class="headerlink" title="3. Kindle"></a>3. Kindle</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><ul><li><strong>电子书阅读器</strong>这个就不用说了，在亚马逊上购买好后，关联账户就可以直接阅读了，方便、快捷、省钱。是否购买主要还是看个人是否对亚马逊的电子书有需求（本人好多书都只看了一小部分，然后就结束了，汗颜）。</li></ul><h4 id="软件截图-2"><a href="#软件截图-2" class="headerlink" title="软件截图"></a>软件截图</h4><ul><li><p>下图，左侧为打开目录，右侧为《高性能MySQL》中的一页。</p><p><img src="./02-04.png" alt="02-04 Kindle"></p></li></ul><h3 id="4-PDF-Expert"><a href="#4-PDF-Expert" class="headerlink" title="4. PDF Expert"></a>4. PDF Expert</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><ul><li><strong>PDF阅读器</strong>，论文、PDF书籍的绝佳阅读软件。</li></ul><h4 id="喜欢的点-2"><a href="#喜欢的点-2" class="headerlink" title="喜欢的点"></a>喜欢的点</h4><ul><li>管理方便，注释、圈画便利，支持pencil直接手写；</li><li>可以双页展示、垂直滚动、水平翻滚；</li></ul><h4 id="可能的局限-2"><a href="#可能的局限-2" class="headerlink" title="可能的局限"></a>可能的局限</h4><ul><li>当PDF不是文件而是图片的时候，标记加下划线就只能一行一行画横线了（其实也还好啦）；</li></ul><h4 id="软件截图-3"><a href="#软件截图-3" class="headerlink" title="软件截图"></a>软件截图</h4><ul><li><p>同样的，左侧是我的Article文件夹下的目录情况，右图是其中一篇论文的打开情况。</p><p><img src="./02-05.png" alt="02-05 PDF Expert"></p></li></ul><h3 id="5-Agenda"><a href="#5-Agenda" class="headerlink" title="5. Agenda"></a>5. Agenda</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><ul><li>制定计划、目标、日志的软件，个人的话，目前日历软件取代了<em>Agenda</em>的一部分功能。</li></ul><h4 id="喜欢的点-3"><a href="#喜欢的点-3" class="headerlink" title="喜欢的点"></a>喜欢的点</h4><ul><li>免费！免费的！</li><li>可以方便的放目标（打勾的图框）；</li><li>能与日历关联，选择一天、一周还是其它的时长；</li></ul><h4 id="可能的局限-3"><a href="#可能的局限-3" class="headerlink" title="可能的局限"></a>可能的局限</h4><ul><li>主体的语言是英语（当然自己可以输入英文）；</li></ul><h4 id="软件截图-4"><a href="#软件截图-4" class="headerlink" title="软件截图"></a>软件截图</h4><ul><li><p>上面是一周的计划，下面是单日的。</p><p><img src="./02-06.png" alt="02-06 Agenda"></p></li></ul><h3 id="6-日历"><a href="#6-日历" class="headerlink" title="6. 日历"></a>6. 日历</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><ul><li>iPad自带的日历软件，最近几周才开始使用，才发现它的魅力——促进时间利用、督促自己（我比较懒，会浪费很多时间）。</li></ul><h4 id="喜欢的点-4"><a href="#喜欢的点-4" class="headerlink" title="喜欢的点"></a>喜欢的点</h4><ul><li>可以与mac、iphone直接关联提醒（由于我妈的iPhone用的是我的Apple ID，所以她也看得到我的，嘤嘤）；</li><li>方便设置时间段的安排，能督促学习，吼吼；</li></ul><h4 id="可能的局限-4"><a href="#可能的局限-4" class="headerlink" title="可能的局限"></a>可能的局限</h4><ul><li>没有更多的功能？</li></ul><h4 id="软件截图-5"><a href="#软件截图-5" class="headerlink" title="软件截图"></a>软件截图</h4><ul><li><p>下图就是展示了啦，安排、安排！（最近几天又开始犯懒不安排了，这不又弄到了凌晨了不是，太难了QAQ）</p><p><img src="./02-07.png" alt="02-07 日历的打开方式"></p></li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li>再说一次，<strong>其中Notability, MindNode 和 PDF Expert 都是收费的软件，收费的软件，收费的软件哦！</strong>另外，这些软件都是直接从App Store中下载的哦。</li><li>另外，软件再好，iPad再好，看了这篇文章你再心动，也未必有用哦！因为没有“用来学习”的觉悟与决心，或许你的iPad最后只能沦为一个看视频、玩游戏的设备了，很多人都这样，不用灰心，反正比手机屏幕大，看视频、玩游戏更快乐不是，嘿嘿～</li><li>最后一件事，国庆快乐～<strong>目标是星辰大海！</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Else </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ipad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记（一）简介&amp;初探</title>
      <link href="/opengl-01/"/>
      <url>/opengl-01/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenGL学习笔记（一）简介-amp-初探"><a href="#OpenGL学习笔记（一）简介-amp-初探" class="headerlink" title="OpenGL学习笔记（一）简介&amp;初探"></a>OpenGL学习笔记（一）简介&amp;初探</h1><h2 id="1-OpenGL"><a href="#1-OpenGL" class="headerlink" title="1. OpenGL"></a>1. OpenGL</h2><h3 id="OpenGL-简介"><a href="#OpenGL-简介" class="headerlink" title="OpenGL 简介"></a>OpenGL 简介</h3><ul><li><strong>OpenGL</strong>（Open Graphics Library，开放式图形库）是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序接口（API），包含了一系列可以操作图形、图像的函数。<a href="https://baike.baidu.com/item/OpenGL/238984?fr=aladdin" title="OpenGL-百度百科" target="_blank" rel="noopener">[1]</a><a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/" title="LearnOpenGL CN-入门" target="_blank" rel="noopener">[2]</a></li><li>OpenGL官网的描述其为”<em>The Industry’s Foundation for High Performance</em>“<a href="https://www.opengl.org" title="OpenGL 官网" target="_blank" rel="noopener">[3]</a>，OpenGL本身并不是一个API，仅仅是一个<strong>由Khronos组织制定并维护的规范</strong>（Specification）。OpenGL规范严格规定了每个函数如何运行，以及其输出输出值，而函数的具体实现，则由OpenGL库的开发者自行决定。<a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/" title="LearnOpenGL CN-入门" target="_blank" rel="noopener">[2]</a></li><li>实际上，通常是<strong>显卡的生产商</strong>开发具体的OpenGL库，如使用Apple系统时，OpenGL库是由Apple自身维护。当OpenGL产生bug时，可以通过<strong>升级显卡驱动</strong>解决。<a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/" title="LearnOpenGL CN-入门" target="_blank" rel="noopener">[2]</a></li></ul><h3 id="OpenGL-相关库"><a href="#OpenGL-相关库" class="headerlink" title="OpenGL 相关库"></a>OpenGL 相关库</h3><ul><li><strong>OpenGL core Library</strong><ul><li>OpenGL核心库</li></ul></li><li><strong>OpenGL Utility Library</strong>（GLU）</li><li><strong>OpenGL Utility Toolkit</strong>（GLUT）<ul><li>提供窗口系统的功能命令</li></ul></li><li><strong>freeglut</strong><ul><li>更新OpenGL的库</li></ul></li><li><strong>OpenGL Extension Wrangler Library</strong>（GLEW）</li></ul><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><ul><li>1980s，软件开发人员为每种图形硬件编写自定义的借口和驱动程序。</li><li>1990初，SGI成为工作站3D图形领域的领导者，其IRIS GL API成为事实上的行业标准。其竞争对手（Sun、惠普、IBM）通过扩展PHIGS标准也将3D硬件投入市场，SCI 将 IRIS GL API转变为一项开放标准，即OpenGL。</li><li>1992年，SCI领导OpenGL架构审查委员会（OpenGL ARB）的创建。</li><li>1995年，微软发布Direct3D成为OpenGL的主要竞争对手。</li><li>1997年12月17日，微软和SGI发起华氏温标项目，统一OpenGL和Direct3D接口。1998年，惠普加入，但项目于1999年停止。</li><li>2006年7月，OpenGL架构评审委员会将OpenGL API标准的控制权交给Khronos Group。 </li></ul><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>此部分主要参考<a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/" title="LearnOpenGL CN-入门" target="_blank" rel="noopener">[2]</a></li></ul><h4 id="核心模式-与-立即渲染模式"><a href="#核心模式-与-立即渲染模式" class="headerlink" title="核心模式 与 立即渲染模式"></a>核心模式 与 立即渲染模式</h4><ul><li><strong>立即渲染模式</strong>（Immediate mode, 固定渲染管线）：早期OpenGL使用，绘制图形容易使用和理解，但是效率较低。</li><li><strong>核心模式</strong>（Core-profile）：从OpenGL3.2后开始使用，移除了旧的特性，迫使用户使用现代的函数。</li></ul><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul><li><strong>扩展</strong>（Extension）：支持扩展，未成为规范之前，显卡公司提出的新特性或优化可以通过扩展的方式在驱动中实现。</li></ul><h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><ul><li>OpenGL自身是一个巨大的<strong>状态机</strong>（State Machine）：一系列的变量描述此时的OpenGL如何运行。OpenGL的状态通常被称为OpenGL上下文。</li><li>使用OpenGL时，使用<strong>状态设置函数</strong>（State-changing Function）与 <strong>状态使用函数</strong>（State-using Function）来进行操作。</li></ul><h2 id="2-初次尝试"><a href="#2-初次尝试" class="headerlink" title="2. 初次尝试"></a>2. 初次尝试</h2><ul><li>以下内容针对Mac上的Xcode（版本 Xcode11），其他平台的搭建还请参考网上的其他资源（MAC XCODE已自带GLUT.framework和OpenGL.framework，所以初次尝试不涉及“复杂”的环境配置）。以下内容参考<a href="https://www.cnblogs.com/chenyangsocool/p/5357691.html" title="Max Xcode 下配置OpenGL - chenyangsocool - 博客园" target="_blank" rel="noopener">[4]</a></li></ul><ol><li><p>打开Xcode，新建一个Command Line Tool项目。</p><p><img src="./02-01.png" alt="01-01 新建Command Line Tool项目"></p></li><li><p>添加GLUT.framework和OpenGL.framework</p><ol><li><p>点击Build Phases, Link Binary with Libraries</p><p><img src="./02-02.png" alt="01-02 添加库位置"></p></li><li><p>寻找、添加GLUT.framework和OpenGL.framework</p><p><img src="./02-03.png" alt="01-03 添加framework"></p></li><li><p>完成后效果</p><p><img src="./02-04.png" alt="01-04 添加后效果"></p></li></ol></li><li><p>进入main.cpp编写Demo代码并运行</p><ol><li><p>Demo代码</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//绘制一个正方形</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;GLUT/GLUT.h></span></span><span class="token keyword">void</span> <span class="token function">myDisplay</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glRectf</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glutInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitDisplayMode</span><span class="token punctuation">(</span>GLUT_RGB <span class="token operator">|</span> GLUT_SINGLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitWindowPosition</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitWindowSize</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutCreateWindow</span><span class="token punctuation">(</span><span class="token string">"第一个 OpenGL 程序"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutDisplayFunc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myDisplay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutMainLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>运行效果</p><img src="./02-05.png" alt="01-05" style="zoom:30%;"></li><li><p>由于在macOS 10.9、10.14 后一些命令被废止，会出现以下提示信息，下一篇会使用GLEW库。</p><p><img src="./02-06.png" alt="01-06 XCODE中的提示"></p></li></ol></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]: <a href="https://baike.baidu.com/item/OpenGL/238984?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/OpenGL/238984?fr=aladdin</a>    “OpenGL-百度百科”<br>[2]: <a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/</a>    “LearnOpenGL CN-入门”<br>[3]: <a href="https://www.opengl.org" target="_blank" rel="noopener">https://www.opengl.org</a>    “OpenGL 官网”<br>[4]: <a href="https://www.cnblogs.com/chenyangsocool/p/5357691.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenyangsocool/p/5357691.html</a>    “Max Xcode 下配置OpenGL - chenyangsocool - 博客园”</p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019论文阅读笔记&lt;03&gt;</title>
      <link href="/article-2019-03/"/>
      <url>/article-2019-03/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-论文阅读笔记-lt-03-gt"><a href="#2019-论文阅读笔记-lt-03-gt" class="headerlink" title="2019 论文阅读笔记 &lt;03&gt;"></a>2019 论文阅读笔记 &lt;03&gt;</h1><h2 id="【基本信息】"><a href="#【基本信息】" class="headerlink" title="【基本信息】"></a>【基本信息】</h2><ul><li><strong>论文题目：</strong><a href="http://papers.nips.cc/paper/7181-attention-is-all-you-need" target="_blank" rel="noopener">Attention is all you need</a></li><li><strong>作者：</strong>Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Adian N. Gomez, Łukasz Kaiser, Illia Polosukhin </li><li><strong>出版：</strong> <a href="http://papers.nips.cc/book/advances-in-neural-information-processing-systems-30-2017" target="_blank" rel="noopener">Advances in Neural Information Processing Systems 30 (NIPS 2017)</a></li><li><strong>日期：</strong>Submitted on 12 Jun 2017 （*<a href="https://arxiv.org/abs/1706.03762v1" target="_blank" rel="noopener">v1</a>*）, last revised 6 Dec 2017 （this version, v5）</li><li><strong>简介：</strong>此论文针对以往NLP中使用RNN结构和endoder-decoder结构无法并行、速度慢的问题，基于<strong>注意力机制</strong>提出了一种称为<strong>Transformer</strong>的网络结构。</li></ul><h2 id="【词汇术语】"><a href="#【词汇术语】" class="headerlink" title="【词汇术语】"></a>【词汇术语】</h2><h3 id="专业词汇-术语"><a href="#专业词汇-术语" class="headerlink" title="专业词汇/术语"></a>专业词汇/术语</h3><ul><li><strong>sequence transduction models</strong></li><li><strong>attention mechanism:</strong> 注意力机制</li></ul><h3 id="语言词汇"><a href="#语言词汇" class="headerlink" title="语言词汇"></a>语言词汇</h3><ul><li><strong>push the boundaries</strong></li><li><strong>integral</strong> 必需的</li></ul><h3 id="模型-模式-算法"><a href="#模型-模式-算法" class="headerlink" title="模型/模式/算法"></a>模型/模式/算法</h3><ul><li><strong>softmax</strong><ul><li>softmax用于多分类过程中，它将多个神经元的输出，映射到（0,1）区间内，可以看成概率来理解，从而来进行多分类</li><li>$S_i=\frac{e^i}{\sum_je^j}$</li></ul></li></ul><h2 id="【论文笔记】"><a href="#【论文笔记】" class="headerlink" title="【论文笔记】"></a>【论文笔记】</h2><h3 id="「简介前言」"><a href="#「简介前言」" class="headerlink" title="「简介前言」"></a>「简介前言」</h3><h4 id="当前缺陷"><a href="#当前缺陷" class="headerlink" title="当前缺陷"></a>当前缺陷</h4><ul><li><strong>RNN</strong><ul><li>前后状态的依赖性导致无法并行，在较长的词序时运行缓慢</li></ul></li><li><strong>当前努力</strong><ul><li>分解（factorization tricks）, 条件计算（conditional computation）</li><li><em>Neural GPU<em>，</em>ByteNet</em> 和 <em>ConvS2S</em></li><li>按序计算的限制仍然存在</li></ul></li></ul><h4 id="注意力机制（Attention-Mechanisms）"><a href="#注意力机制（Attention-Mechanisms）" class="headerlink" title="注意力机制（Attention Mechanisms）"></a>注意力机制（Attention Mechanisms）</h4><ul><li><strong>注意力机制</strong>（Attention Mechanisms）<ul><li>各种序列模型建模和转换模型中的一个组成部分（<em>an integral part of compelling sequence modeling and transduction models in various tasks</em>）</li><li>可以不用考虑在输入输出序列中的距离而允许建模</li><li>在少量情况，和循环网络结合使用</li></ul></li><li><strong>自注意力机制</strong>（Self-attention，intra-attention）<ul><li>把输入序列上不同位置的信息联系起来计算一个句子的表示内容</li></ul></li></ul><h3 id="「Transformer模型」"><a href="#「Transformer模型」" class="headerlink" title="「Transformer模型」"></a>「Transformer模型」</h3><h4 id="Encoder-Decoder"><a href="#Encoder-Decoder" class="headerlink" title="Encoder-Decoder"></a>Encoder-Decoder</h4><ul><li><p><strong>结构图</strong></p><p><img src="./03-01the-transformer-model-architecture.png" alt="03-01the-transformer-model-architecture"></p></li><li><p><strong>Encoder</strong></p><ul><li>由6个基本层堆叠</li><li>每层含有两个子层：<ul><li>注意力机制（<em>multi-head self-attention mechanism</em>）</li><li>全连接前向网络（<em>simple, position-wise fully connected feed-forward network</em>）</li></ul></li><li>在两个子层中都有剩余连接（<em>residual connection</em>）和层标准化（<em>layer normalization</em>）<ul><li>子层的输出：$LayerNorm(x+Sublayer(x))$</li></ul></li></ul></li><li><p><strong>Decoder</strong></p><ul><li>在encoder的输出外再增加了一层注意力机制</li><li>掩饰（<em>masking</em>）<ul><li>确保每个位置的预测只基于前面已知位置的词</li></ul></li></ul></li></ul><h4 id="注意力机制（Attention）"><a href="#注意力机制（Attention）" class="headerlink" title="注意力机制（Attention）"></a>注意力机制（Attention）</h4><ul><li><p><strong>注意力机制</strong></p><ul><li>将一个查找和一组键值对映射到正确的输出（<em>mapping a query and a set of key-value pairs to an output</em>）</li></ul><p><img src="./03-02tow-attention.png" alt="03-02tow-attention"></p></li><li><p><strong>Scaled Dot-Product Attention</strong></p><ul><li>$Attention(Q,K,V)=softmax(\frac{QK^T}{\sqrt{d_k}})V$</li><li>$d_k$：keys的维度；$d_v$：value的维度</li><li>$Q$：查询矩阵；$K$：keys的矩阵；$V$：values的矩阵</li></ul></li><li><p><strong>Multi-Head Attention</strong></p><ul><li>$MultiHead(Q,K,V)=Concat(head_1,…,head_h)W^{\bigcirc}$</li><li>$head_i=Attention(QW_i^Q,KW_i^K,VW_i^V)$</li></ul></li><li><p>文章使用的注意力机制</p><ul><li>Multi-Head Attention，三个方面：</li><li>Encoder-Decoder Attention层<ul><li>查询来自前一个decoder层，允许decoder的每个位置都能关注输入的所有位置</li></ul></li><li>Encoder层中的Self-attention层<ul><li>在self-attention层中所有的key、value和query都来自前一层的encoder，encoder的每个位置都能关注前一层输出的所有位置。</li></ul></li><li>Decoder层中的Self-attention层</li></ul></li></ul><h4 id="Position-wise-Feed-Forward-Networks"><a href="#Position-wise-Feed-Forward-Networks" class="headerlink" title="Position-wise Feed-Forward Networks"></a>Position-wise Feed-Forward Networks</h4><ul><li>每一层都有一个<strong>fukky connected feed-forward network</strong><ul><li>$FNN(x)=\max(0,xW_1+b_1)W_2+b_2$</li><li>两个线性转换，中间一个ReLU</li></ul></li></ul><h4 id="Embeddings-and-Softmax"><a href="#Embeddings-and-Softmax" class="headerlink" title="Embeddings and Softmax"></a>Embeddings and Softmax</h4><h4 id="位置编码（Positional-Encoding）"><a href="#位置编码（Positional-Encoding）" class="headerlink" title="位置编码（Positional Encoding）"></a>位置编码（Positional Encoding）</h4><ul><li>不使用递归结构和卷积结构，引入位置编码来使用输入顺序信息</li><li><strong>位置编码：</strong><ul><li>$PE_{(pos,2i)}=\sin(pos/10000^{2i/d_{model}})$</li><li>$PE_{(pos,2i+1)}=\cos(pos/10000^{2i/d_{model}})$</li><li>$pos$: position; $i$: dimension</li></ul></li><li>使用sin版本，因为它允许序列用到更长</li></ul><h3 id="「为什么使用自注意力机制」"><a href="#「为什么使用自注意力机制」" class="headerlink" title="「为什么使用自注意力机制」"></a>「为什么使用自注意力机制」</h3><ul><li>三个方面比较其与递归结构、卷积结构<ul><li>每层的计算复杂度（<em>total computational complexity per layer</em>）</li><li>能被并行计算的数量（<em>the amount of computation that can be parallelized</em>）</li><li>网络中长范围以来的路径长度（<em>the path length between long-range dependencies in the network</em>）</li></ul></li></ul><h3 id="「实验与结论」"><a href="#「实验与结论」" class="headerlink" title="「实验与结论」"></a>「实验与结论」</h3><ul><li>同前文，不加以赘述，有兴趣可以自行查看论文以及相关代码。</li></ul><h2 id="「小记总结」"><a href="#「小记总结」" class="headerlink" title="「小记总结」"></a>「小记总结」</h2><ul><li>论文中为提高并行能力，引入注意力机制代替递归结构和卷积结构，用位置编码来体现句子顺序信息。换种思路实现位置表示，NICE～是否还有其他方法，或者还有其他的耗时处理可以用更为简洁的方法来代替处理呢？</li></ul>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Article </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019论文阅读笔记&lt;02&gt;</title>
      <link href="/article-2019-02/"/>
      <url>/article-2019-02/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-论文阅读笔记-lt-02-gt"><a href="#2019-论文阅读笔记-lt-02-gt" class="headerlink" title="2019 论文阅读笔记 &lt;02&gt;"></a>2019 论文阅读笔记 &lt;02&gt;</h1><h2 id="【基本信息】"><a href="#【基本信息】" class="headerlink" title="【基本信息】"></a>【基本信息】</h2><ul><li><strong>论文题目：</strong><a href="https://www.aclweb.org/anthology/D14-1181/" target="_blank" rel="noopener">Convolutional Neural Networks for Sentence Classification</a></li><li><strong>作者：</strong>Yoon Kim</li><li><strong>组织：</strong>New York University</li><li><strong>出版：</strong>Association for Computational Linguistics</li><li><strong>关联：</strong>Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)</li><li><strong>日期：</strong>October 2014</li><li><strong>简介：</strong>此论文在CNN上使用词向量处理自然语言的问题，将词向量与深度学习（NLP与卷积神经网络）结合，并构建了一个简单的CNN模型进行实验，指出了词向量是神经网络对于自然语言处理的一个重要部分<em>（unsupervised pre-training of word vectors is an important ingredient in deep learning for NLP）</em>。</li></ul><h2 id="【词汇术语】"><a href="#【词汇术语】" class="headerlink" title="【词汇术语】"></a>【词汇术语】</h2><h3 id="专业词汇-术语"><a href="#专业词汇-术语" class="headerlink" title="专业词汇/术语"></a>专业词汇/术语</h3><ul><li><strong>tanh</strong>: hyperbolic tangent, 双曲正切函数</li><li><strong>pooling:</strong> 池化层，集中特征</li><li><strong>Regularization:</strong> 正则化<ul><li>给损失函数加一个正则化项</li><li><strong>l2-norms</strong></li></ul></li></ul><h3 id="语言词汇"><a href="#语言词汇" class="headerlink" title="语言词汇"></a>语言词汇</h3><ul><li><strong>utilize:</strong> 利用</li><li><strong>disentangle:</strong> 摆脱</li></ul><h3 id="模型-模式-算法"><a href="#模型-模式-算法" class="headerlink" title="模型/模式/算法"></a>模型/模式/算法</h3><ul><li>$\circ$: the element-wise multiplication operator<ul><li>数组对应元素相乘</li></ul></li><li><strong>Bernoulli random variables</strong>：伯努利随机变量<ul><li>01分布：$P(X=1)=p,\ P(x=1)=1-p$</li></ul></li><li><strong>norm:</strong> 范数<ul><li>$l_2-norms(||w||_2)$: 第二范数，欧几里得范数<ul><li>$||w||_2=\sqrt{x_1^2+x_2^2+…+x_n^2}$</li></ul></li></ul></li></ul><h2 id="【论文笔记】"><a href="#【论文笔记】" class="headerlink" title="【论文笔记】"></a>【论文笔记】</h2><h3 id="「简介内容」"><a href="#「简介内容」" class="headerlink" title="「简介内容」"></a>「简介内容」</h3><ul><li><strong>深度学习</strong>（Deep Learning）：当时主要应用于计算机视觉、语音识别，在自然语言处理方面，则用于特征分类上。</li><li><strong>词向量</strong>（Word Vectors）</li><li><strong>卷积神经网络</strong>（Convolutional neural networks, CNN）<ul><li>利用卷积过滤器层</li><li>最早用于计算机视觉</li><li>在语义分析上展现出能力</li></ul></li></ul><h3 id="「模型」"><a href="#「模型」" class="headerlink" title="「模型」"></a>「模型」</h3><h4 id="模型结构图"><a href="#模型结构图" class="headerlink" title="模型结构图    "></a>模型结构图    <img src="./02-01cnn-model-architecture.png" alt="CNN Model Architecture"></h4><h4 id="变量信息"><a href="#变量信息" class="headerlink" title="变量信息"></a>变量信息</h4><ul><li>$x_i$: $k$维词向量句子中的第$i$个词语</li><li>$x_{1:n}$: 长度为n的句子</li><li>$w$: 长度为$h$的窗口</li><li>特征: $c_i=f(w\cdot x_{i:i+h-1}+b)$<ul><li>$f$: 非线性函数</li><li>$b$: 偏移</li></ul></li><li>$\hat{c}=\max{c}$</li></ul><h4 id="各层信息"><a href="#各层信息" class="headerlink" title="各层信息"></a>各层信息</h4><ul><li><strong>池化层</strong>：max-pooling方法</li><li><strong>全连接层</strong>：softmax</li></ul><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><ul><li>正则化用于防止过拟合，常见是在损失函数中加入正则项（L1、L2正则化），本文采用的是DropOut方法。</li><li><strong>Dropout</strong><ul><li>训练中随机删掉隐藏层的一半节点进行学习，之后再对另一半节点进行一轮学习，最终将权重除以2。</li><li>减少了神经元间的依赖性，降低了过拟合，提高了准确率。</li></ul></li></ul><h3 id="「实验结论」"><a href="#「实验结论」" class="headerlink" title="「实验结论」"></a>「实验结论」</h3><ul><li>实验方法、结果不再重复，有兴趣可以自行阅读论文。</li><li>最重要的一点是，该论文指出词向量是神经网络对于自然语言处理的一个重要部分（<em>Our results add to the well-established evidence that unsupervised pre-training of word vectors is an important ingredient in deep learning for NLP.</em>）。</li></ul><h2 id="【小记总结】"><a href="#【小记总结】" class="headerlink" title="【小记总结】"></a>【小记总结】</h2><ul><li>此论文作为CNN与NLP结合的开山之作，虽然模型简单，但却极具价值和意义。创造性、拓展性的思维和能力，急需。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Article </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019论文阅读笔记&lt;01&gt;</title>
      <link href="/article-2019-01/"/>
      <url>/article-2019-01/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-论文阅读笔记-lt-01-gt"><a href="#2019-论文阅读笔记-lt-01-gt" class="headerlink" title="2019 论文阅读笔记 &lt;01&gt;"></a>2019 论文阅读笔记 &lt;01&gt;</h1><h2 id="【基本信息】"><a href="#【基本信息】" class="headerlink" title="【基本信息】"></a>【基本信息】</h2><ul><li><strong>论文题目：</strong> <em><a href="https://ieeexplore.ieee.org/document/7372153" target="_blank" rel="noopener">Entropy-Based Term Weighting Schemes for Text Categorization in VSM</a></em></li><li><strong>作者：</strong>Tao Wang ; Yi Cai ; Ho-fung Leung ; Zhiwei Cai ; Huaqing Min</li><li><strong>出版：</strong> <a href="https://ieeexplore.ieee.org/xpl/conhome/7372093/proceeding" target="_blank" rel="noopener">2015 IEEE 27th International Conference on Tools with Artificial Intelligence (ICTAI)</a></li><li><strong>日期：</strong>9-11 Nov. 2015 / 07 Jan 2016</li><li><strong>标签：</strong>TC、VSM</li><li><strong>简介：</strong>此论文分析了用于文本分类任务的一些权重法（如无监督学习中的$tf,tf\cdot idf,BM25$ 与监督学习中的$rf,iqf\cdot qf\cdot icf,tf\cdot gr$等），指出这些已有模式在文本分类中存在的问题，并提出了两种新的基于熵的权重法（$tf\cdot dc$ 和 $tf\cdot bdc$），提升了术语的辨别力与文本分类任务的完成。</li></ul><h2 id="【词汇术语】"><a href="#【词汇术语】" class="headerlink" title="【词汇术语】"></a>【词汇术语】</h2><h3 id="专业词汇-术语"><a href="#专业词汇-术语" class="headerlink" title="专业词汇/术语"></a>专业词汇/术语</h3><ul><li><strong>TC</strong> （Text Categorization）：文本分类</li><li><strong>VSM</strong> （Vector Space Model）：向量空间模型</li><li><strong>IR</strong> （Information Retrieval）：信息检索</li><li><strong>unsupervised</strong> &amp; <strong>supervised</strong>：无监督、监督</li><li><strong>Contingency Table</strong> 情形分析表<ul><li><strong>positive category （PC）</strong> ：正类</li><li><strong>negative category （NC）</strong>：负类</li></ul></li></ul><h3 id="语言词汇"><a href="#语言词汇" class="headerlink" title="语言词汇"></a>语言词汇</h3><ul><li><strong>state-of-the-art</strong>：当前最好的</li></ul><h3 id="模型-模式-算法"><a href="#模型-模式-算法" class="headerlink" title="模型/模式/算法"></a>模型/模式/算法</h3><ul><li><strong>KNN</strong> （k-Nearest Neighbor）：邻近算法</li><li><strong>SVM</strong> （Support Vector Machine）：支持向量机</li><li>$tf$：<strong>Term Frequency</strong> 词频<ul><li>$词频(TF)=某个词在文章中的出现次数$</li><li>$词频(TF)=\frac{某个词在文章中的出现次数}{文章的总词数}$</li><li>$词频(TF)=\frac{某个词在文章中的出现次数}{该文出现次数最多的词的出现次数}$</li><li>Variants: $\log(tf),\log(tf+1),log(tf)+1,…$</li></ul></li><li>$idf$: <strong>Inverse document frequency</strong> 逆文本频率指数<ul><li>$逆文档频率(IDF)=\log(\frac{语料库的文档总数}{包含该词的文档数+1})$</li><li>$df$: <strong>document frequency</strong></li><li>包含词条的文档越小，$idf$越大</li></ul></li><li>$dc$: <strong>distributional concentration</strong><ul><li>$dc(t)=1-\frac{H(t)}{\log(|C|)}=1+\frac{\sum^{|C|}_{i=1}\frac{f(t,c_i)}{f(t)}\log{\frac{f(t,c_i)}{f(t)}}}{\log{|C|}}$</li></ul></li><li>$rf$: <strong>relevance frequency</strong>, $rf=\frac{a}{c}$</li><li>$cf$: <strong>category frequency</strong>, 出现的类别越少，值越大</li><li>$bdc$: <strong>balanced distributional concentration</strong><ul><li>$bdc(t)=1-\frac{BH(t)}{\log(|C|)}=1+\frac{\sum^{|C|}_{i=1}\frac{p(t|c_i)}{\sum^{|C|}_{i=1}p(t|c_i)}\log{\frac{p(t|c_i)}{sum^{|C|}_{i=1}p(t|c_i)}}}{\log{|C|}}$</li></ul></li></ul><h2 id="【论文笔记】"><a href="#【论文笔记】" class="headerlink" title="【论文笔记】"></a>【论文笔记】</h2><h3 id="「已有方法-—-无监督学习方法」"><a href="#「已有方法-—-无监督学习方法」" class="headerlink" title="「已有方法 —- 无监督学习方法」"></a>「已有方法 —- 无监督学习方法」</h3><h4 id="无监督学习（unsupervised）"><a href="#无监督学习（unsupervised）" class="headerlink" title="无监督学习（unsupervised）"></a>无监督学习（unsupervised）</h4><ul><li><strong>含义：</strong>无先验知识（无标签）的学习</li><li><strong>常见模式：</strong>$tf,tf\cdot idf,BM25 $</li></ul><h4 id="缺点问题"><a href="#缺点问题" class="headerlink" title="缺点问题"></a>缺点问题</h4><ul><li><strong>【由于】</strong>关注于词出现的次数，而忽略了训练<em>文档（documents）<em>的</em>类别标签（category labels）</em></li><li><strong>【导致】</strong><ul><li><em>词语（term）</em>能区别文档的差异，但不能区别类别的差异</li><li>在文本分类任务中，不足以衡量词语对文档类别的<em>辨别能力（discriminating power）</em></li></ul></li></ul><h3 id="「已有方法-—-监督学习方法」"><a href="#「已有方法-—-监督学习方法」" class="headerlink" title="「已有方法 —- 监督学习方法」"></a>「已有方法 —- 监督学习方法」</h3><h4 id="监督学习（supervised）"><a href="#监督学习（supervised）" class="headerlink" title="监督学习（supervised）"></a>监督学习（supervised）</h4><ul><li><strong>含义：</strong>利用已知类别的样本进行学习</li><li><strong>常见模式：</strong>$rf,iqf\cdot qf\cdot icf,tf\cdot gr$</li></ul><h4 id="缺点问题-1"><a href="#缺点问题-1" class="headerlink" title="缺点问题"></a>缺点问题</h4><ul><li><strong>缘由：</strong>大部分监督学习用到了情形分析表中的正类（PC）和负类（NC）</li><li><strong>【由于】</strong>在<em>多类别的情况（multi-class case）</em>中，正类只有一个类，而负类是多个类的集合</li><li><strong>【导致】</strong>负类中产生了<em>信息损失（information loss）</em></li></ul><h4 id="已有优化仍然存在的问题"><a href="#已有优化仍然存在的问题" class="headerlink" title="已有优化仍然存在的问题"></a>已有优化仍然存在的问题</h4><ul><li><em>正类和负类的分离问题 （PC/NC-split based schemes）</em>仍然存在，使得无法有效区别类别。</li><li><em>一种基于统计置信区间的模式（a scheme based on statistical confidence intervals）</em><ul><li>过于复杂难以实现</li></ul></li></ul><h3 id="「基于熵的权重法」"><a href="#「基于熵的权重法」" class="headerlink" title="「基于熵的权重法」"></a>「基于熵的权重法」</h3><h4 id="基于熵的权重法（entropy-based-term-weighting-schemes）"><a href="#基于熵的权重法（entropy-based-term-weighting-schemes）" class="headerlink" title="基于熵的权重法（entropy- based term weighting schemes）"></a>基于熵的权重法（entropy- based term weighting schemes）</h4><ul><li><strong>观点</strong><ul><li>利用负类中的具体类别帮助提升辨别力</li><li><em>更高浓度（higher concentration）</em>的词语具有更强的辨别能力</li><li>在类别层面有更高浓度分布的词语的熵更小</li></ul></li><li>熵值越小，辨别能力越强</li></ul><h4 id="模式1-Distribution-Concentration"><a href="#模式1-Distribution-Concentration" class="headerlink" title="模式1: Distribution Concentration"></a>模式1: Distribution Concentration</h4><ul><li><strong>模式</strong>：$dc$, distribution concentration</li><li><strong>计算公式：</strong> $dc(t)=1-\frac{H(t)}{\log(|C|)}=1+\frac{\sum^{|C|}_{i=1}\frac{f(t,c_i)}{f(t)}\log{\frac{f(t,c_i)}{f(t)}}}{\log{|C|}}$<ul><li>$|C|$: 类别数量</li><li>$f(t,c_i)$: 表示词语 $t$ 在类别 $c_i$ 中出现的频率，这里使用 $df(t,c_i)$</li><li>$f(t)$: 词语 $t$ 在所有类别出现的频数和</li><li>$H(t)$: 词语 $t$ 在语料库中类别的熵，$H(t)\in [0,\log|C|]$</li></ul></li><li><strong>特征优势</strong><ul><li>词语的权重基于在类别中词语的全局分布，而不是依赖于已有的类别正类。</li><li>因此，不需要已有的正类标签就可以进行分类。</li></ul></li><li><strong>缺陷</strong><ul><li>缺少类别的优先级信息（不同种类文档的长度不同，会导致熵的计算产生偏差）<ul><li>$bdc$模式解决此问题</li></ul></li></ul></li></ul><h4 id="模式2-Balanced-Distributional-Concentration"><a href="#模式2-Balanced-Distributional-Concentration" class="headerlink" title="模式2: Balanced Distributional Concentration"></a>模式2: Balanced Distributional Concentration</h4><ul><li><strong>模式</strong>：$bdc$, balanced distributional concentration</li><li><strong>计算公式：</strong> $bdc(t)=1-\frac{BH(t)}{\log(|C|)}=1+\frac{\sum^{|C|}_{i=1}\frac{p(t|c_i)}{\sum^{|C|}_{i=1}p(t|c_i)}\log{\frac{p(t|c_i)}{sum^{|C|}_{i=1}p(t|c_i)}}}{\log{|C|}}$</li><li><strong>特征优势</strong><ul><li>解决了 $dc$ 模式存在的问题</li></ul></li></ul><h3 id="「实验结果」"><a href="#「实验结果」" class="headerlink" title="「实验结果」"></a>「实验结果」</h3><ul><li>此处对于实验的数据、内容、结论不做详细描述，有兴趣可以自行查看论文。</li></ul><h2 id="【小记总结】"><a href="#【小记总结】" class="headerlink" title="【小记总结】"></a>【小记总结】</h2><ul><li>2019论文博客整理的第一篇，希望能坚持，不足之处还请谅解。许多的英文词汇转为中文总有些怪异的感觉，就保留在中文词后面了。</li><li>此论文指出了过往文本分类任务中一些模式（scheme, 这个词翻译成模式也觉得读起来不太顺口，汗）的缺陷，无法很好地利用标签信息、区别类别差异，因而引入了熵的概念。一种角度来说，也是更充分地利用“压榨”已有信息（无监督学习模式忽略了类别标签，PC/NC的监督学习模式则忽略了NC中的类别差异），挖掘、压榨、充分利用全部信息，促进更好的分类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Article </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019论文阅读列表</title>
      <link href="/article-2019-00/"/>
      <url>/article-2019-00/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读列表-2019"><a href="#论文阅读列表-2019" class="headerlink" title="论文阅读列表-2019"></a>论文阅读列表-2019</h1><h2 id="在读-已读列表"><a href="#在读-已读列表" class="headerlink" title="在读/已读列表"></a>在读/已读列表</h2><ol><li><a href="https://ieeexplore.ieee.org/document/7372153" target="_blank" rel="noopener">Entropy-Based Term Weighting Schemes for Text Categorization in VSM</a></li><li><a href="https://www.aclweb.org/anthology/D14-1181/" target="_blank" rel="noopener">Convolutional Neural Networks for Sentence Classification</a></li><li><a href="http://papers.nips.cc/paper/7181-attention-is-all-you-need" target="_blank" rel="noopener">Attention is All you Need</a></li><li><a href="http://kns.cnki.net/kcms/detail/61.1167.g3.20190910.1730.010.html" target="_blank" rel="noopener">黄炜,黄建桥,李岳峰.基于BiLSTM-CRF的涉恐信息实体识别模型研究</a></li><li>Neural Architectures for Named Entity Recognition</li><li>文本自动生成研究进展与趋势</li></ol><h2 id="候选列表"><a href="#候选列表" class="headerlink" title="候选列表"></a>候选列表</h2><ol><li>Man Lan, Chew Lim Tan, Jian Su, and Yue Lu. Supervised and traditional term weighting methods for automatic text categorization. <em>Pattern Analysis and Machine Intelligence, IEEE Transactions on</em>, 31(4):721–735, 2009.</li><li>Xinghua Lu, Bin Zheng, Atulya Velivelli, and ChengXiang Zhai. Enhancing text categorization with semantic-enriched representation and training data augmentation. <em>Journal of the American Medical Informatics Association</em>, 13(5):526–535, 2006.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Article </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
